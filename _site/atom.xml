<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>SiQi Blog</title>
 <link href="http://dreambt.github.com/atom.xml" rel="self"/>
 <link href="http://dreambt.github.com"/>
 <updated>2012-08-16T14:12:28+08:00</updated>
 <id>http://dreambt.github.com</id>
 <author>
   <name>dreambt</name>
   <email>dreambt@gmail.com</email>
 </author>

 
 <entry>
   <title>日志处理Log4j</title>
   <link href="http://dreambt.github.com/J2EE/2012/08/13/log4j"/>
   <updated>2012-08-13T04:53:11+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2012/08/13/log4j</id>
   <content type="html">&lt;h2&gt;日志分级&lt;/h2&gt;

&lt;p&gt;DEBUG
INFO
WARN
ERROR
FATAL&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>OAuth原理初探</title>
   <link href="http://dreambt.github.com/Security/2012/08/04/oauth2"/>
   <updated>2012-08-04T17:26:09+08:00</updated>
   <id>http://dreambt.github.com/Security/2012/08/04/oauth2</id>
   <content type="html">&lt;h2&gt;什么是OAuth&lt;/h2&gt;


&lt;p&gt;如今很多网站的功能都强调彼此间的交互，因此我们需要一种简单，标准的解决方案来安全的完成应用的授权，于是，OAuth应运而生，看看官网对其的定义：&lt;/p&gt;

&lt;blockquote&gt;An open protocol to allow secure API authorization  in a simple and standard method from desktop and web applications.&lt;/blockquote&gt;


&lt;p&gt;一个典型的OAuth应用通常包括三种角色，分别是：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Consumer：消费方&lt;/li&gt;
    &lt;li&gt;Service Provider：服务提供者&lt;/li&gt;
    &lt;li&gt;User：用户&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;用户好理解，不必多言，消费方和服务提供者则需要解释一下，举例来说：假设我们做了一个SNS，它有一个功能，可以让会员把他们在Google上的联系人导入到SNS上，那么此时的消费方就是SNS，而服务提供者则是Google。&lt;/p&gt;

&lt;p&gt;注：&lt;a href=&quot;http://code.google.com/more/&quot; target=&quot;_blank&quot;&gt;Google APIs&lt;/a&gt;支持&lt;a href=&quot;http://code.google.com/apis/accounts/docs/OAuth.html&quot; target=&quot;_blank&quot;&gt;OAuth&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;消费方如果想使用服务提供者的OAuth功能，通常需要先申请两样东西：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Consumer Key&lt;/li&gt;
    &lt;li&gt;Consumer Secret&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;当消费方生成签名的时候，会用到它们。&lt;/p&gt;

&lt;p&gt;一个典型的OAuth流程通常如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/08/oauth_flow.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1169&quot; title=&quot;oauth_flow&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/08/oauth_flow.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;535&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;A：消费方请求Request Token&lt;/li&gt;
    &lt;li&gt;B：服务提供者授权Request Token&lt;/li&gt;
    &lt;li&gt;C：消费方定向用户到服务提供者&lt;/li&gt;
    &lt;li&gt;D：获得用户授权后，服务提供者定向用户到消费方&lt;/li&gt;
    &lt;li&gt;E：消费方请求Access Token&lt;/li&gt;
    &lt;li&gt;F：服务提供者授权Access Token&lt;/li&gt;
    &lt;li&gt;G：消费方访问受保护的资源&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;基本就是用Request Token换取Access Token的过程。这里需要注意的是，对服务提供者而言，Request Token和Access Token的生命周期不一样，通常，Request Token的生命周期很短，一般在一个小时以内，这样相对安全一些；而Access Token的生命周期很长，往往是无限，如此一来，消费方就可以把它保存起来，以后的操作就无需用户再授权了，即便用户修改账号密码，也不会受影响，当然，用户可以废除消费方的授权。&lt;/p&gt;

&lt;h2&gt;有腿的OAuth&lt;/h2&gt;


&lt;p&gt;我们前面描述的OAuth，被称为三条腿的OAuth（3-Legged OAuth），这也是OAuth的标准版本。这里所谓的“三条腿”，指的是授权过程中涉及前面提到的三种角色，也就是：消费方，服务提供者，用户。不过有些情况下，不需要用户的参与，此时就产生了一个变体，被称作两条腿的OAuth（2-Legged OAuth），两条腿的OAuth和三条腿的OAuth相比，因为没有用户的参与，所以在流程中就不会涉及用户授权的环节，而主要是通过Consumer Key和Consumer Secret来完成签名的，此时的Consumer Key和Consumer Secret基本等价于账号和密码的作用。&lt;/p&gt;

&lt;h2&gt;OAuth简史&lt;/h2&gt;


&lt;p&gt;2007年12月4日发布了&lt;a href=&quot;http://oauth.net/core/1.0/&quot; target=&quot;_blank&quot;&gt;OAuth Core 1.0&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;此版本的协议存在严重的安全漏洞：&lt;a href=&quot;http://oauth.net/advisories/2009-1/&quot; target=&quot;_blank&quot;&gt;OAuth Security Advisory: 2009.1&lt;/a&gt;，更详细的介绍可以参考：&lt;a href=&quot;http://hueniverse.com/2009/04/explaining-the-oauth-session-fixation-attack/&quot; target=&quot;_blank&quot;&gt;Explaining the OAuth Session Fixation Attack&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;2009年6月24日发布了&lt;a href=&quot;http://oauth.net/core/1.0a/&quot; target=&quot;_blank&quot;&gt;OAuth Core 1.0 Revision A&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;此版本的协议修复了前一版本的安全漏洞，并成为&lt;a href=&quot;http://tools.ietf.org/html/rfc5849&quot; target=&quot;_blank&quot;&gt;RFC5849&lt;/a&gt;，我们现在使用的OAuth版本多半都是以此版本为基础。&lt;/p&gt;

&lt;p&gt;OAuth的未来：&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-oauth-v2&quot; target=&quot;_blank&quot;&gt;OAuth 2.0 Working Draft&lt;/a&gt;，…&lt;/p&gt;

&lt;h2&gt;OAuth四种授权流程&lt;/h2&gt;


&lt;p&gt;下面我们具体介绍一下OAuth2.0提供的四种授权流程：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Authorization Code&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可用范围：此类型可用于有服务端的应用，是最贴近老版本的方式。&lt;/p&gt;

&lt;pre&gt; +----------+
 | resource |
 |   owner  |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier      +---------------+
 |         -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;|               |
 |  User-   |                                 | Authorization |
 |  Agent  -+----(B)-- User authenticates ---&amp;gt;|     Server    |
 |          |                                 |               |
 |         -+----(C)-- Authorization Code ---&amp;lt;|               |
 +-|----|---+                                 +---------------+
   |    |                                         ^      v
  (A)  (C)                                        |      |
   |    |                                         |      |
   ^    v                                         |      |
 +---------+                                      |      |
 |         |&amp;gt;---(D)-- Authorization Code ---------'      |
 |  Client |          &amp;amp; Redirection URI                  |
 |         |                                             |
 |         |&amp;lt;---(E)----- Access Token -------------------'
 +---------+       (w/ Optional Refresh Token)&lt;/pre&gt;


&lt;p&gt;Client向Authorization Server发出申请（/oauth/2.0/authorize）：&lt;/p&gt;

&lt;pre&gt;response_type = code
client_id
redirect_uri
scope
state&lt;/pre&gt;


&lt;p&gt;Authorization Server在Resource Owner授权后给Client返回Authorization Code：&lt;/p&gt;

&lt;pre&gt;code
state&lt;/pre&gt;


&lt;p&gt;Client向Authorization Server发出申请（/oauth/2.0/token）：&lt;/p&gt;

&lt;pre&gt;grant_type = authorization_code
code
client_id
client_secret
redirect_uri&lt;/pre&gt;


&lt;p&gt;Authorization Server在Resource Owner授权后给Client返回Access Token：&lt;/p&gt;

&lt;pre&gt;access_token
token_type
expires_in
refresh_token&lt;/pre&gt;


&lt;p&gt;说明：基本流程就是拿Authorization Code换Access Token。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implicit Grant&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可用范围：此类型可用于没有服务端的应用，比如Javascript应用。&lt;/p&gt;

&lt;pre&gt; +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      ^
      |
     (B)
 +----|-----+          Client Identifier     +---------------+
 |         -+----(A)-- &amp;amp; Redirection URI ---&amp;gt;|               |
 |  User-   |                                | Authorization |
 |  Agent  -|----(B)-- User authenticates --&amp;gt;|     Server    |
 |          |                                |               |
 |          |&amp;lt;---(C)--- Redirection URI ----&amp;lt;|               |
 |          |          with Access Token     +---------------+
 |          |            in Fragment
 |          |                                +---------------+
 |          |----(D)--- Redirection URI ----&amp;gt;|   Web-Hosted  |
 |          |          without Fragment      |     Client    |
 |          |                                |    Resource   |
 |     (F)  |&amp;lt;---(E)------- Script ---------&amp;lt;|               |
 |          |                                +---------------+
 +-|--------+
   |    |
  (A)  (G) Access Token
   |    |
   ^    v
 +---------+
 |         |
 |  Client |
 |         |
 +---------+&lt;/pre&gt;


&lt;p&gt;Client向Authorization Server发出申请（/oauth/2.0/authorize）：&lt;/p&gt;

&lt;pre&gt;response_type = token
client_id
redirect_uri
scope
state&lt;/pre&gt;


&lt;p&gt;Authorization Server在Resource Owner授权后给Client返回Access Token：&lt;/p&gt;

&lt;pre&gt;access_token
token_type
expires_in
scope
state&lt;/pre&gt;


&lt;p&gt;说明：没有服务端的应用，其信息只能保存在客户端，如果使用Authorization Code授权方式的话，无法保证client_secret的安全。BTW：不返回Refresh Token。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resource Owner Password Credentials&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可用范围：不管有无服务端，此类型都可用。&lt;/p&gt;

&lt;pre&gt; +----------+
 | Resource |
 |  Owner   |
 |          |
 +----------+
      v
      |    Resource Owner
     (A) Password Credentials
      |
      v
 +---------+                                  +---------------+
 |         |&amp;gt;--(B)---- Resource Owner -------&amp;gt;|               |
 |         |         Password Credentials     | Authorization |
 | Client  |                                  |     Server    |
 |         |&amp;lt;--(C)---- Access Token ---------&amp;lt;|               |
 |         |    (w/ Optional Refresh Token)   |               |
 +---------+                                  +---------------+&lt;/pre&gt;


&lt;p&gt;Clien向Authorization Server发出申请（/oauth/2.0/token）：&lt;/p&gt;

&lt;pre&gt;grant_type = password
username
password
scope&lt;/pre&gt;


&lt;p&gt;AuthorizationServer给Client返回AccessToken：&lt;/p&gt;

&lt;pre&gt;access_token
token_type
expires_in
refresh_token&lt;/pre&gt;


&lt;p&gt;说明：因为涉及用户名和密码，所以此授权类型仅适用于可信赖的应用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Client Credentials&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可用范围：不管有无服务端，此类型都可用。&lt;/p&gt;

&lt;pre&gt; +---------+                                  +---------------+
 |         |                                  |               |
 |         |&amp;gt;--(A)- Client Authentication ---&amp;gt;| Authorization |
 | Client  |                                  |     Server    |
 |         |&amp;lt;--(B)---- Access Token ---------&amp;lt;|               |
 |         |                                  |               |
 +---------+                                  +---------------+&lt;/pre&gt;


&lt;p&gt;Client向Authorization Server发出申请（/oauth/2.0/token）：&lt;/p&gt;

&lt;pre&gt;grant_type = client_credentials
client_id
client_secret
scope&lt;/pre&gt;


&lt;p&gt;Authorization Server给Client返回Access Token：&lt;/p&gt;

&lt;pre&gt;access_token
token_type
expires_in&lt;/pre&gt;


&lt;p&gt;说明：此授权类型仅适用于获取与用户无关的公共信息。BTW：不返回Refresh Token。&lt;/p&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;流程中涉及两种Token，分别是Access Token和Refresh Token。通常，Access Token的有效期比较短，而Refresh Token的有效期比较长，如此一来，当Access Token失效的时候，就需要用Refresh Token刷新出有效的Access Token：&lt;/p&gt;

&lt;pre&gt; +--------+                                         +---------------+
 |        |--(A)------- Authorization Grant -------&amp;gt;|               |
 |        |                                         |               |
 |        |&amp;lt;-(B)----------- Access Token -----------|               |
 |        |               &amp;amp; Refresh Token           |               |
 |        |                                         |               |
 |        |                            +----------+ |               |
 |        |--(C)---- Access Token ----&amp;gt;|          | |               |
 |        |                            |          | |               |
 |        |&amp;lt;-(D)- Protected Resource --| Resource | | Authorization |
 | Client |                            |  Server  | |     Server    |
 |        |--(E)---- Access Token ----&amp;gt;|          | |               |
 |        |                            |          | |               |
 |        |&amp;lt;-(F)- Invalid Token Error -|          | |               |
 |        |                            +----------+ |               |
 |        |                                         |               |
 |        |--(G)----------- Refresh Token ---------&amp;gt;|               |
 |        |                                         |               |
 |        |&amp;lt;-(H)----------- Access Token -----------|               |
 +--------+           &amp;amp; Optional Refresh Token      +---------------+&lt;/pre&gt;


&lt;p&gt;Client向Authorization Server发出申请（/oauth/2.0/token）：&lt;/p&gt;

&lt;pre&gt;grant_type = refresh_token
refresh_token
client_id
client_secret
scope&lt;/pre&gt;


&lt;p&gt;Authorization Server给Client返回Access Token：&lt;/p&gt;

&lt;pre&gt;access_token
expires_in
refresh_token
scope&lt;/pre&gt;


&lt;h2&gt;OAuth和OpenID的区别&lt;/h2&gt;


&lt;p&gt;OAuth关注的是&lt;a href=&quot;http://dict.youdao.com/search?q=authorization&quot; target=&quot;_blank&quot;&gt;authorization&lt;/a&gt;；而OpenID侧重的是&lt;a href=&quot;http://dict.youdao.com/search?q=authentication&quot; target=&quot;_blank&quot;&gt;authentication&lt;/a&gt;。从表面上看，这两个英文单词很容易混淆，但实际上，它们的含义有本质的区别：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;authorization: n. 授权，认可；批准，委任&lt;/li&gt;
    &lt;li&gt;authentication: n. 证明；鉴定；证实&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;OAuth关注的是授权，即：“用户能做什么”；而OpenID关注的是证明，即：“用户是谁”。&lt;/p&gt;

&lt;p&gt;如果混淆了OAuth和OpenID的含义，后果很严重。以国内某网站开发的应用为例：它的功能是通过OAuth授权让新浪微博和豆瓣的用户使用各自的身份发表评论，如下图所示：&lt;/p&gt;

&lt;p&gt;此类应用属于身份证明问题，本应该通过OpenID来实现，但因为错误的使用了OAuth，从而带来安全隐患：设想一下用户只是在网站上发表了评论而已，但却赋予了网站随意操作自己私有数据的权利！这就好比：快递员送包裹，为了证明收件人的身份，原本你只要给他看一下身份证即可，可你却把防盗门钥匙都给他了！Oh，My God！&lt;/p&gt;

&lt;p&gt;BTW：关于OAuth详细的介绍可以参考&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-oauth-v2-31&quot;&gt;http://tools.ietf.org/html/draft-ietf-oauth-v2-31&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&quot;http://huoding.com/2010/10/10/8&quot;&gt;http://huoding.com/2010/10/10/8&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ESXi相关问题解决</title>
   <link href="http://dreambt.github.com/Cloud/2012/08/02/esxi"/>
   <updated>2012-08-02T17:19:05+08:00</updated>
   <id>http://dreambt.github.com/Cloud/2012/08/02/esxi</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;1.5.0如何挂载U盘？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;esxi 4.1是可以自动挂的，5.0不可以。挂载办法如下：&lt;/p&gt;

&lt;p&gt;你先运行 /etc/init.d/usbarbitrator stop
然后重新插入u盘，顺利的话可以在/vmfs/volumes/下看到一个新的目录(对应u盘)&lt;/p&gt;

&lt;p&gt;但是在挂之前要注意，esxi只支持对 fat/ext3/vmfs分区的读写， fat32（有的人说可以，但很多限制）和ntfs是不支持的， 这一点要注意。&lt;/p&gt;

&lt;p&gt;如果用完后，拔出U盘， 运行  /etc/init.d/usbarbitrator start&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之Kit抽象工厂</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/07/07/gof-kit"/>
   <updated>2012-07-07T18:04:58+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/07/07/gof-kit</id>
   <content type="html">&lt;p&gt;抽象工厂（Kit）模式提供一个接口，用来创建相关或依赖对象的家族，而不需要明确指定具体类。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;抽象工厂模式面对的问题是多个产品等级结构的系统设计&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象工厂模式是工厂方法的进一步推广&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象工厂将产品对象的创建延迟到它的具体工厂的子类。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通常在运行时刻创建一个具体工厂类的实例，这一具体工厂的创建具有特定实现的产品对象，为创建不同的产品对象，客户应使用不同的具体工厂。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/12.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1161&quot; title=&quot;1&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/12.jpg&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;268&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;抽象工厂（提供不同等级结构的产品工厂）：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface Creator
{
    public ProductA factoryA();

    public ProductB factoryB();
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;具体工厂（实现不同等级结构中的某一族产品对象）：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteCreator1 implements Creator
{
    public ProductA factoryA()
    {
        return new ProductA1();
    }

    public ProductB factoryB()
    {
        return new ProductB1();
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteCreator2 implements Creator
{
    public ProductA factoryA()
    {
        return new ProductA1();
    }

    public ProductB factoryB()
    {
        return new ProductB1();
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;抽象产品：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface ProductA
{
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface ProductB
{
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;具体产品：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ProductA1 implements ProductA
{
    public ProductA1()
    {
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ProductA2 implements ProductA
{
    public ProductA2()
    {
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ProductB1 implements ProductA
{
    public ProductB1()
    {
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ProductB2 implements ProductA
{
    public ProductB2()
    {
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;相图：&lt;/p&gt;

&lt;p&gt;每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族、但是分属于不同等级结构的产品。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/2.gif&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1162&quot; title=&quot;2&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/2.gif&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;213&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节。这对于所有形态的工厂模式都是重要的&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;同属于同一个产品族的产品是在一起使用的，这一约束必须要在系统的设计中体现出来&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;参与者：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;AbstractFactory：创建抽象产品对象的接口&lt;/li&gt;
    &lt;li&gt;ConcreteFactory：实现创建具体产品对象的操作&lt;/li&gt;
    &lt;li&gt;AbstractProduct：为一类产品对象声明一个接口&lt;/li&gt;
    &lt;li&gt;ConcreteProduct：定义一个将被相应的具体工厂创建的产品对象，实现AbstractProduct接口&lt;/li&gt;
    &lt;li&gt;Client：仅使用由AbstractFactory和AbstractProduct类声明的接口&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;分离了具体的类。抽象工厂模式帮助你控制一个应用创建的对象的类，因为一个工厂封装创建产品对象的责任和过程。它将客户和类的实现分离，客户通过他们的抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它使得易于交换产品系列。一个具体工厂类在一个应用中仅出现一次——即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;它有利于产品的一致性。当一个系列的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要，而抽象工厂很容易实现这一点。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;增加新的产品等级结构的时候，要改变抽象工厂接口，不支持“开－闭”原则&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之工厂方法模式</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/07/05/gof-factory-method"/>
   <updated>2012-07-05T23:08:53+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/07/05/gof-factory-method</id>
   <content type="html">&lt;p&gt;工厂方法模式（别名Virtual Constructor）定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工厂方法让子类决定要实例化的类是哪一个。所谓的“决定”并不是指模式允许子类本身在运行时做决定，而是指编写抽象工厂类时，不需要知道实际创建的产品是哪一个。选择使用了那个子类，自然就决定了实际使用的产品是什么。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂方法模式是由简单工厂经过重构（利用多态性替换复杂的if else逻辑）而成。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂方法是简单工厂的推广，简单工厂是工厂方法的退化。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不接触哪一个产品类被实例化这种细节。这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。在Factory Method模式中，工厂类与产品类往往具有平行的等级结构，它们之间一一对应。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工厂方法不一定每一次都返还一个新的对象。但是它所返还的对象一定是他自己创建的，而不是在一个外部对象里面创建，然后传入工厂对象中的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;原则：&lt;/p&gt;

&lt;p&gt;依赖倒置原则：要依赖抽象，不要依赖具体类。&lt;/p&gt;

&lt;p&gt;依赖倒置的指导方针：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;变量不可以持有具体类的引用&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要让类派生自具体类&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要覆盖基类中已经实现的方法&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;aligncenter size-full wp-image-1158&quot; title=&quot;1&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/11.jpg&quot; alt=&quot;&quot; width=&quot;582&quot; height=&quot;173&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;抽象工厂（工厂方法模式的核心，也可以是抽象类）：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface Creator
{
    public Product factory();
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;具体工厂：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteCreator1 implements Creator
{
    public Product factory()
    {
        return new ConcreteProduct1();
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteCreator2 implements Creator
{
    public Product factory()
    {
        return new ConcreteProduct2();
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;抽象产品：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface Product
{
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;具体产品：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteProduct1 implements Product
{
    public ConcreteProduct1()
    {
    System.out.println(&quot;CocnreteProduct1 is being created.&quot;);
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteProduct2 implements Product
{
    public ConcreteProduct2()
    {
    System.out.println(&quot;CocnreteProduct2 is being created.&quot;);
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;p&gt;在以下情况下，适用于Factory Method模式：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;当一个类不知道它所必须创建的对象的类的时候。&lt;/li&gt;
    &lt;li&gt;当一个类希望由它的子类来指定它所创建的对象的时候。&lt;/li&gt;
    &lt;li&gt;当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;参与者：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;Product:定义工厂方法所创建的对象的接口&lt;/li&gt;
    &lt;li&gt;ConcreteProduct:实现Product接口&lt;/li&gt;
    &lt;li&gt;Creator:&lt;/li&gt;
&lt;/ol&gt;


&lt;ul&gt;
    &lt;li&gt;声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。&lt;/li&gt;
    &lt;li&gt;工厂方法可以带参数，由参数决定返回的产品实例。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;4.  ConcreteCreator：实现Creator以返回一个ConcreteProduct实例&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之Decorator装饰者模式</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/07/04/gof-decorator"/>
   <updated>2012-07-04T19:36:04+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/07/04/gof-decorator</id>
   <content type="html">&lt;p&gt;装饰者模式&lt;/p&gt;

&lt;p&gt;Decorator模式（别名Wrapper）：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;意图：&lt;/p&gt;

&lt;p&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;设计原则：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;多用组合，少用继承。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;类应设计的对扩展开放，对修改关闭。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;要点：&lt;/p&gt;

&lt;p&gt;1． 装饰者和被装饰对象有相同的超类型。&lt;/p&gt;

&lt;p&gt;2． 可以用一个或多个装饰者包装一个对象。&lt;/p&gt;

&lt;p&gt;3． 装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。&lt;/p&gt;

&lt;p&gt;4． 对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。&lt;/p&gt;

&lt;p&gt;5． 装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。&lt;/p&gt;

&lt;p&gt;6． 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。&lt;/p&gt;

&lt;p&gt;7． 适配器模式的用意是改变对象的接口而不一定改变对象的性能，而装饰模式的用意是保持接口并增加对象的职责。&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/1.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1148&quot; title=&quot;1&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/1.jpg&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;330&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Component：&lt;/p&gt;

&lt;p&gt;定义一个对象接口，可以给这些对象动态地添加职责。&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface Component
{
    void operation();
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Concrete Component：&lt;/p&gt;

&lt;p&gt;定义一个对象，可以给这个对象添加一些职责。&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteComponent implements Component
{
    public void operation()
    {
        // Write your code here
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Decorator：&lt;/p&gt;

&lt;p&gt;维持一个指向Component对象的引用，并定义一个与 Component接口一致的接口。&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class Decorator implements Component
{
    public Decorator(Component component)
    {
        this.component = component;
    }

    public void operation()
    {
        component.operation();
    }

    private Component component;
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Concrete Decorator：&lt;/p&gt;

&lt;p&gt;在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteDecorator extends Decorator
{
    public void operation()
    {
        //addBehavior也可以在前面

        super.operation();

        addBehavior();
    }

    private void addBehavior()
    {
        //your code
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;模式的简化：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果只有一个Concrete Component类而没有抽象的Component接口时，可以让Decorator继承Concrete Component。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/2.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1149&quot; title=&quot;2&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/2.jpg&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;315&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;如果只有一个Concrete Decorator类时，可以将Decorator和Concrete Decorator合并。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/3.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1150&quot; title=&quot;3&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/3.jpg&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;221&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;p&gt;以下情况使用Decorator模式&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;需要扩展一个类的功能，或给一个类添加附加职责。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要动态的给一个对象添加功能，这些功能可以再动态的撤销。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变的不现实。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;这种比继承更加灵活机动的特性，也同时意味着更加多的复杂性。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装饰模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;装饰模式是针对抽象组件（Component）类型编程。但是，如果你要针对具体组件编程时，就应该重新思考你的应用架构，以及装饰者是否合适。当然也可以改变Component接口，增加新的公开的行为，实现“半透明”的装饰者模式。在实际项目中要做出最佳选择。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;装饰模式在Java I/O库中的应用：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/07/4.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1151&quot; title=&quot;4&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/07/4.jpg&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;247&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;编写一个装饰者把所有的输入流内的大写字符转化成小写字符：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;

public class LowerCaseInputStream extends FilterInputStream
{
    protected LowerCaseInputStream(InputStream in)
    {
        super(in);
    }

    @Override
    public int read() throws IOException
    {
        int c = super.read();
        return (c == -1 ? c : Character.toLowerCase((char) c));
    }

    @Override
    public int read(byte[] b, int offset, int len) throws IOException
    {
        int result = super.read(b, offset, len);

        for (int i = offset; i &amp;lt; offset + result; i++)
        {
            b[i] = (byte) Character.toLowerCase((char) b[i]);
        }

        return result;

    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;测试我们的装饰者类：&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;import java.io.*;

public class InputTest
{
    public static void main(String[] args) throws IOException
    {
        int c;

        try
        {
            InputStream in = new LowerCaseInputStream(new BufferedInputStream(
                    new FileInputStream(&quot;D:\\test.txt&quot;)));

            while ((c = in.read()) &amp;gt;= 0)
            {
                System.out.print((char) c);
            }

            in.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }
}&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之简单工厂模式</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/07/04/gof-simply-factory"/>
   <updated>2012-07-04T15:18:23+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/07/04/gof-simply-factory</id>
   <content type="html">&lt;p&gt;简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/03/1.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1153&quot; title=&quot;1&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/03/1.jpg&quot; alt=&quot;&quot; width=&quot;501&quot; height=&quot;180&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;工厂类:&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class Creator
{
    public static Product factory()
    {
        return new ConcreteProduct();
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;抽象产品:&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public interface Product
{
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;具体产品:&lt;/p&gt;

&lt;div&gt;
&lt;pre&gt;public class ConcreteProduct implements Product
{
    public ConcreteProduct(){}
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现要点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工厂类可以根据传入的参数决定创建出哪一种产品类的实例。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体产品有共同的商业逻辑，那么这些公有的逻辑就应当移到抽象角色里面，这就意味着抽象角色应当由一个抽象类扮演。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每个工厂类可以有多于一个的工厂方法，分别负责创建不同的产品对象。如java.text.DateFormat 类&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;特例：&lt;/p&gt;

&lt;p&gt;如果只有一个具体产品的话，抽象产品可以省略&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/03/2.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1154&quot; title=&quot;2&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/03/2.jpg&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;84&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;在某些情况下，可以由抽象产品扮演工厂类的角色，典型的应用就是java.text.DateFormat，一个抽象产品担当子类的工厂&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/03/3.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1155&quot; title=&quot;3&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/03/3.jpg&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;190&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;如果抽象产品再省略的话，可以做到三者合并，这样一个产品类为自身的工厂&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/03/4.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1156&quot; title=&quot;4&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/03/4.jpg&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;104&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;模式的核心是工厂类。工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例。而客户端则可以免除直接创建产品的责任，而仅仅负责“消费”产品。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;工厂类成为“全能类”，添加新的产品或扩展功能时会非常复杂&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;经常使用static方法作为工厂方法（也叫静态工厂方法），不能通过继承来改变创建方法的行为。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;在java中的应用：&lt;/p&gt;

&lt;p&gt;DateFormat和sax2库中的XMLReaderFactory&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之Observer观察者模式</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/06/29/gof-observer"/>
   <updated>2012-06-29T22:59:50+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/06/29/gof-observer</id>
   <content type="html">&lt;p&gt;观察者模式（别名Publish-Subscribe）:定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;生活中的实例：&lt;/p&gt;

&lt;p&gt;订阅报纸杂志&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;报社的业务就是出版报纸。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;向某家报社订阅报纸，只要他们有新报纸出版，就会给你送来。只要你是他们的订户，你就会一直收到新报纸。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当你不想再看报纸的时候，取消订阅，他们就不会再送新报纸来。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;只要报社还在运营，就会一直有人（或单位）向他们订阅报纸或取消订阅报纸。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;要点：&lt;/p&gt;

&lt;p&gt;1． 主题用一个共同的接口来通知观察者(notifyObservers)&lt;/p&gt;

&lt;p&gt;2． 主题和观察者之间松耦合，主题不知道观察者的细节，只知道观察者实现了观察者接口(update)&lt;/p&gt;

&lt;p&gt;3． 推、拉模式各有千秋,推的实现要简单一些&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/06/observer.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1141&quot; title=&quot;observer&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/06/observer.jpg&quot; alt=&quot;&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Subject：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Subject可以加将Observer对象的引用保存在一个聚集中，每个Subject可以有任意个Observer。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;提供注册和删除Observer对象的接口。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;div&gt;
&lt;pre&gt;public interface Subject {
    public void registerObserver(Observer o);
    public void removeObserver(Observer o);
    public void notifyObservers();
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Observer：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;为那些在Subject发生改变时需获得通知的对象定义一个更新接口。&lt;/li&gt;
&lt;/ol&gt;


&lt;div&gt;
&lt;pre&gt;public interface Observer {
    public void update();
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Concrete Subject：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将有关状态存入各 ConcreteObserver对象，当它的状态发生改变时，向它的各个观察者发出通知。&lt;/li&gt;
&lt;/ol&gt;


&lt;div&gt;
&lt;pre&gt;public class ConcreteSubject implements Subject {

    private ArrayList&amp;lt;Observer&amp;gt; observers;

    public ConcreteSubject() {
        observers = new ArrayList&amp;lt;Observer&amp;gt;();        
    }

    public void registerObserver(Observer o) {      
        observers.add(o);       
    }

    public void removeObserver(Observer o) {        
        int i = observers.indexOf(o);       
        if (i &amp;gt;= 0) {            
            observers.remove(i);            
        }       
    }

    public void notifyObservers() {     
        for (int i = 0; i &amp;lt; observers.size(); i++) {         
            observer = observers.get(i);            
            observer.update();          
        }       
    }

    public void stateChanged() {        
        notifyObservers();      
    }

    public void setState() {        
        stateChanged();     
    }
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Concrete Observer：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;维护一个指向ConcreteSubject对象的引用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;存储有关状态，这些状态应与Subject的状态保持一致。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实现Observer的更新接口以使自身状态与Subject的状态保持一致。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;div&gt;
&lt;pre&gt;public class ConcreteObserver implements Observer {

    private Subject subject;

    public ConcreteObserver(Subject subject) {
        this.subject = subject;     
        subject.registerObserver(this);     
    }

    public void update() {      
        // your code        
    }   
}&lt;/pre&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;Java对观察者模式的实现：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java.util.Observable相当与Subject，发出通知时应该先调用setChanged()方法，再调用notifyObservers方法通知观察者。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以把数据封装成对象传入notifyObservers(Object arg)，观察者调用update(Obserable o,Object arg)取出数据，实现推模式。如果调用notifyObservers()，观察者调用update(Obserable o,Object arg)取出Obserable，再调用它的get状态方法，实现拉模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当一个抽象模型有两个方面，其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象有待改变。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧密耦合的。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;目标和观察者间的松耦合。一个目标所知道的仅仅是它有一系列观察者，每个都符合抽象的 Observer类的简单接口。目标不知道任何一个观察者属于哪一个具体的类。这样目标和观察者之间的耦合是抽象的和最小的。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;支持广播通信，主题向所有登记过的观察者发出通知。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;缺点:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;意外的更新。因为一个观察者并不知道其它观察者的存在，它可能对改变目标的最终代价一无所知。在目标上一个看似无害的的操作可能会引起一系列对观察者以及依赖于这些观察者的那些对象的更新。此外，如果依赖准则的定义或维护不当，常常会引起错误的更新，这种错误通常很难捕捉。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个主题对象有很多直接或间接的观察者对象，将所有的观察者都通知会花费很多时间。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果对观察者的通知是在另外的线程异步进行的话，要额外注意多线程操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之Policy策略模式</title>
   <link href="http://dreambt.github.com/Design Pattern/2012/06/27/gof-policy"/>
   <updated>2012-06-27T22:58:01+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2012/06/27/gof-policy</id>
   <content type="html">&lt;p&gt;策略模式（别名Policy）: 定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;使用继承的缺点：&lt;/p&gt;

&lt;p&gt;1． 代码在多个子类中重复&lt;/p&gt;

&lt;p&gt;2． 运行时的行为不容易改变&lt;/p&gt;

&lt;p&gt;3． 很难抽象出子类的全部行为&lt;/p&gt;

&lt;p&gt;4． 牵一发而动全身&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;设计原则:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;把会变化的部分取出来进行封装，以便以后可以轻易的改动或扩充该部分，而不影响不需要变化的其他部分&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;针对接口编程，而不是针对实现编程&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;少用继承，多用组合&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;a) 策略模式找出会变化的算法，将它们封装出来，再利用组合将算法抽象接口整合进系统中以达到松耦合的目的。&lt;/p&gt;

&lt;p&gt;b) 当准备在一个系统里面使用策略模式的时，首先必须找到需要包装的算法，看看算法是否可以从环境中分割出来，最后再考察这些算法是否会在以后发生变化。&lt;/p&gt;

&lt;p&gt;c) 策略模式不适合于处理同时嵌套多于一个算法的情形。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2012/06/policy.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1138&quot; title=&quot;policy&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/06/policy.jpg&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;222&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;环境(context)角色:&lt;/p&gt;

&lt;p&gt;持有一个Strategy的引用，用一个具体的ConcreteStrategy对象来配置自己的ContextInterface行为&lt;/p&gt;

&lt;p&gt;public class Context{
private Strategy strategy;
public void contextInterface(){
strategy.strategyInterface();
}
}&lt;/p&gt;

&lt;p&gt;Strategy接口角色：定义所有算法的公共接口，可以由Interface和抽象类实现&lt;/p&gt;

&lt;p&gt;abstract public class Strategy{
public abstract void strategyInterface();
}&lt;/p&gt;

&lt;p&gt;ConcreteStrategy角色：以Strategy接口实现具体的算法&lt;/p&gt;

&lt;p&gt;public class ConcreteStrategy extends Strategy{
public void strategyInterface(){
//write you algorithm code here
}
}&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;适用性：&lt;/p&gt;

&lt;p&gt;当存在以下情况时使用strategy模式:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如果一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个系统需要动态的在几种算法中选择一种。那么这些算法可以包装到一个个的具体算法类里面，而这些算法类都是一个抽象算法类的子类。换言之，这些具体算法类均有统一的接口，由于多态性原则，客户端可以选择使用任何一个具体算法类，并只持有一个数据类型是抽象算法的对象。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;一个系统的算法使用的数据不可以让客户端知道。策略模式可以避免让客户端涉及到不必要接触到的和复杂的只与算法有关的数据。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现。将相关的条件分支移到它们各自的Strategy类中以代替这些条件语句。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Strategy类层次为Context定义了一系列可供重用的算法或行为，继承有助于析取出这些算法中的公共部分。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消除了一些条件语句，Strategy利用继承这一多态性避免了使用多重条件转移语句。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strategy将变化的算法封装出来，使得客户端动态改变算法或行为变的可能。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时的选择合适的算法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Strategy造就了很多的策略类，增加了对象的数目。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>运行phpize时出现：Cannot find autoconf. Please check your autoconf installation</title>
   <link href="http://dreambt.github.com/PHP/2012/06/06/cannot-find-autoconf-please-check-your-autoconf-installation"/>
   <updated>2012-06-06T18:29:50+08:00</updated>
   <id>http://dreambt.github.com/PHP/2012/06/06/cannot-find-autoconf-please-check-your-autoconf-installation</id>
   <content type="html">&lt;p&gt;运行/usr/local/php/bin/phpize时出现 Cannot find autoconf. Please check your autoconf installation：&lt;/p&gt;

&lt;p&gt;Configuring for:
PHP Api Version:         20041225
Zend Module Api No:      20060613
Zend Extension Api No:   220060519
Cannot find autoconf. Please check your autoconf installation and the
$PHP_AUTOCONF environment variable. Then, rerun this script.&lt;/p&gt;

&lt;p&gt;根据网上的解决办法是：&lt;/p&gt;

&lt;pre&gt;cd /usr/src
wget http://ftp.gnu.org/gnu/m4/m4-1.4.16.tar.gz
tar -zvxf m4-1.4.16.tar.gz
cd m4-1.4.16/
./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install
cd ../
wget http://ftp.gnu.org/gnu/autoconf/autoconf-2.69.tar.gz
tar -zvxf autoconf-2.69.tar.gz
cd autoconf-2.69/
./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>如何书写高质量的Java源代码</title>
   <link href="http://dreambt.github.com/Java/2012/03/25/how-to-write-high-quality-java-source-code"/>
   <updated>2012-03-25T18:06:59+08:00</updated>
   <id>http://dreambt.github.com/Java/2012/03/25/how-to-write-high-quality-java-source-code</id>
   <content type="html">&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：WMI_WRONG_MAP_ITERATOR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;for(String key : blackItemsMap.keySet()) {
List&amp;lt;BlockListDO&amp;gt; item = blackItemsMap.get(key);
if (null == item || item.isEmpty())
continue;
else ....
}&lt;/pre&gt;


&lt;p&gt;解读：遍历Map时使用了效率低下的方法，比如：先一个一个的把key遍历，然后在根据key去查找value，为什么不遍历entry（桶）然后直接从entry得到value呢？它们的执行效率大概为1.5:1（有人实际测试过）。 我们看看HashMap.get方法的源代码：&lt;/p&gt;

&lt;pre&gt;public V get(Object key) {
if (key == null)
return getForNullKey();
int hash = hash(key.hashCode());
for (Entry&amp;lt;K,V&amp;gt; e = table[indexFor(hash, table.length)];
e != null;
e = e.next) {
Object k;
if (e.hash == hash &amp;amp;&amp;amp; ((k = e.key) == key || key.equals(k)))
return e.value;
}
return null;
}&lt;/pre&gt;


&lt;p&gt;从这里可以看出查找value的原理，先计算出hashcode，然后散列表里取出entry，不管是计算hashcode，还是执行循环for以及执行equals方法，都是CPU密集运算，非常耗费CPU资源，如果对一个比较大的map进行遍历，会出现CPU迅速飚高的现象，直接影响机器的响应速度，在并发的情况下，简直就是一场灾难。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;for (Map.Entry&amp;lt;String, JMenu&amp;gt; entry : menuList.entrySet()) {
mb.add(entry.getValue());
}&lt;/pre&gt;


&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：EI_EXPOSE_REP2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;public Date getCreatedTime() {
return this.createdTime;
}&lt;/pre&gt;


&lt;p&gt;解读：此代码存储到一个到对象的内部表示外部可变对象的引用。如果实例是由不受信任的代码，并以可变对象会危及安全或其他重要的属性选中更改访问，你需要做不同的东西。存储一个对象的副本，在许多情况下是更好的办法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;public Date getGmtCreate() {
if(this.gmtCreate != null)
return new Date(this.gmtCreate.getTime()); //正确值
else
return null;
}&lt;/pre&gt;


&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：DM_FP_NUMBER_CTOR&lt;/strong&gt;、&lt;strong&gt;DM_NUMBER_CTOR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实例：UnitTestUtil.setObjectValue(new Double(123.456));&lt;/p&gt;

&lt;p&gt;解读：采用new Ddouble(double)会产生一个新的对象，采用Ddouble.valueOf(double)在编译的时候可能通过缓存经常请求的值来显著提高空间和时间性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;最佳实践&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.采用Ddouble.valueOf方法，&lt;/p&gt;

&lt;p&gt;2.推荐使用Integer.ValueOf(int)代替new Integer(int)，因为这样可以提高性能。如果当你的int值介于-128～127时，Integer.ValueOf(int)的效率比Integer(int)快大约3.5倍。看一下Integer.ValueOf(int)的源代码：&lt;/p&gt;

&lt;pre&gt;public static Integer valueOf(int i) {
final int offset = 128;
if (i &amp;gt;= -128 &amp;amp;&amp;amp; i &amp;lt;= 127) { // must cache
return IntegerCache.cache[i + offset];
}
return new Integer(i);
}&lt;/pre&gt;


&lt;pre&gt;private static class IntegerCache {
private IntegerCache(){}

static final Integer cache[] = new Integer[-(-128) + 127 + 1];
static {
for(int i = 0; i &amp;lt; cache.length; i++)
cache = new Integer(i - 128);
}
}&lt;/pre&gt;


&lt;p&gt;运行如下代码，思考上面的话：&lt;/p&gt;

&lt;pre&gt;public static void main(String []args) {
Integer a = 100;
Integer b = 100;
System.out.println(a==b);

Integer c = new Integer(100);
Integer d = new Integer(100);
System.out.println(c==d);
}

public static void main(String args[]) throws Exception{
Integer a = 100;
Integer b = a;
a = a + 1;　　//或者a++;
System.out.println(a==b);
}&lt;/pre&gt;


&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：DM_BOOLEAN_CTOR&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实例：int number = Math.abs(sellerId.hasCode());&lt;/p&gt;

&lt;p&gt;解读：此代码产生的哈希码，然后计算该哈希码的绝对值。如果哈希码是Integer.MIN_VALUE的，那么结果将是负面的，以及（因为Math.abs（Integer.MIN_VALUE的）==Integer.MIN_VALUE的）。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在使用之前判断一下是否是为Integer.MIN_VALUE&lt;/p&gt;

&lt;pre&gt;int iTemp = sellerId.hashCode();
if(iTemp != Integer.MIN_VALUE) {
number = Math.abs(iTemp) % 12;
} else {
number = Integer.MIN_VALUE % 12;
}&lt;/pre&gt;


&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：SE_NO_SERIALVERSIONID&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：实现了Serializable接口，却没有实现定义serialVersionUID字段，序列化的时候，我们的对象都保存为硬盘上的一个文件，当通过网络传输或者其他类加载方式还原为一个对象时，serialVersionUID字段会保证这个对象的兼容性，考虑两种情况：
1. 新软件读取老文件，如果新软件有新的数据定义，那么它们必然会丢失。
2. 老软件读取新文件，只要数据是向下兼容的，就没有任何问题。
序列化会把所有与你要序列化对象相关的引用（包括父类，特别是内部类持有对外部类的引用，这里的例子就符合这种情况）都输出到一个文件中，这也是为什么能够使用序列化能进行深拷贝。这种序列化算法给我们的忠告是，不要把一些你无法确定其基本数据类型的对象引用作为你序列化的字段（比如JFrame），否则序列化后的文件超大，而且会出现意想不到的异常。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;定义serialVersionUID字段&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：DM_GC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：
1. System.gc()只是建议，不是命令，JVM不能保证立刻执行垃圾回收。
2. System.gc()被显示调用时，很大可能会触发Full GC。&lt;/p&gt;

&lt;p&gt;GC有两种类型：Scavenge GC和Full GC&lt;/p&gt;

&lt;p&gt;Scavenge GC一般是针对年轻代区（Eden区）进行GC，不会影响老年代和永生代（PerGen），由于大部分对象都是从Eden区开始的，所以Scavenge GC会频繁进行，GC算法速度也更快，效率更高&lt;/p&gt;

&lt;p&gt;但是Full GC不同，Full GC是对整个堆进行整理，包括Young、Tenured和Perm，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;去掉System.gc()&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：DP_DO_INSIDE_DO_PRIVILEGED&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：此代码调用一个方法，需要一个安全权限检查。如果此代码将被授予安全权限，但可能是由代码不具有安全权限调用，则需要调用发生在一个doPrivileged的块。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;一般情况下，我们并不能对类的私有字段进行操作，利用反射也不例外，但有的时候，例如要序列化的时候，我们又必须有能力去处理这些字段，这时候，我们就需要调用AccessibleObject上的setAccessible()方法来允许这种访问，而由于反射类中的Field，Method和Constructor继承自AccessibleObject，因此，通过在这些类上调用setAccessible()方法，我们可以实现对这些字段的操作。但有的时候这将会成为一个安全隐患，为此，我们可以启用java.security.manager来判断程序是否具有调用setAccessible()的权限。默认情况下，内核API和扩展目录的代码具有该权限，而类路径或通过URLClassLoader加载的应用程序不拥有此权限。例如：当我们以这种方式来执行上述程序时将会抛出异常&lt;/p&gt;

&lt;p&gt;增加：} catch (SecurityException e) {&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：NP_NULL_ON_SOME_PATH&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：方法中存在空指针&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在对实例做操作前，先对字段做为空的判断&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;实例：&lt;/p&gt;

&lt;pre&gt;if (bean2 == null) {
return bean1 == null;
}&lt;/pre&gt;


&lt;p&gt;解读：这种方法包含了一个称为非空对空值的不断重复检查。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;if (bean2 == null) {
return false;
}&lt;/pre&gt;


&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：SS_SHOULD_BE_STATIC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：final成员变量表示常量，只能被赋值一次，赋值后值不再改变。 这个类包含的一个final变量初始化为编译时静态值。考虑变成静态常量。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #00ff00;&quot;&gt;&lt;strong&gt;最佳实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;增加static关键字&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;错误码：NM_METHOD_NAMING_CONVENTION&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;解读：方法应该是动词，与第一个字母小写混合的情况下，与每个单词的首字母大写的内部。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jersey基础知识分享</title>
   <link href="http://dreambt.github.com/J2EE/2012/03/06/jersey-basic"/>
   <updated>2012-03-06T22:13:31+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2012/03/06/jersey-basic</id>
   <content type="html">&lt;h1&gt;RESTful Web 服务简介&lt;/h1&gt;


&lt;p&gt;REST 在 2000 年由 Roy Fielding 在博士论文中提出，他是 HTTP 规范 1.0 和 1.1 版的首席作者之一。
REST 中最重要的概念是资源（resources），使用全球 ID（通常使用 URI）标识。客户端应用程序使用 HTTP 方法（GET/ POST/ PUT/ DELETE）操作资源或资源集。RESTful Web 服务是使用 HTTP 和 REST 原理实现的 Web 服务。通常，RESTful Web 服务应该定义以下方面：
Web 服务的基/根 URI，比如 http://host/&amp;lt;appcontext&amp;gt;/resources。
支持 MIME 类型的响应数据，包括 JSON/XML/ATOM 等等。
服务支持的操作集合（例如 POST、GET、PUT 或 DELETE）。&lt;/p&gt;

&lt;h2&gt;Jersey的四种行为&lt;/h2&gt;


&lt;p&gt;对应我们日常说的CRUD.
方法/资源 资源集合; URI：http://host/api/resources 成员资源; URI：http://host/api/resources/123 对应的操作
GET          列出资源集合的所有成员。                           检索标识为 123 的资源的表示形式。                     R（读取）
PUT          使用一个集合更新（替换）另一个集合。        更新标记为 123 的数字资源。                              U（更新）
POST        在集合中创建数字资源，其 ID 是自动分配的  在下面创建一个子资源。                                       C（创建）
DELETE     删除整个资源集合。                                     删除标记为 123 的数字资源。                              D（删除）&lt;/p&gt;

&lt;h2&gt;相关的架包结构&lt;/h2&gt;


&lt;p&gt;· 核心服务器：jersey-core.jar，jersey-server.jar，jsr311-api.jar，asm.jar&lt;/p&gt;

&lt;p&gt;· 核心客户端：（用于测试）jersey-client.jar
· JAXB 支持：（在高级样例中使用）jaxb-impl.jar，jaxb-api.jar，activation.jar，stax-api.jar，wstx-asl.jar
· JSON 支持：（在高级样例中使用）jersey-json.jar
· Spring支持：（在高级样例中使用）jersey-spirng.jar&lt;/p&gt;

&lt;h2&gt;元注解信息说明&lt;/h2&gt;


&lt;h3&gt;生存周期说明&lt;/h3&gt;


&lt;ol&gt;
&lt;li&gt;默认不使用注解，表示生存周期等于request，请求过后自动销毁，默认是线程安全的。&lt;/li&gt;
&lt;li&gt;application，使用@Singleton注解。生存周期等于整个应用程序的生存周期。&lt;/li&gt;
&lt;li&gt;session,使用@PerSession注解。生存周期等于一个session请求，session销毁，该rest资源实例也同时销毁。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;Bean注解说明&lt;/h3&gt;


&lt;p&gt;1.@Path，路径信息，表示映射出去的访问路径。
范例如下：@Path(&quot;/myResource&quot;)
2. @Produces，用于限制post和get方法返回的参数类型，支持json、string、xml、html
范例如下：@Produces({&quot;application/xml&quot;, &quot;application/json&quot;})
3. @Consumes，用于限制输入的参数的类型，支持json、string、xml、html
范例如下：@Consumes(&quot;text/plain&quot;)
4. @QueryParam，@DefaultValue，通过request传入的参数，@DefaultValue表示默认参数。
范例如下：@DefaultValue(&quot;2&quot;) @QueryParam(&quot;step&quot;) int step,
5. @PathParam ，@ MatrixParam，@ HeaderParam，@ CookieParam和@@ QueryParam FormParam听从以相同的规则。 @ MatrixParam提取URL路径段的信息。 @ HeaderParam提取的HTTP头信息。 @ CookieParam提取信息的Cookie饼干宣布相关的HTTP标头。@ FormParam略有特殊，因为它提取请求表示，该类型匹配前面的@Consumes所声明的类型。
范例如下：
@POST
@Consumes(&quot;application/x-www-form-urlencoded&quot;)
public void post(@FormParam(&quot;name&quot;) String name) {
6.pojo层面等相关注解，@XmlRootElement,支持JPA注解。
7.Spring相关注解，比如@Autowired(required=true) 、@Qualifier(&quot;persionDao&quot;)、@Component
@Scope(&quot;request&quot;)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>构建REST风格的Web Service</title>
   <link href="http://dreambt.github.com/J2EE/2012/03/06/rest-web-service"/>
   <updated>2012-03-06T18:17:01+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2012/03/06/rest-web-service</id>
   <content type="html">&lt;h1&gt;1．什么是REST?&lt;/h1&gt;


&lt;div&gt;REST 是由 Roy Fielding 在他的论文&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;《Architectural Styles and the Design of Network-based Software Architectures》&lt;/a&gt;中提出的一个术语。&lt;/div&gt;


&lt;div&gt;REST 是英文 Representational State Transfer 的缩写，有中文翻译为“具象状态传输”（参考：&lt;a href=&quot;http://dev2dev.bea.com.cn/bbsdoc/20060529259.html&quot;&gt;《SIP/IMS网络中的Representational State Transfer (REST)和数据分布》&lt;/a&gt;）&lt;/div&gt;


&lt;div&gt;可以将REST归纳如下：&lt;/div&gt;


&lt;h2&gt;1.1首先REST只是一种风格，不是一种标准&lt;/h2&gt;


&lt;blockquote&gt;
&lt;div&gt;You will not see the W3C putting out a REST specification. You will not see IBM or Microsoft or Sun selling a REST developer's toolkit. Why? Because REST is just an architectural style. You can't bottle up that style. You can only understand it, and design your Web services in that style.&lt;/div&gt;
&lt;div&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;em&gt;-&lt;/em&gt;&lt;strong&gt;&lt;em&gt; Roger L. Costello&lt;/em&gt;&lt;/strong&gt;&lt;em&gt; &lt;a href=&quot;http://www.xfront.com/REST-Web-Services.html&quot;&gt;《Building Web Services the REST Way》&lt;/a&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/div&gt;&lt;/blockquote&gt;


&lt;h2&gt;1.2  REST是以资源为中心的&lt;/h2&gt;


&lt;div&gt;在REST中，认为Web是由一系列的抽象资源（Abstract Resource）组成，这些抽象的资源具有不同的具体表现形式((Representational State)。譬如，定义一个资源为photo，含义是照片，它的表现形式可以是一个图片，也可以是一个.xml的文件，其中包含一些描述该照片的元素。或是一个html文件。并且这些具体的表现可以分布在不同的物理位置上。&lt;/div&gt;


&lt;h2&gt;1.3  REST的目的是决定如何使一个定义良好的 Web程序向前推进&lt;/h2&gt;


&lt;div&gt;一个程序可以通过选择一个Web页面上的超链(这些链接代表资源)，使得另一个Web页面 (Representational State of an abstract resource) 返回(transfer)到用户，使程序进一步运行。&lt;/div&gt;


&lt;h2&gt;1.4  REST充分利用或者说极端依赖HTTP协议&lt;/h2&gt;


&lt;div&gt;&lt;strong&gt;它通过逻辑URI定位资源&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;在 REST 的定义中，一个 Web 应用总是使用固定的 URI 向外部世界呈现（或者说暴露）一个资源。&lt;/div&gt;


&lt;div&gt;这里必须注意&lt;/div&gt;


&lt;div&gt;1.一个URI对应一个资源&lt;/div&gt;


&lt;div&gt;2.这里的URI是一个逻辑URI&lt;/div&gt;


&lt;div&gt;一个逻辑 URI： http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;一个物理 URI： http://www.example.com/photo/logo.html&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;通过分辨 HTTP Request Header 信息来分辨客户端是想要取得资源的哪一种表现形式的数据&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;我们来看一个实际例子：&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo 指向 example.com 网站（可以视为一个 Web 应用）中类型为photo，名字为 logo 的资源。我们用浏览器访问这个 URI，看到的将可能是一个 html 文档，其中用 &amp;lt;img src=”……” /&amp;gt; 来显示实际的照片。&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo 这个地址很可能会在服务器内部处理为 http://www.example.com/photo.jsp?name=logo 这样的地址。photo.jsp 是服务器端的一个动态脚本文件，根据 name 参数生成 html 文档返回给浏览器。&lt;/div&gt;


&lt;div&gt;现在假设我们要获取这张照片的 XML 文档。XML 文档中包含照片的文件名、文件大小、拍摄日期等等信息。也就是说我们要获取“同一个资源的不同表现形式的数据”。对于这个要求，我们可以很容易的用另一个 URL地址达到：http://www.example.com/xml/logo。&lt;/div&gt;


&lt;div&gt;但是，这就违背了“URI 唯一标识一个资源”的定义。如果我们要获取同一个资源的多种表现形式，那么就要使用更多的 URL，从而给一个资源指定了多个不同的 URI。&lt;/div&gt;


&lt;div&gt;而在REST 中，不管是获取照片的 xhtml 文档还是 XML 文档，或者照片文件本身，都是用同一个 URI，就是http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;那这是怎么办到的呢？是通过分辨 HTTP Request Header 信息来分辨客户端是想要取得资源的哪一种表现形式的数据。&lt;/div&gt;


&lt;div&gt;当我们用浏览器访问一个网址时，浏览器会构造一个 HTTP 请求。这个请求有一个头信息，其中包括了本次请求接受何种类型的数据。通常浏览器发送的 HTTP 请求头中，Accept 的值都是 */*，也就说接受服务器返回的任何类型的数据。&lt;/div&gt;


&lt;div&gt;只要我们指定一个特定的 Accept 参数，那么服务器就可以通过判断该参数来决定返回什么类型的数据。所以在一个采用 REST 架构的应用中，要获取同一个资源的不同表现形式的数据，只需要使用不同的 HTTP 请求头信息就行了。&lt;/div&gt;


&lt;div&gt;如果考虑为 Web 应用增加 Web Services，这种技术的价值就体现出来了。比如写了一个程序，现在只需要构造一个包含 Accept: text/xml 的 HTTP 请求头，然后将请求发送到 http://www.example.com/photo/logo 就可以了。返回的结果就是一个 XML 文档，而不是别的资源形式的数据。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;在 REST 架构中，用不同的 HTTP 请求方法来处理对资源的 CRUD（创建、读取、更新和删除）操作&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;我们在 Web 应用中处理来自客户端的请求时，通常只考虑 GET 和 POST 这两种 HTTP 请求方法。实际上，HTTP 还有HEAD、PUT、DELETE 等请求方法。而在 REST 架构中，用不同的 HTTP 请求方法来处理对资源的 CRUD（创建、读取、更新和删除）操作：&lt;/div&gt;


&lt;div&gt;Ø POST: 创建&lt;/div&gt;


&lt;div&gt;Ø GET: 读取&lt;/div&gt;


&lt;div&gt;Ø PUT: 更新&lt;/div&gt;


&lt;div&gt;Ø DELETE: 删除&lt;/div&gt;


&lt;div&gt;经过这样的一番扩展，我们对一个资源的 CRUD 操作就可以通过同一个 URI 完成了：&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo（读取）
仍然保持为 [GET] http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo/create（创建）
改为 [POST] http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo/update（更新）
改为 [PUT] http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;http://www.example.com/photo/logo/delete（删除）
改为 [DELETE] http://www.example.com/photo/logo&lt;/div&gt;


&lt;div&gt;从而进一步规范了资源标识的使用。&lt;/div&gt;


&lt;div&gt;通过 REST 架构，Web 应用程序可以用一致的接口（URI）暴露资源给外部世界，并对资源提供语义一致的操作服务。这对于以资源为中心的 Web 应用来说非常重要。&lt;/div&gt;


&lt;h1&gt;2．RESTful Web Services 特点&lt;/h1&gt;


&lt;div&gt;通过将HTTP Accept类型设置为text/xml，我们便可以将资源返回的“具象状态”表示为可跨平台识别的数据。这是应用于Web Services的基础。&lt;/div&gt;


&lt;div&gt;RESTful Web Service具有以下特点：&lt;/div&gt;


&lt;h2&gt;2.1无状态的&lt;/h2&gt;


&lt;div&gt;每一个来自客户端的request必须包含所有必要的信息，即不能从服务器端获得任何保存的上下文信息。&lt;/div&gt;


&lt;div&gt;REST 的 “客户机－无状态－服务器” 约束禁止在服务器上保存会话状态。符合这一约束进行设计&lt;/div&gt;


&lt;div&gt;1.可以提高系统的可靠性和可伸缩性。它不需要昂贵的维护和支持费用，因为状态并不在服务器上维护&lt;/div&gt;


&lt;div&gt;2.可以进行资源缓存。Web的高速缓存既可以驻留在客户主机中，也可以驻留在中间网络高速缓存服务器主机中&lt;/div&gt;


&lt;h2&gt;2.2  HTTP头中可见的统一接口和资源地址&lt;/h2&gt;


&lt;div&gt;通过对于HTTP Head 的解析，我们便可以了解到当前所请求的资源和请求的方式。相对于SOAP RPC风格来说，我们必须解析HTTP体。&lt;/div&gt;


&lt;div&gt;这样做对于一些代理服务器的设置，将带来很高的处理效率。&lt;/div&gt;


&lt;div&gt;REST 系统中所有的动作和要访问的资源都可以从H TTP和URI 中得到，这使得代理服务器、缓存服务器和网关很好地协调工作。而RPC模 型的SOAP 要访问的资源仅从 URI无法得知，要调用的方法也无法从 HTTP中得知，它们都隐藏在 SOAP 消息中。&lt;/div&gt;


&lt;div&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;同样的，在REST系统中的代理服务器还可以通过 HTTP 的动作 (GET 、 POST)来进行控制。&lt;/span&gt;&lt;/div&gt;


&lt;div&gt;&lt;img class=&quot;aligncenter size-full wp-image-1116&quot; title=&quot;200710231193107976394&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/03/200710231193107976394.jpg&quot; alt=&quot;&quot; /&gt;&lt;/div&gt;


&lt;h2&gt;2.3  返回一般的XML格式内容&lt;/h2&gt;


&lt;div&gt;一般情况下，一个RESTful Web Service将比一个SOAP RPC Web Service占用更少的传输带宽。&lt;/div&gt;


&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;568&quot;&gt;
&lt;div&gt;POST/Order HTTP/1.1&lt;/div&gt;
&lt;div&gt;Host:www.northwindtraders.com&lt;/div&gt;
&lt;div&gt;Content-Type:text/xml&lt;/div&gt;
&lt;div&gt;Content-Length:nnnn&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;UpdatePO&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;orderID&amp;gt;098&amp;lt;/orderID&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;customerNumber&amp;gt;999&amp;lt;/customerNumber&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;item&amp;gt;89&amp;lt;/item&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;quantity&amp;gt;3000&amp;lt;/quantity&amp;gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;/UpdatePO&amp;gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&quot;top&quot; width=&quot;568&quot;&gt;
&lt;div&gt;POST/Order HTTP/1.1&lt;/div&gt;
&lt;div&gt;Host:www.northwindtraders.com&lt;/div&gt;
&lt;div&gt;Content-Type:text/xml&lt;/div&gt;
&lt;div&gt;Content-Length:nnnn&lt;/div&gt;
&lt;div&gt;SOAPAction:”urn:northwindtraders.com:PO#UpdatePO”&lt;/div&gt;
&lt;div&gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;SOAP-ENV:Envelope&lt;/div&gt;
&lt;div&gt;xmlns:xsi=”http://www.3w.org/1999/XMLSchema/instance”&lt;/div&gt;
&lt;div&gt;xmlns:SOAP-ENV=”http://schemas.xmlsoap.org/soap/envelope”&lt;/div&gt;
&lt;div&gt;xsi:schemaLocation=”http://www.northwindtraders.com/schema/NPOSchema.xsd”&amp;gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;SOAP-ENV:Body xsi:type=”NorthwindBody”&amp;gt;&lt;/div&gt;
&lt;div&gt;    &amp;lt;UpdatePO&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;orderID&amp;gt;098&amp;lt;/orderID&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;customerNumber&amp;gt;999&amp;lt;/customerNumber&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;item&amp;gt;89&amp;lt;/item&amp;gt;&lt;/div&gt;
&lt;div&gt;      &amp;lt;quantity&amp;gt;3000&amp;lt;/quantity&amp;gt;&lt;/div&gt;
&lt;div&gt;    &amp;lt;/UpdatePO&amp;gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;/SOAP-ENV:Body&amp;gt;&lt;/div&gt;
&lt;div&gt;&amp;lt;/SOAP-ENV:Envelope&amp;gt;&lt;/div&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h2&gt;2.4  安全机制&lt;/h2&gt;


&lt;div&gt;REST使用了简单有效的安全模型。REST中很容易隐藏某个资源，只需不发布它的URI；而在资源上也很容易使用一些安全策略，比如可以在每个 URI 针对 4个通用接口设置权限；再者，以资源为中心的 Web服务是防火墙友好的，因为 GET的意思就是GET， PUT 的意思就是PUT，管理员可以通过堵塞非GET请求把资源设置为只读的，而现在的基于RPC 模型的 SOAP一律工作在 HTTP 的 POST上。&lt;/div&gt;


&lt;div&gt;使用 SOAP RPC模型，要访问的对象名称藏在方法的参数中，因此需要创建新的安全模型。&lt;/div&gt;


&lt;h2&gt;2.5  无法用于事务型的服务&lt;/h2&gt;


&lt;div&gt;对于事务型的服务，一个简单的例子就是银行事务，在那里用户可以把钱从一个账户转移到另一个账户上。用户不想直接操作资源（钱、银行账户等等），他们只想告诉银行他们想要达到的目的，并且让银行根据他们的利益对资源进行处理。&lt;/div&gt;


&lt;div&gt;所以从这一条，我们应该明白，选择基于REST或SOAP RPC风格的Web 服务，我们应该首先考虑这个服务是针对资源的还是针对活动的。&lt;/div&gt;


&lt;div&gt;- James Snell，面向资源与面向活动的 Web 服务，&lt;a href=&quot;http://www.ibm.com/developerworks/webservices/library/ws-restvsoap/?S_TACT=105AGX52&amp;amp;S_CMP=cn-a-ws&quot; target=&quot;_blank&quot;&gt;英文原文&lt;/a&gt;。&lt;/div&gt;


&lt;h1&gt;3．JAX-WS&lt;/h1&gt;


&lt;div&gt;JAX-WS是Java Architecture for XML Web Services的缩写,简单说就是一种用Java和XML开发Web Services应用程序的框架, 目前版本是2.0, 它是JAX-RPC 1.1的后续版本。&lt;/div&gt;


&lt;div&gt;&lt;a href=&quot;https://jax-ws.dev.java.net/&quot;&gt;JAX-WS2.0&lt;/a&gt;用JAXB2来处理Java Object与XML之间的映射。&lt;/div&gt;


&lt;div&gt;JAX-WS通过javax.xml.ws.Provider接口来构建REST风格的终端。&lt;/div&gt;


&lt;h1&gt;4．WADL&lt;/h1&gt;


&lt;div&gt;&lt;a href=&quot;http://research.sun.com/spotlight/2006/2006-04-24-TR153.html&quot;&gt;Web Application Description Language (WADL)&lt;/a&gt;是由SUN公司提出的，旨在提供一种Web 应用的描述语言。WADL主要描述一个Web 应用的&lt;/div&gt;


&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;资源列表-站点所有的资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;资源之间的关系-说明资源之间的链接关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;所有应用于每个资源的特定方法-应用于每个资源的HTTP方法，指定的输入和输出以及它们支持的数据格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;资源表现的形式-支持的MIME类型和所用到的XML schemas&lt;/li&gt;
&lt;/ul&gt;
&lt;div&gt;&lt;span style=&quot;line-height: 19px;&quot;&gt;&lt;img class=&quot;size-full wp-image-1115 aligncenter&quot; title=&quot;200710231193108006978&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2012/03/200710231193108006978.jpg&quot; alt=&quot;&quot; width=&quot;575&quot; height=&quot;389&quot; /&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;下面是一个WADL示例，它描述了Yahoo新闻搜索的应用。&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 2 开始一个应用描述，定义所使用的namespaces。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 3–6 定义XML 语法，这个示例中是两个W3C XML Schema。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 7–11描述了Yahoo新闻搜索Web 资源以及它所支持的HTTP方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 12–26 描述了‘search’ GET方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 13–21 描述输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;div align=&quot;left&quot;&gt;
&lt;ul&gt;
    &lt;li&gt;Lines 22–25 描述所有可能的输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;h1&gt;5．关于WADL的项目介绍&lt;/h1&gt;


&lt;div&gt;&lt;a href=&quot;https://glassfish.dev.java.net/&quot; target=&quot;_parent&quot;&gt; &lt;/a&gt;&lt;a href=&quot;https://glassfish.dev.java.net/&quot; target=&quot;_parent&quot;&gt;GlassFish&lt;/a&gt; » &lt;a href=&quot;https://wadl.dev.java.net/&quot; target=&quot;_parent&quot;&gt;Web Application Description Language&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;wadl2java&lt;/strong&gt; - A tool that generates client side stubs from WADL files. May be used from the command line or as an Apache Ant plug-in, see the &lt;a href=&quot;https://wadl.dev.java.net/wadl2java.html&quot; target=&quot;_parent&quot;&gt;wadl2java documentation&lt;/a&gt; for full details.&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;wadl2java_yahoo&lt;/strong&gt; - A sample project that uses the wadl2java tool to create stubs for the &lt;a href=&quot;http://developer.yahoo.com/search/news/V1/newsSearch.html&quot; target=&quot;_parent&quot;&gt;Yahoo News Search Service&lt;/a&gt;. Includes a simple main method that uses the generated stubs to query for the latest Java news.&lt;/div&gt;


&lt;h1&gt;6．建议阅读的资料&lt;/h1&gt;


&lt;div&gt;[1] Roy Thomas Fielding，&lt;a href=&quot;http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm&quot;&gt;Architectural Styles and the Design of Network-based Software Architectures&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[2] &lt;a href=&quot;http://rest.blueoxen.net/cgi-bin/wiki.pl&quot;&gt;RESTwiki&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[3] &lt;a href=&quot;http://c2.com/cgi/fullSearch&quot;&gt;Rest Architectural Style&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[4] &lt;a href=&quot;http://groups.yahoo.com/group/rest-discuss/&quot;&gt;REST mailing list&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[5] &lt;a href=&quot;http://www.xfront.com/REST-Web-Services.html&quot;&gt;Building Web Services the REST Way&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[6] &lt;a href=&quot;http://www-128.ibm.com/developerworks/cn/webservices/ws-restvsoap/&quot;&gt;面向资源与面向活动的 Web 服务&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[7] &lt;a href=&quot;http://www.prescod.net/rest/security.html&quot;&gt;Some thoughts about SOAP versus REST on Security&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[8] WADL语言作者&lt;a href=&quot;http://weblogs.java.net/blog/mhadley/&quot;&gt;Marc Hadley's Blog&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;[9] &lt;a href=&quot;http://java.sun.com/webservices/technologies/index.jsp&quot;&gt;Java Web Service Technologies @Sun&lt;/a&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;a href=&quot;http://zhangjunhd.blog.51cto.com/113473/47283&quot;&gt;来源&lt;/a&gt;&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>VirtualBox中使用物理硬盘上的Win7</title>
   <link href="http://dreambt.github.com/Windows/2012/02/23/virtualbox-win7"/>
   <updated>2012-02-23T17:39:05+08:00</updated>
   <id>http://dreambt.github.com/Windows/2012/02/23/virtualbox-win7</id>
   <content type="html">&lt;h2&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;操作有风险，动手须谨慎！&lt;/span&gt;&lt;/h2&gt;


&lt;h2&gt;&lt;strong&gt;前提&lt;/strong&gt;&lt;/h2&gt;


&lt;p&gt;1.在硬盘上安装Ubuntu、Win7(或者XP)&lt;/p&gt;

&lt;p&gt;2.在Ubuntu安装&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot;&gt;VirtualBox&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.在Ubuntu安装MBR&lt;/p&gt;

&lt;pre&gt;sudo apt-get install mbr&lt;/pre&gt;


&lt;h2&gt;&lt;strong&gt;方法&lt;/strong&gt;&lt;/h2&gt;


&lt;p&gt;1.提升硬盘访问权限&lt;/p&gt;

&lt;pre&gt;chmod o+rw /dev/sda //全盘获取读写权限，不安全
chmod o+rw /dev/sda3 //第3个分区获得读写权限&lt;/pre&gt;


&lt;p&gt;1.配置引导区&lt;/p&gt;

&lt;pre&gt;install-mbr -e12 --force vm.mbr&lt;/pre&gt;


&lt;p&gt;2.将物理硬盘生成VirtualBox配置文件&lt;/p&gt;

&lt;pre&gt;VBoxManage internalcommands createrawvmdk -filename ~/Win7.vmdk -rawdisk /dev/sda -partitions 3 -mbr vm.mbr -relative
//将第3个分区生成配置文件，并导入MBR文件&lt;/pre&gt;


&lt;p&gt;3.修改vmdk等文件的所有者和访问权限&lt;/p&gt;

&lt;pre&gt;chown siqi:siqi /home/siqi/VM/Win7-64/*
chmod o+rw /home/siqi/VM/Win7-64/*
&lt;/pre&gt;


&lt;p&gt;4.在VirtualBox界面添加生成的Win7.vmdk文件&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Tomcat处理HTTP请求源码分析（下）</title>
   <link href="http://dreambt.github.com/J2EE/2011/12/15/tomcat-http2"/>
   <updated>2011-12-15T11:38:34+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2011/12/15/tomcat-http2</id>
   <content type="html">&lt;p&gt;很多开源应用服务器都是集成tomcat作为web container的，而且对于tomcat的servlet container这部分代码很少改动。这样，这些应用服务器的性能基本上就取决于Tomcat处理HTTP请求的connector模块的性能。本文首先从应用层次分析了tomcat所有的connector种类及用法，接着从架构上分析了connector模块在整个tomcat中所处的位置，最后对connector做了详细的源代码分析。并且我们以Http11NioProtocol为例详细说明了tomcat是如何通过实现ProtocolHandler接口而构建connector的。&lt;/p&gt;

&lt;h2&gt;4 如何实现Connector&lt;/h2&gt;


&lt;p&gt;由上面的介绍我们可以知道，实现Connector就是实现ProtocolHander接口的过程。&lt;/p&gt;

&lt;p&gt;AjpAprProtocol、AjpProtocol、Http11AprProtocol、Http11Protocol、JkCoyoteHandler、MemoryProtocolHandler这些实现类的实现流程与Http11NioProtocol相同，下面我们以Http11NioProtocol为类重点说明tomcat中如何实现ProtocolHander接口的。&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;Http11NioProtocol实现了ProtocolHander接口，它将所有的操作委托给NioEndpoint类去做，如下图：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs3XQv/medium.jpg&quot; alt=&quot;image1&quot; width=&quot;404&quot; height=&quot;263&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;NioEndpoint类中的init方法中首先以普通阻塞方式启动了SocketServer：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs4dsZ/medium.jpg&quot; alt=&quot;image2&quot; width=&quot;500&quot; height=&quot;69&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;NioEndpoint类的start方法是关键，如下：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs4kjm/medium.jpg&quot; alt=&quot;image3&quot; width=&quot;500&quot; height=&quot;420&quot; /&gt;&lt;/p&gt;


&lt;p&gt;可以看出，在start方法中启动了两个线程和一个线程池：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Acceptor线程，该线程以普通阻塞方式接收客户端请求（socket.accep()），将客户Socket交由线程池是处理，线程池要将该Socket配置成非阻塞模式（socket.configureBlocking(false)）,并且向Selector注册READ事件。该线程数目可配置，默认为1个。&lt;/li&gt;
    &lt;li&gt;Poller线程，由于Acceptor委托线程为客户端Socket注册了READ事件，当READ准备好时，就会进入Poller线程的循环，Poller线程也是委托线程池去做，线程池将NioChannel加入到ConcurrentLinkedQueue&amp;lt;NioChannel&amp;gt;队列中。该线程数目可配置，默认为1个。&lt;/li&gt;
    &lt;li&gt;线程池，就是上面说的做Acceptor与Poller线程委托要做的事情。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;4.1 Init接口实现方法中阻塞方式启动ServerSocketChannel&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;在Init接口实现方法中阻塞方式启动ServerSocketChannel。
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs4LVD/medium.jpg&quot; alt=&quot;image4&quot; width=&quot;500&quot; height=&quot;66&quot; /&gt;&lt;/p&gt;




&lt;h3&gt;4.2 Start接口实现方法中启动所有线程&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;Start方法中启动了线程池，acceptor线程与Poller线程。其中acceptor与poller线程一般数目为1，当然，数目也可配置。
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs4Io9/medium.jpg&quot; alt=&quot;image5&quot; width=&quot;500&quot; height=&quot;368&quot; /&gt;&lt;/p&gt;


&lt;p&gt;可以看出，线程池有两种实现方式：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;普通queue + wait + notify方式，默认使用的方式，据说实际测试这种比下种效率高&lt;/li&gt;
    &lt;li&gt;JDK1.5自带的线程池方式&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;4.3 Acceptor线程接收客户请求、注册READ事件&lt;/h3&gt;


&lt;p&gt;在Acceptor线程中接收了客户请求，同时委托线程池注册READ事件。&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;在Acceptior线程中接收了客户请求（serverSock.accept()）&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs4SNn/medium.jpg&quot; alt=&quot;image6&quot; width=&quot;500&quot; height=&quot;64&quot; /&gt;&lt;/p&gt;




&lt;ol&gt;
    &lt;li&gt;委托线程池处理&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs54Yu/medium.jpg&quot; alt=&quot;image7&quot; width=&quot;500&quot; height=&quot;218&quot; /&gt;&lt;/p&gt;




&lt;ol&gt;
    &lt;li&gt;在线程池的Worker线程的run方法中有这么几句：&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs5nvc/medium.jpg&quot; alt=&quot;image8&quot; width=&quot;500&quot; height=&quot;309&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;在setSocketOptions方法中，首先将socket配置成非阻塞模式：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs5MJX/medium.jpg&quot; alt=&quot;image9&quot; width=&quot;500&quot; height=&quot;100&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;在setSocketOptions方法中，最后调用getPoller0().register(channel);一句为SocketChannel注册READ事件，register方法代码如下(注意：这是Poller线程的方法)：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs5L3z/medium.jpg&quot; alt=&quot;image10&quot; width=&quot;500&quot; height=&quot;202&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;其中attachment的结构如下，它可以看做是一个共享的数据结构：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs68j1/medium.jpg&quot; alt=&quot;image11&quot; width=&quot;500&quot; height=&quot;478&quot; /&gt;&lt;/p&gt;




&lt;h3&gt;4.4 Poller线程读请求、生成响应数据、注册WRITE事件&lt;/h3&gt;


&lt;ol&gt;
    &lt;li&gt;在上面说的setSocketOptions方法中调用Poller线程的register方法注册读事件之后，当READ准备就绪之后，就开始读了。下面代码位于Poller线程的run方法之中：&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs6sz3/medium.jpg&quot; alt=&quot;image12&quot; width=&quot;500&quot; height=&quot;461&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;可以看到，可读之后调用processSocket方法，该方法将读处理操作委拖给线程池处理(注意此时加入到线程池的是NioChannel，不是SocketChannel)：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs6RDS/medium.jpg&quot; alt=&quot;image13&quot; width=&quot;500&quot; height=&quot;217&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;线程池的Worker线程中的run方法中的部分代码如下（请注意handler.process(socket)这一句）：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs6TbB/medium.jpg&quot; alt=&quot;image14&quot; width=&quot;500&quot; height=&quot;403&quot; /&gt;&lt;/p&gt;


&lt;p&gt;注意：&lt;/p&gt;

&lt;ol&gt;
&lt;ul&gt;
    &lt;li&gt;调用了hanler.process(socket)来生成响应数据）&lt;/li&gt;
    &lt;li&gt;数据生成完之后，注册WRITE事件的，代码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs779P/medium.jpg&quot; alt=&quot;image15&quot; width=&quot;500&quot; height=&quot;262&quot; /&gt;&lt;/p&gt;




&lt;h3&gt;4.5 Handle接口实现类通过Adpater调用Servlet容器生成响应数据&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;NioEndpoint类中的Handler接口定义如下：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs7lDm/medium.jpg&quot; alt=&quot;image16&quot; width=&quot;500&quot; height=&quot;105&quot; /&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;其中process方法通过Adapter来调用Servlet Container生成返回结果。Adapter接口定义如下：
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBKs7xxM/medium.jpg&quot; alt=&quot;image17&quot; width=&quot;500&quot; height=&quot;319&quot; /&gt;&lt;/p&gt;




&lt;h3&gt;4.6 小结&lt;/h3&gt;


&lt;p&gt;实现一个tomcat连接器Connector就是实现ProtocolHander接口的过程。Connector用来接收Socket Client端的请求，通过内置的线程池去调用Servlet Container生成响应结果，并将响应结果同步或异步的返回给Socket Client。在第三方应用集成tomcat作为Web容器时，一般不会动Servlet Container端的代码，那么connector的性能将是整个Web容器性能的关键。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;转载自：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/zh-tomcat-http-request-1&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/zh-tomcat-http-request-1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/zh-tomcat-http-request-2&quot; target=&quot;_blank&quot;&gt;http://www.infoq.com/cn/articles/zh-tomcat-http-request-2&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Tomcat处理HTTP请求源码分析（上）</title>
   <link href="http://dreambt.github.com/J2EE/2011/12/08/tomcat-http1"/>
   <updated>2011-12-08T10:41:12+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2011/12/08/tomcat-http1</id>
   <content type="html">&lt;p&gt;很多开源应用服务器都是集成tomcat作为web container的，而且对于tomcat的servlet container这部分代码很少改动。这样，这些应用服务器的性能基本上就取决于Tomcat处理HTTP请求的connector模块的性能。本文首先从应用层次分析了tomcat所有的connector种类及用法，接着从架构上分析了connector模块在整个tomcat中所处的位置，最后对connector做了详细的源代码分析。并且我们以Http11NioProtocol为例详细说明了tomcat是如何通过实现ProtocolHandler接口而构建connector的。&lt;/p&gt;

&lt;p&gt;通过本文的学习，应该可以轻松做到将tomcat做为web container集成到第三方系统，并且自定义任何你想要的高性能的HTTP连接器。&lt;/p&gt;

&lt;h2&gt;1 Connector介绍&lt;/h2&gt;


&lt;h3&gt;1.1 Connector的种类&lt;/h3&gt;


&lt;p&gt;Tomcat源码中与connector相关的类位于org.apache.coyote包中，Connector分为以下几类：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Http Connector, 基于HTTP协议，负责建立HTTP连接。它又分为BIO Http Connector与NIO Http Connector两种，后者提供非阻塞IO与长连接Comet支持。&lt;/li&gt;
    &lt;li&gt;AJP Connector, 基于AJP协议，AJP是专门设计用来为tomcat与http服务器之间通信专门定制的协议，能提供较高的通信速度和效率。如与Apache服务器集成时，采用这个协议。&lt;/li&gt;
    &lt;li&gt;APR HTTP Connector, 用C实现，通过JNI调用的。主要提升对静态资源（如HTML、图片、CSS、JS等）的访问性能。现在这个库已独立出来可用在任何项目中。Tomcat在配置APR之后性能非常强劲。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;1.2 Connector的配置&lt;/h3&gt;


&lt;p&gt;对Connector的配置位于conf/server.xml文件中。&lt;/p&gt;

&lt;h4&gt;1.2.1 BIO HTTP/1.1 Connector配置&lt;/h4&gt;


&lt;p&gt;一个典型的配置如下：&lt;/p&gt;

&lt;pre&gt;&lt;/pre&gt;


&lt;p&gt;其它一些重要属性如下：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;acceptCount : 接受连接request的最大连接数目，默认值是10&lt;/li&gt;
    &lt;li&gt;address : 绑定IP地址，如果不绑定，默认将绑定任何IP地址&lt;/li&gt;
    &lt;li&gt;allowTrace : 如果是true,将允许TRACE HTTP方法&lt;/li&gt;
    &lt;li&gt;compressibleMimeTypes : 各个mimeType, 以逗号分隔，如text/html,text/xml&lt;/li&gt;
    &lt;li&gt;compression : 如果带宽有限的话，可以用GZIP压缩&lt;/li&gt;
    &lt;li&gt;connectionTimeout : 超时时间，默认为60000ms (60s)&lt;/li&gt;
    &lt;li&gt;maxKeepAliveRequest : 默认值是100&lt;/li&gt;
    &lt;li&gt;maxThreads : 处理请求的Connector的线程数目，默认值为200&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;如果是SSL配置，如下：&lt;/p&gt;

&lt;pre&gt;&lt;/pre&gt;


&lt;p&gt;其中，keystoreFile为证书位置，keystorePass为证书密码&lt;/p&gt;

&lt;h4&gt;1.2.2 NIO HTTP/1.1 Connector配置&lt;/h4&gt;


&lt;pre&gt;&lt;/pre&gt;


&lt;h4&gt;1.2.3 Native APR Connector配置&lt;/h4&gt;


&lt;ol&gt;
    &lt;li&gt;ARP是用C/C++写的，对静态资源（HTML，图片等）进行了优化。所以要下载本地库tcnative-1.dll与openssl.exe，将其放在%tomcat%\bin目录下。下载地址是：&lt;a href=&quot;http://tomcat.heanet.ie/native/1.1.10/binaries/win32/&quot;&gt;http://tomcat.heanet.ie/native/1.1.10/binaries/win32/&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;在server.xml中要配置一个Listener,如下图。这个配置tomcat是默认配好的。
&lt;pre&gt;&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;&lt;/pre&gt;
&lt;/li&gt;
    &lt;li&gt;配置使用APR connector
&lt;pre&gt;&lt;/pre&gt;
maxThreads=”150” connectionTimeout=”20000” redirectPort=”8443”&amp;gt;&lt;/li&gt;
    &lt;li&gt;如果配置成功，启动tomcat,会看到如下信息：
&lt;pre&gt;org.apache.coyote.http11.Http11AprProtocol init&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;2 Connector在Tomcat中所处的位置&lt;/h2&gt;


&lt;h3&gt;2.1 Tomcat架构&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2MHNz/medium.jpg&quot; alt=&quot;1&quot; width=&quot;415&quot; height=&quot;284&quot; /&gt;
&lt;strong&gt;图2-1 Tomcat架构&lt;/strong&gt;&lt;/p&gt;




&lt;ul&gt;
    &lt;li&gt;Server(服务器)是Tomcat构成的顶级构成元素，所有一切均包含在Server中，Server的实现类StandardServer可以包含一个到多个Services;&lt;/li&gt;
    &lt;li&gt;次顶级元素Service的实现类为StandardService调用了容器(Container)接口，其实是调用了Servlet Engine(引擎)，而且StandardService类中也指明了该Service归属的Server；&lt;/li&gt;
    &lt;li&gt;接下来次级的构成元素就是容器(Container)，主机(Host)、上下文(Context)和引擎(Engine)均继承自Container接口，所以它们都是容器。但是，它们是有父子关系的，在主机(Host)、上下文(Context)和引擎(Engine)这三类容器中，引擎是顶级容器，直接包含是主机容器，而主机容器又包含上下文容器，所以引擎、主机和上下文从大小上来说又构成父子关系，虽然它们都继承自Container接口。&lt;/li&gt;
    &lt;li&gt;连接器(Connector)将Service和Container连接起来，首先它需要注册到一个Service，它的作用就是把来自客户端的请求转发到Container(容器)，这就是它为什么称作连接器的原因。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;故我们从功能的角度将Tomcat源代码分成5个子模块，它们分别是：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;Jsper子模块：这个子模块负责jsp页面的解析、jsp属性的验证，同时也负责将jsp页面动态转换为java代码并编译成class文件。在Tomcat源代码中，凡是属于org.apache.jasper包及其子包中的源代码都属于这个子模块；&lt;/li&gt;
    &lt;li&gt;Servlet和Jsp规范的实现模块：这个子模块的源代码属于javax.servlet包及其子包，如我们非常熟悉的javax.servlet.Servlet接口、javax.servet.http.HttpServlet类及javax.servlet.jsp.HttpJspPage就位于这个子模块中；&lt;/li&gt;
    &lt;li&gt;Catalina子模块：这个子模块包含了所有以org.apache.catalina开头的java源代码。该子模块的任务是规范了Tomcat的总体架构，定义了Server、Service、Host、Connector、Context、Session及Cluster等关键组件及这些组件的实现，这个子模块大量运用了Composite设计模式。同时也规范了Catalina的启动及停止等事件的执行流程。从代码阅读的角度看，这个子模块应该是我们阅读和学习的重点。&lt;/li&gt;
    &lt;li&gt;Connectors子模块：如果说上面三个子模块实现了Tomcat应用服务器的话，那么这个子模块就是Web服务器的实现。所谓连接器(Connector)就是一个连接客户和应用服务器的桥梁，它接收用户的请求，并把用户请求包装成标准的Http请求(包含协议名称，请求头Head，请求方法是Get还是Post等等)。同时，这个子模块还按照标准的Http协议，负责给客户端发送响应页面，比如在请求页面未发现时，connector就会给客户端浏览器发送标准的Http 404错误响应页面。&lt;/li&gt;
    &lt;li&gt;Resource子模块：这个子模块包含一些资源文件，如Server.xml及Web.xml配置文件。严格说来，这个子模块不包含java源代码，但是它还是Tomcat编译运行所必需的。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;2.2 Tomcat运行流程&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2MMBF/medium.jpg&quot; alt=&quot;2&quot; width=&quot;500&quot; height=&quot;202&quot; /&gt;
&lt;strong&gt;图2-2 tomcat运行流程&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;假设来自客户的请求为：&lt;a href=&quot;http://localhost:8080/test/index.jsp&quot;&gt;http://localhost:8080/test/index.jsp&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得&lt;/li&gt;
    &lt;li&gt;Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应&lt;/li&gt;
    &lt;li&gt;Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host&lt;/li&gt;
    &lt;li&gt;Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）&lt;/li&gt;
    &lt;li&gt;localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context&lt;/li&gt;
    &lt;li&gt;Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为&quot;&quot;的Context去处理）&lt;/li&gt;
    &lt;li&gt;path=&quot;/test&quot;的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet&lt;/li&gt;
    &lt;li&gt;Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类&lt;/li&gt;
    &lt;li&gt;构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法&lt;/li&gt;
    &lt;li&gt;Context把执行完了之后的HttpServletResponse对象返回给Host&lt;/li&gt;
    &lt;li&gt;Host把HttpServletResponse对象返回给Engine&lt;/li&gt;
    &lt;li&gt;Engine把HttpServletResponse对象返回给Connector&lt;/li&gt;
    &lt;li&gt;Connector把HttpServletResponse对象返回给客户browser&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;3 Connector源码分析&lt;/h2&gt;


&lt;h3&gt;3.1 Tomcat的启动分析与集成设想&lt;/h3&gt;


&lt;p&gt;我们知道，启动tomcat有两种方式：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;双击bin/startup.bat&lt;/li&gt;
    &lt;li&gt;运行bin/catalina.bat run&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;它们对应于Bootstrap与Catalina两个类，我们现在只关心Catalina这个类，这个类使用Apache Digester解析conf/server.xml文件生成tomcat组件，然后再调用Embedded类的start方法启动tomcat。&lt;/p&gt;

&lt;p&gt;所以，集成Tomcat的方式就有以下两种了：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;沿用tomcat自身的server.xml&lt;/li&gt;
    &lt;li&gt;自己定义一个xml格式来配置tocmat的各参数，自己再写解析这段xml，然后使用tomcat提供的API根据这些xml来生成Tomcat组件，最后调用Embedded类的start方法启动tomcat&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;个人觉得第一种方式要优越，给开发者比较好的用户体验，如果使用这种，直接模仿Catalina类的方法即可实现集成。&lt;/p&gt;

&lt;p&gt;目前，JOnAS就使用了这种集成方式，JBoss、GlassFish使用的第二种自定义XML的方式。&lt;/p&gt;

&lt;h3&gt;3.2 Connector类图与顺序图&lt;/h3&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2MWlG/medium.jpg&quot; alt=&quot;3&quot; width=&quot;500&quot; height=&quot;278&quot; /&gt;
&lt;strong&gt;图3-1 Connector相关类图&lt;/strong&gt;&lt;/p&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2NbVm/medium.jpg&quot; alt=&quot;4&quot; width=&quot;500&quot; height=&quot;208&quot; /&gt;
&lt;strong&gt;图3-2 Connector工作流程顺序图&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;从上面二图中我们可以得到如下信息：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;Tomcat中有四种容器(Context、Engine、Host、Wrapper)，前三者常见，第四个不常见但它也是实现了Container接口的容器&lt;/li&gt;
    &lt;li&gt;如果要&lt;strong&gt;自定义一个Connector的话，只需要实现ProtocolHander接口&lt;/strong&gt;,该接口定义如下：&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2NwrU/medium.jpg&quot; alt=&quot;5&quot; width=&quot;485&quot; height=&quot;500&quot; /&gt;
&lt;strong&gt;图3-3 自定义connector时需实现的ProtocolHandler接口&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;Tomcat以HTTP（包括BIO与NIO）、AJP、APR、内存四种协议实现了该接口（它们分别是：AjpAprProtocol、AjpProtocol、Http11AprProtocol、Http11NioProtocol、Http11Protocal、JkCoyoteHandler、MemoryProtocolHandler），要使用哪种Connector就在conf/server.xml中配置，在Connector的构造函数中会通过反射实例化所配置的实现类：&lt;/p&gt;

&lt;pre&gt;&lt;/pre&gt;


&lt;h3&gt;3.3 Connector的工作流程&lt;/h3&gt;


&lt;p&gt;下面我们以Http11AprProtocol为例说明Connector的工作流程。&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;它将工作委托给NioEndpoint类。在NioEndpoint类的init方法中构建一个SocketServer(当然，不同的实现类会有一些微小的变化，例如如果是NIO，它构建的就是SocketServerChannel)&lt;/li&gt;
    &lt;li&gt;在NioEndpoint.Acceptor类中会接收一个客户端新的连接请求，如下图：&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2NLw6/medium.jpg&quot; alt=&quot;6&quot; width=&quot;500&quot; height=&quot;492&quot; /&gt;&lt;/p&gt;


&lt;p&gt;在NioEndpoint类中，有一个内部接口Handle，该接口定义如下：&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2NOBZ/medium.jpg&quot; alt=&quot;7&quot; width=&quot;500&quot; height=&quot;105&quot; /&gt;&lt;/p&gt;


&lt;p&gt;在Http11NioProtocol类中实现了Handle这个内部接口，并调用Http11NioProcessor类(该类实现了ActionHook回调接口)。在Response类中会调用ActionHook实现类的相关方法的，Response类的action方法如下：&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt_v/BBK2O5uW/medium.jpg&quot; alt=&quot;8&quot; width=&quot;469&quot; height=&quot;142&quot; /&gt;&lt;/p&gt;


&lt;p&gt;Http11NioProcessor的process实现方法中，会通过Adapter来调用Servler容器生成响应结果。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>2011杭州行-旅游篇</title>
   <link href="http://dreambt.github.com/Life/2011/12/01/2011-hangzhou"/>
   <updated>2011-12-01T09:39:28+08:00</updated>
   <id>http://dreambt.github.com/Life/2011/12/01/2011-hangzhou</id>
   <content type="html">&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;去往杭州的火车上，只传一张都不是很清楚&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBctYE8F/Rnl5f.jpg&quot; alt=&quot;C360_2011-07-05 05-00-18&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;知味观的猫耳朵和蟹黄蒸包，很给力哦~&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu0g3p/14sVBo.jpg&quot; alt=&quot;C360_2011-07-16 13-38-41_org&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;河坊街上的一家复古文具店&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu190k/959r5.jpg&quot; alt=&quot;C360_2011-07-16 16-20-13&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;南宋古街&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcuh5Pb/1YvbP.jpg&quot; alt=&quot;IMG_20110813_142206&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;450&quot; caption=&quot;南宋古街-缘溪行&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcug80r/NnE1r.jpg&quot; alt=&quot;IMG_20110813_142126&quot; width=&quot;450&quot; height=&quot;600&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖大道和南宋古街交界处的一户人家&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcufUVT/ljKMC.jpg&quot; alt=&quot;IMG_20110813_141504&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;外婆家-052号，外婆喊你吃饭喽~052号，外婆喊你吃饭喽~&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu3Mom/scM2j.jpg&quot; alt=&quot;IMG_20110717_121231&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖-先看一下地图免得迷路&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu6jkW/FggHt.jpg&quot; alt=&quot;IMG_20110730_132351&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖-路边&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu4HRn/SZSaL.jpg&quot; alt=&quot;IMG_20110730_132106&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖-比较满意的一张&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu6198/14QXg8.jpg&quot; alt=&quot;IMG_20110730_132135&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu7hYN/j8qnm.jpg&quot; alt=&quot;IMG_20110730_132456&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu84cI/stu2o.jpg&quot; alt=&quot;IMG_20110730_132516&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu9s8g/LNoaX.jpg&quot; alt=&quot;IMG_20110730_132540&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu9Xmj/jiNSg.jpg&quot; alt=&quot;IMG_20110730_132652&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;西湖&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcuano1/nn6Y9.jpg&quot; alt=&quot;IMG_20110730_132737&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;450&quot; caption=&quot;恶劣天气-不多说&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcudHy6/jDplb.jpg&quot; alt=&quot;IMG_20110813_140215&quot; width=&quot;450&quot; height=&quot;600&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;恶劣天气-近照&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcufCnc/wZ8Dl.jpg&quot; alt=&quot;IMG_20110813_140708&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;恶劣天气-近照&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcueNa5/8Vmq7.jpg&quot; alt=&quot;IMG_20110813_140643&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;川流不息&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu1OBB/q2dKX.jpg&quot; alt=&quot;C360_2011-07-17 17-31-19&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;给力的6*8路公交车&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu2oSb/fiNQh.jpg&quot; alt=&quot;C360_2011-07-19 20-42-03_org&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;450&quot; caption=&quot;记不清这个照片在哪拍的了...&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcu2RYl/BCgw.jpg&quot; alt=&quot;C360_2011-09-12 20-10-17&quot; width=&quot;450&quot; height=&quot;600&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;万丈高楼平地而起&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcubxSt/wMNaE.jpg&quot; alt=&quot;IMG_20110731_180554&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;600&quot; caption=&quot;传说中的Java咖啡&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcucYXR/o63Kw.jpg&quot; alt=&quot;IMG_20110808_084638&quot; width=&quot;600&quot; height=&quot;450&quot; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;&quot; align=&quot;aligncenter&quot; width=&quot;450&quot; caption=&quot;龟-虎妞，别想不开啊~&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt_v/BBcuhFqu/11DhwG.jpg&quot; alt=&quot;IMG_20110821_190655&quot; width=&quot;450&quot; height=&quot;600&quot; /&gt;[/caption]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JVM监控工具介绍jstack, jconsole, jinfo, jmap, jdb, jsta</title>
   <link href="http://dreambt.github.com/Java/2011/11/20/jvm-jstack-jconsole-jinfo-jmap-jdb-jsta"/>
   <updated>2011-11-20T20:44:11+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/11/20/jvm-jstack-jconsole-jinfo-jmap-jdb-jsta</id>
   <content type="html">&lt;h4&gt;jstatd&lt;/h4&gt;


&lt;p&gt;启动jvm监控服务。它是一个基于rmi的应用，向远程机器提供本机jvm应用程序的信息。默认端口1099。
实例：jstatd -J-Djava.security.policy=my.policy&lt;/p&gt;

&lt;p&gt;my.policy文件需要自己建立，内如如下：
grant codebase &quot;file:$JAVA_HOME/lib/tools.jar&quot; {
permission java.security.AllPermission;
};
这是安全策略文件，因为jdk对jvm做了jaas的安全检测，所以我们必须设置一些策略，使得jstatd被允许作网络操作&lt;/p&gt;

&lt;h4&gt;jps&lt;/h4&gt;


&lt;p&gt;列出所有的jvm实例
实例：
jps
列出本机所有的jvm实例&lt;/p&gt;

&lt;p&gt;jps 192.168.0.77
列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099
（前提是远程服务器提供jstatd服务）&lt;/p&gt;

&lt;p&gt;输出内容如下：
jones@jones:~/data/ebook/java/j2se/jdk_gc$ jps
6286 Jps
6174  Jstat&lt;/p&gt;

&lt;h4&gt;jconsole&lt;/h4&gt;


&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;一个图形化界面，可以观察到java进程的gc，class，内存等信息。&lt;/p&gt;

&lt;h4&gt;远程连接jconsole的方法&lt;/h4&gt;


&lt;p&gt;服务器端：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;mkdir $JAVA_HOME/jconsole&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;cp $JAVA_HOME/jre/lib/management/jmxremote.password $JAVA_HOME/jconsole/&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;chmod 600 $JAVA_HOME/jconsole/jmxremote.password&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;vi jmxremote.password&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;去掉#monitorRole RED前的注释并将RED修改为你要设置的密码。(安全起见，只开放有只读权限的用户)&lt;/p&gt;

&lt;p&gt;4.如果你是Tomcat&lt;/p&gt;

&lt;p&gt;在catalina.bat来设置set JAVA_OPTS=%JAVA_OPTS%&lt;/p&gt;

&lt;div&gt;-Dcom.sun.management.jmxremote.authenticate=false&lt;/div&gt;


&lt;div&gt;-Dcom.sun.management.jmxremote.ssl=false&lt;/div&gt;


&lt;div&gt;-Dcom.sun.management.jmxremote.port=7080&lt;/div&gt;


&lt;div&gt;-Dcom.sun.management.jmxremote&lt;/div&gt;


&lt;div&gt;4. 如果你是RESIN&lt;/div&gt;


&lt;p&gt;修改 $RESIN_HOME/bin/wrapper.pl，为$JAVA_ARGS添加三个参数：
-Dcom.sun.management.jmxremote.port=7080
-Dcom.sun.management.jmxremote.password.file=/usr/local/jdk1.6.0/jconsole/jmxremote.password
-Dcom.sun.management.jmxremote.ssl=false&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;执行hostname -i ，如果显示的是127.0.0.1，则需要修改/etc/hosts文件&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;vi /etc/hosts，修改如下：&lt;/p&gt;

&lt;h1&gt;127.0.0.1              localhost localhost.localdomain localhost&lt;/h1&gt;

&lt;p&gt;服务器的真实IP地址        localhost localhost.localdomain localhost&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;启动JSP容器&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;netstat -na|grep 7080 查看7080端口是否已在监听&lt;/p&gt;

&lt;p&gt;客户端:
1. 打开cmd窗口，输入jconsole
2. 指定连接参数:
远程主机: 服务器的真实IP地址
端口: 1010 ($JAVA_ARGS中-Dcom.sun.management.jmxremote.port指定的端口)
用户名: monitorRole (jmxremote.password中指定的用户名)
密码: your_password(jmxremote.password中设置的密码)
3. 连接 -&amp;gt; OK。&lt;/p&gt;

&lt;h4&gt;jinfo&lt;/h4&gt;


&lt;p&gt;观察运行中的java程序的运行环境参数：参数包括Java System属性和JVM命令行参数
实例：jinfo 2083
其中2083就是java进程id号，可以用jps得到这个id号。
输出内容太多了，不在这里一一列举，大家可以自己尝试这个命令。&lt;/p&gt;

&lt;h4&gt;jstack&lt;/h4&gt;


&lt;p&gt;可以观察到jvm中当前所有线程的运行情况和线程当前状态
jstack 2083
输出内容如下：&lt;/p&gt;

&lt;p&gt;转自：&lt;a href=&quot;http://dolphin-ygj.iteye.com/blog/366216&quot;&gt;http://dolphin-ygj.iteye.com/blog/366216&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java国际化资源文件相关的乱码问题</title>
   <link href="http://dreambt.github.com/Java/2011/11/14/java-internationalization-resource-files"/>
   <updated>2011-11-14T18:52:10+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/11/14/java-internationalization-resource-files</id>
   <content type="html">&lt;p&gt;是不得不重新总结一下国际化问题的时候了，因为今天浪费了我整整一个下午的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.定义国际化资源文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在resources目录里面新建一下文件：&lt;/p&gt;

&lt;pre&gt;ApplicationResources.properties
ApplicationResources_zh_CN.properties&lt;/pre&gt;


&lt;p&gt;文件的内容格式为“key=value”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.在代码中调用国际化资源文件&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;// 声明资源包
private ResourceBundle bundle;

// 通过类加载器获取资源包
bundle = PropertyResourceBundle.getBundle(&quot;ApplicationResources&quot;);

// 获取 i18n 字符串
bundle.getString(&quot;ApplicationTitle&quot;)&lt;/pre&gt;


&lt;p&gt;国际化就这么简单，上面的内容只是为了本文的完整性。当你运行程序的时候会发现乱码，MyEclipse等集成开发环境除外。下面是讲解重点：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;出现乱码的原因&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Property 文件中，使用的编码方式根据机器本身的设置可能是GBK或者UTF-8。而在Java程序中读取Property文件的时候使用的是Unicode编码方 式，这种编码方式不同会导致中文乱码。因此需要将Property文件中的中文字符转化成Unicode编码方式才能正常显示中文。&lt;/p&gt;

&lt;p&gt;有的IDE会自动给你转码，而有的不会。在不知情的情况下可能转码2次，也可能发生转码不对的情况。这是要注意检查资源文件的编码格式，同时利用我后面提供的批处理文件验证自己转码是否正确，一时解决不了的话可以直接用批处理的输出结果替换到打包文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.使用 native2ascii 工具将资源文件转为 Unicode 编码&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;native2ascii -[options] [inputfile [outputfile]]
说明：
-[options]：表示命令开关，有两个选项可供选择
-reverse：将Unicode编码转为本地或者指定编码，不指定编码情况下，将转为本地编码。
-encoding encoding_name：转换为指定编码，encoding_name为编码名称。
[inputfile [outputfile]]
inputfile：表示输入文件全名。
outputfile：输出文件名。如果缺少此参数，将输出到控制台。&lt;/pre&gt;


&lt;p&gt;下面是我提供给大家的一个小工具 &lt;a href=&quot;http://filemarkets.com/file/dreambt/a54ccf2e/&quot; target=&quot;_blank&quot;&gt;i18n.bat&lt;/a&gt;，可以批量转换指定目录下所有资源文件（请不要修改版权信息，谢谢！版本更新恕不通知）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.通过 Maven 管理国际化资源文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;也许你比我还懒，批处理都不愿意使用。好吧，我再提供一种更好的办法来满足你。&lt;/p&gt;

&lt;p&gt;抱歉：我的编辑器将尖括号转码了，请您自己用批量代替的方法转换一下吧。&lt;/p&gt;

&lt;pre&gt;        

                src/main/resources
                *_zh*.properties
                true

                org.codehaus.mojo
                native2ascii-maven-plugin
                1.0-beta-1

                            native2ascii

                            GBK

                                *_zh*.properties&lt;/pre&gt;


&lt;p&gt;至此，Java下的国际化问题就完美解决了，如果您有什么问题欢迎回复~&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Install VMWare Tools on Ubuntu Server</title>
   <link href="http://dreambt.github.com/Linux/2011/11/02/install-vmware-tools-on-ubuntu-server"/>
   <updated>2011-11-02T13:01:06+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/11/02/install-vmware-tools-on-ubuntu-server</id>
   <content type="html">&lt;p&gt;I don't often install Ubuntu server on a Virtual Machine (VM) so I've documented the process here. Usually you can just click &quot;install VMWare tools&quot; and VMWare will complete the process automatically.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I have tested this on VMWare workstation 7.0 and Ubuntu 9.10 to 11.10 is also works on Lubuntu and Xubuntu. Once you have Ubuntu server installed run the following commands.&lt;/p&gt;

&lt;pre&gt;#Change to super user
sudo -i

#Update your sources
apt-get update

#Upgrade your installed packages and force kernel upgrade
apt-get dist-upgrade

###
#  Now reboot
###
reboot

#back to super user
sudo -i

#Update your kernel:
apt-get install linux-headers-server build-essential

###
#  Now you are ready to install VMWare tools.
###

#Mount the VMWare Tools CD ISO
mkdir /mnt/cdrom
mount /dev/cdrom /mnt/cdrom

#Copy VMware Tools
cp /mnt/cdrom/VmwareTools-x.x.x-xxxxx.tar.gz /tmp

#Go tmp
cd /tmp

#Extract
tar -zxf VmwareTools-x.x.x-xxxxx.tar.gz

#Change to extracted directory
cd vmware-tools-distrib

#Start the installer
./vmware-install.pl&lt;/pre&gt;


&lt;p&gt;The default settings have always worked for me (within a vm) so I hit enter a lot. Anyone know how to automatically choose all the default options for quicker install?&lt;/p&gt;

&lt;h2&gt;Using Shared folders&lt;/h2&gt;


&lt;p&gt;After a reboot you can use tools such as Shared folders. I like to sym link my shared folders to my home directory as I tend to forget the mount directory (hgfs) location.&lt;/p&gt;

&lt;pre&gt;#move to home dir
cd 

#sym link and name vmSharedFolder
ln -s /mnt/hgfs/ vmSharedFolder&lt;/pre&gt;


&lt;div id=&quot;reference&quot;&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
Please note that if you use VMWare work station you can find all this in the help. When I wrote this I was using player, which at the time didn't include this in the help.
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.gorillapond.com/2006/07/31/install-vmware-tools-on-ubuntu/&quot;&gt;Gorillapond&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://ubuntu-tutorials.com/2008/06/07/how-to-install-vmware-tools-on-ubuntu-804-guests/&quot;&gt;Ubuntu tutorials&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://communities.vmware.com/thread/215289&quot;&gt;VMWare forum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>利用Java反射机制输出类实例的属性值</title>
   <link href="http://dreambt.github.com/Java/2011/11/01/java-reflection-mechanism-output-class-instance-attribute-values"/>
   <updated>2011-11-01T12:51:05+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/11/01/java-reflection-mechanism-output-class-instance-attribute-values</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;设计目的：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;平时我们调试代码可以使用IDE内置的Debug工具，但有的时候我们可能没有办法利用这些专业的Debug工具进行调试（比如我们自己设计一套监控系统）。于是，我设计了一个可以打印类变量中属性值的Java类，主要利用了Java的反射机制，方便直接调用查看POJO传值是否正确等。更多用途期待大家发现，欢迎交流～&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;源代码参考：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;打印类PrintClass：&lt;/p&gt;

&lt;pre&gt;package net.im47.utils;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

/**
 * User: siqi
 * Date: 11-10-31
 * Time: 下午10:10
 * 该类用于打印类中的所有属性及其类型、值。
 */
public class PrintClass {
    public static DateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);

    public static void print(Object object) {
        StringBuffer str = new StringBuffer();
        str.append(&quot;Attribute of instance: &quot; + object.toString() + &quot;\n&quot;);
        Field[] fields = object.getClass().getDeclaredFields();
        for (Field field : fields) {
            if (field.getName().equals(&quot;serialVersionUID&quot;) || field.getName().equals(&quot;$VALUES&quot;)) return;
            String name = getAttrName(field);
            String type = getAttrType(field);
            String value = getAttrValue(object, field, name);

            str.append(&quot;Name:&quot; + name);
            str.append(&quot;\t\tType:&quot; + type);
            str.append(&quot;\t\tValue:&quot; + value);
            str.append(&quot;\n&quot;);
        }
        System.out.println(str);
    }

    private static String getAttrName(Field field) {
        return field.getName();
    }

    private static String getAttrType(Field field) {
        return field.getGenericType().toString();
    }

    private static String getAttrValue(Object object, Field field, String attrName) {
        try {
            Method method = object.getClass().getMethod(&quot;get&quot; + attrName.substring(0, 1).toUpperCase() + attrName.substring(1));
            Class type = method.getReturnType();
            Object value = method.invoke(object);
            if (&quot;java.util.Date&quot;.equals(type.toString())) {
                //dateFormat = DateFormat.getDateInstance(DateFormat.SHORT);
                //dateFormat = DateFormat.getDateInstance(DateFormat.MEDIUM);
                dateFormat = DateFormat.getDateInstance(DateFormat.FULL);
                return dateFormat.format(value);
            } else {
                print(value);
                return value.toString();
            }
        } catch (NoSuchMethodException e) {
            //System.out.println(&quot;Error: NoSuchMethod: get&quot; + attrName.substring(0, 1).toUpperCase() + attrName.substring(1));
        } catch (InvocationTargetException e) {
            System.out.println(&quot;Error: NoInvocationTarget&quot;);
        } catch (IllegalAccessException e) {
            System.out.println(&quot;Error: IllegalAccess&quot;);
        }
        return &quot;&quot;;
    }

    public static void main(String[] args) throws ParseException {
        Date birthday = dateFormat.parse(&quot;1987-08-08&quot;);
        User user = new User(&quot;baitao.jibt&quot;, &quot;badsiu129hqw98ed&quot;, User.Gender.MALE, 24, birthday, new User.Address(&quot;china&quot;, &quot;shandong&quot;, &quot;jinan&quot;));
        PrintClass.print(user);
    }
}&lt;/pre&gt;


&lt;p&gt;待检查类User：&lt;/p&gt;

&lt;pre&gt;package net.im47.utils;

import java.util.Date;

/**
 * User: siqi
 * Date: 11-10-30
 * Time: 下午7:22
 */
public class User {
    private String username;
    private String password;
    private Gender gender;
    private int age;
    private Date birthday;
    private Address address;

    public enum Gender {MALE, FEMALE}

    ;

    public User() {

    }

    public User(String username, String password, int age) {
        this.username = username;
        this.password = password;
        this.age = age;
    }

    public User(String username, String password, Gender gender, int age) {
        this.username = username;
        this.password = password;
        this.gender = gender;
        this.age = age;
    }

    public User(String username, String password, Gender gender, int age, Date birthday, Address address) {
        this.username = username;
        this.password = password;
        this.gender = gender;
        this.age = age;
        this.birthday = birthday;
        this.address = address;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public Gender getGender() {
        return gender;
    }

    public void setGender(Gender gender) {
        this.gender = gender;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }

    public Address getAddress() {
        return address;
    }

    public void setAddress(Address address) {
        this.address = address;
    }

    public static class Address {
        private String country;
        private String province;
        private String city;

        public Address() {
        }

        public Address(String country, String city, String province) {
            this.country = country;
            this.city = city;
            this.province = province;
        }

        public String getCountry() {
            return country;
        }

        public void setCountry(String country) {
            this.country = country;
        }

        public String getProvince() {
            return province;
        }

        public void setProvince(String province) {
            this.province = province;
        }

        public String getCity() {
            return city;
        }

        public void setCity(String city) {
            this.city = city;
        }
    }
}&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>ubuntu开启SSH服务</title>
   <link href="http://dreambt.github.com/Linux/2011/10/31/ubuntu-open-ssh-service"/>
   <updated>2011-10-31T10:25:39+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/10/31/ubuntu-open-ssh-service</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;SSH简介&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSH 为 Secure Shell 的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SSH安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SSH分客户端openssh-client和openssh-server&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu默认安装）&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;如果要使本机开放SSH服务就需要安装openssh-server&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;pre&gt;sudo apt-get install openssh-client openssh-server&lt;/pre&gt;


&lt;p&gt;然后确认sshserver是否启动了：&lt;/p&gt;

&lt;pre&gt;ps -e |grep ssh&lt;/pre&gt;


&lt;p&gt;如果看到sshd那说明ssh-server已经启动了。
如果没有则可以这样启动：&lt;/p&gt;

&lt;pre&gt;sudo /etc/init.d/ssh start&lt;/pre&gt;


&lt;p&gt;ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号。
然后重启SSH服务：&lt;/p&gt;

&lt;pre&gt;sudo /etc/init.d/ssh stop
sudo /etc/init.d/ssh start&lt;/pre&gt;


&lt;p&gt;然后使用以下方式登陆SSH：&lt;/p&gt;

&lt;pre&gt;ssh username@192.168.1.112&lt;/pre&gt;


&lt;p&gt;username为192.168.1.112 机器上的用户，需要输入密码。
断开连接：exit&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit 4 中的Before After Ignore Test BeforeClass AfterClass</title>
   <link href="http://dreambt.github.com/Test/2011/10/30/junit-4-before-after-ignore-test-beforeclass-afterclass"/>
   <updated>2011-10-30T12:01:54+08:00</updated>
   <id>http://dreambt.github.com/Test/2011/10/30/junit-4-before-after-ignore-test-beforeclass-afterclass</id>
   <content type="html">&lt;p&gt;JUnit 4 使用 Java 5 中的注解（annotation），以下是JUnit 4 常用的几个 annotation 介绍&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@BeforeClass：针对所有测试，只执行一次，且必须为static void&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@Before：初始化方法&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@Test：测试方法，在这里可以测试期望异常和超时时间&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@Ignore：忽略的测试方法&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@After：释放资源
&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: 18px;&quot;&gt;@AfterClass：针对所有测试，只执行一次，且必须为static void&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;一个JUnit 4 的单元测试用例执行顺序为：&lt;/p&gt;

&lt;blockquote&gt;@BeforeClass –&amp;gt; @Before –&amp;gt; @Test –&amp;gt; @After –&amp;gt; @AfterClass&lt;/blockquote&gt;


&lt;p&gt;每一个测试方法的调用顺序为：&lt;/p&gt;

&lt;blockquote&gt;@Before –&amp;gt; @Test –&amp;gt; @After&lt;/blockquote&gt;


&lt;p&gt;写个例子测试一下，测试一下&lt;/p&gt;

&lt;pre&gt;package net.im47.demo.junit;

import org.junit.*;
import static org.junit.Assert.*;

public class JUnit4Test {
    @Before
    public void before() {
        System.out.println(&quot;@Before&quot;);
    }

    @Test
    public void test() {
        System.out.println(&quot;@Test&quot;);
        assertEquals(5 + 5, 10);
    }

    @Ignore
    @Test
    public void testIgnore() {
        System.out.println(&quot;@Ignore&quot;);
    }

    @Test(timeout = 50)
    public void testTimeout() {
        System.out.println(&quot;@Test(timeout = 50)&quot;);
        assertEquals(5 + 5, 10);
    }

    @Test(expected = ArithmeticException.class)
    public void testExpected() {
        System.out.println(&quot;@Test(expected = Exception.class)&quot;);
        throw new ArithmeticException();
    }

    @After
    public void after() {
        System.out.println(&quot;@After&quot;);
    }

    @BeforeClass
    public static void beforeClass() {
        System.out.println(&quot;@BeforeClass&quot;);
    }

    @AfterClass
    public static void afterClass() {
        System.out.println(&quot;@AfterClass&quot;);
    }
}&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;输出结果&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;pre&gt;@BeforeClass
@Before
@Test
@After
Test 'net.im47.demo.junit.JUnit4Test.testIgnore' ignored
@Before
@Test(timeout = 50)
@After
@Before
@Test(expected = Exception.class)
@After
@AfterClass&lt;/pre&gt;
&lt;/blockquote&gt;


&lt;p&gt;&lt;strong&gt;对比：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;@BeforeClass 和 @AfterClass 对于那些比较“昂贵”的资源的分配或者释放来说是很有效的，因为他们只会在类中被执行一次。相比之下对于那些需要在每次运行之前都要初始化或者在运行之后都需要被清理的资源来说使用@Before和@After同样是一个比较明智的选择。&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;@BeforeClass and @AfterClass&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;@Before and @After&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;在一个类中只可以出现一次&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: normal;&quot;&gt;在一个类中可以出现多次，即可以在多个方法的声明前加上这两个Annotaion标签，执行顺序不确定&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;方法名不做限制&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;方法名不做限制&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;在类中只运行一次&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;在每个测试方法之前或者之后都会运行一次&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;line-height: normal;&quot;&gt;@BeforeClass父类中标识了该Annotation的方法将会先于当前类中标识了该Annotation的方法执行。
@AfterClass 父类中标识了该Annotation的方法将会在当前类中标识了该Annotation的方法之后执行&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;@Before父类中标识了该Annotation的方法将会先于当前类中标识了该Annotation的方法执行。
@After父类中标识了该Annotation的方法将会在当前类中标识了该Annotation的方法之后执行&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;必须声明为public static&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;必须声明为public 并且非static&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;所有标识为@AfterClass的方法都一定会被执行，即使在标识为@BeforeClass的方法抛出异常的的情况下也一样会。&lt;/span&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;color: #504e53; font-family: 'Lucida Grande', 'Lucida Sans Unicode', verdana, arial, Tahoma, Verdana, sans-serif; font-size: x-small;&quot;&gt;所有标识为@After 的方法都一定会被执行，即使在标识为 @Before 或者 @Test 的方法抛出异常的的情况下也一样会。&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>RabbitMQ常见问题整理</title>
   <link href="http://dreambt.github.com/MQ/2011/10/20/rabbitmq"/>
   <updated>2011-10-20T15:58:20+08:00</updated>
   <id>http://dreambt.github.com/MQ/2011/10/20/rabbitmq</id>
   <content type="html">&lt;h2&gt;1.在成功安装为services后,start也成功,但是rabbitmqctl.bat status却提示&lt;/h2&gt;


&lt;p&gt;或者rabbitmqctl list_exchanges&lt;/p&gt;

&lt;pre&gt;Error: unable to connect to node '?': nodedown&lt;/pre&gt;


&lt;p&gt;参考&lt;a href=&quot;http://www.rabbitmq.com/install.html#running-windows-service&quot;&gt;http://www.rabbitmq.com/install.html#running-windows-service&lt;/a&gt;中 Troubleshooting 一节中提到&lt;span class=&quot;Apple-style-span&quot; style=&quot;font-family: 'Courier New', Courier, 'Lucida Console', Monaco, 'DejaVu Sans Mono', 'Nimbus Mono L', 'Bitstream Vera Sans Mono', monospace; font-size: 12px; line-height: normal; white-space: pre-wrap; background-color: #ffffff;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This example indicates that no broker is running:&lt;/p&gt;

&lt;pre&gt;  Status of node 'rabbit@xxx' ...
  Error: unable to connect to node 'rabbit@xxx': nodedown
  diagnostics:
  - nodes and their ports on xxx: [{rabbitmqctl,...}]
  - current node: 'rabbitmqctlxxx@xxx'
  - current node home dir: [...]
  - current node cookie hash: [...]If the diagnostic line looks like this:&lt;/pre&gt;


&lt;pre&gt;  - nodes and their ports on xxx: [{rabbit,...},{rabbitmqctl,...}]&lt;/pre&gt;


&lt;p&gt;and the broker logfile contains entries similar to&lt;/p&gt;

&lt;pre&gt;  Connection attempt from disallowed node...&lt;/pre&gt;


&lt;p&gt;then you should make sure the erlang cookies are the same.&lt;/p&gt;

&lt;p&gt;所以删了%APPDATA%下的&quot;RabbitMQ&quot;目录&lt;/p&gt;

&lt;p&gt;和%USERPROFILE%下的&quot;.erlang.cookie&quot;文件,再试,还是失败&lt;/p&gt;

&lt;p&gt;然后看到 &lt;a href=&quot;http://www.rabbitmq.com/man/rabbitmq-service.man.html&quot;&gt;http://www.rabbitmq.com/man/rabbitmq-service.man.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中有一句&lt;/p&gt;

&lt;pre&gt;(typically C:\WINDOWS\.erlang.cookie and the account that will be used to run rabbitmqctl.&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #008080;&quot;&gt;去把C:\WINDOWS.erlang.cookie复制出来,覆盖掉%USERPROFILE%下的&quot;.erlang.cookie&quot;文件,再试,成功&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>[翻译] [RabbitMQ入门经典] 兔子和兔子窝</title>
   <link href="http://dreambt.github.com/MQ/2011/10/20/rabbits-and-warrens"/>
   <updated>2011-10-20T13:14:16+08:00</updated>
   <id>http://dreambt.github.com/MQ/2011/10/20/rabbits-and-warrens</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;http://www.rabbitmq.com/&quot; target=&quot;_blank&quot;&gt;RabbitMQ&lt;/a&gt;作为一个工业级的消息队列服务器，在其&lt;a href=&quot;http://www.rabbitmq.com/how.html#clients&quot; target=&quot;_blank&quot;&gt;客户端手册列表&lt;/a&gt;的Python段当中推荐了&lt;a href=&quot;http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/&quot; target=&quot;_blank&quot;&gt;一篇blog&lt;/a&gt;，作为RabbitMQ+Python的入门手册再合适不过了。不过，正如其标题&lt;em&gt;Rabbit and Warrens&lt;/em&gt;（兔子和养兔场）一样，这篇英文写的相当俏皮，以至于对于我等非英文读者来说不像一般的技术文档那么好懂，所以，翻译一下吧。翻译过了，希望其他人可以少用一些时间。翻译水平有限，不可能像原文一样俏皮，部分地方可能就意译了，希望以容易懂为准。想看看老外的幽默的，推荐去看原文，其实，也不是那么难理解……&lt;/p&gt;

&lt;p&gt;原文：&lt;a href=&quot;http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/&quot; target=&quot;_blank&quot;&gt;http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;兔子和兔子窝&lt;/h2&gt;


&lt;p&gt;当时我们的动机很简单：从生产环境的电子邮件处理流程当中分支出一个特定的离线分析流程。我们开始用的MySQL，将要处理的东西放在表里面，另一个程序从中取。不过很快，这种设计的丑陋之处就显现出来了…… 你想要多个程序从一个队列当中取数据来处理？没问题，我们硬编码程序的个数好了……什么？还要能够允许程序动态地增加和减少的时候动态进行压力分配？&lt;/p&gt;

&lt;p&gt;是的，当年我们想的简单的东西（做一个分支处理）逐渐变成了一个棘手的问题。以前拿着锤子（MySQL）看所有东西都是钉子（表）的年代是多么美好……&lt;/p&gt;

&lt;p&gt;在搜索了一下之后，我们走进了消息队列（message queue）的大门。不不，我们当然知道消息队列是什么，我们可是以做电子邮件程序谋生的。我们实现过各种各样的专业的，高速的内存队列用来做电子邮件处理。我们不知道的是那一大类现成的、通用的消息队列（MQ）服务器——无论是用什么语言写出的，不需要复杂的装配的，可以自然的在网络上的应用程序之间传送数据的一类程序。不用我们自己写？看看再说。&lt;/p&gt;

&lt;h3&gt;让大家看看你们的Queue吧……&lt;/h3&gt;


&lt;p&gt;过去的4年里，人们写了有好多好多的开源的MQ服务器啊。其中大多数都是某公司例如LiveJournal写出来用来解决特定问题的。它们的确不关心上面跑的是什么类型的消息，不过他们的设计思想通常是和创建者息息相关的（消息的持久化，崩溃恢复等通常不在他们考虑范围内）。不过，有三个专门设计用来做及其灵活的消息队列的程序值得关注：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://activemq.apache.org/&quot;&gt;Apache ActiveMQ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.zeromq.org/&quot;&gt;ZeroMQ&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;RabbitMQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Apache ActiveMQ 曝光率最高，不过看起来它有些问题，可能会造成丢消息。不可接受，下一个。&lt;/p&gt;

&lt;p&gt;ZeroMQ 和 RabbitMQ 都支持一个开源的消息协议，成为AMQP。AMQP的一个优点是它是一个灵活和开放的协议，以便和另外两个商业化的Message Queue （IBM和Tibco）竞争，很好。不过ZeroMQ不支持消息持久化和崩溃恢复，不太好。剩下的只有RabbitMQ了。如果你不在意消息持久化和崩溃恢复，试试ZeroMQ吧，延迟很低，而且支持灵活的拓扑。&lt;/p&gt;

&lt;h3&gt;剩下的只有这个吃胡萝卜的家伙了……&lt;/h3&gt;


&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/RabbitMQLogo.png&quot; alt=&quot;&quot; border=&quot;0&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我读到它是用Erlang写的时候，RabbitMQ震了我一下。&lt;a href=&quot;http://en.wikipedia.org/wiki/Erlang_%28programming_language%29&quot;&gt;Erlang&lt;/a&gt; 是爱立信开发的高度并行的语言，用来跑在电话交换机上。是的，那些要求6个9的在线时间的东西。在Erlang当中，充斥着大量轻量进程，它们之间用消息传递来通信。听起来思路和我们用消息队列的思路是一样的，不是么？&lt;/p&gt;

&lt;p&gt;而且，RabbitMQ支持持久化。是的，如果RabbitMQ死掉了，消息并不会丢失，当队列重启，一切都会回来。而且，正如在DigiTar（注：原文作者的公司）做事情期望的那样，它可以和Python无缝结合。除此之外，RabbitMQ的文档相当的……恐怖。如果你懂AMQP，这些文档还好，但是有多少人懂AMQP？这些文档就像MySQL的文档假设你已经懂了SQL一样……不过没关系啦。&lt;/p&gt;

&lt;p&gt;好了，废话少说。这里是花了一周时间阅读关于AMQP和关于它如何在RabbitMQ上工作的文档之后的一个总结，还有，怎么在Python当中使用。&lt;/p&gt;

&lt;h3&gt;开始吧&lt;/h3&gt;


&lt;p&gt;AMQP当中有四个概念非常重要：虚拟主机（virtual host），交换机（exchange），队列（queue）和绑定（binding）。一个虚拟主机持有一组交换机、队列和绑定。为什么需要多个虚拟主机呢？很简单，RabbitMQ当中，用户只能在虚拟主机的粒度进行权限控制。因此，如果需要禁止A组访问B组的交换机/队列/绑定，必须为A和B分别创建一个虚拟主机。每一个RabbitMQ服务器都有一个默认的虚拟主机“/”。如果这就够了，那现在就可以开始了。&lt;/p&gt;

&lt;h3&gt;交换机，队列，还有绑定……天哪！&lt;/h3&gt;


&lt;p&gt;刚开始我思维的列车就是在这里脱轨的…… 这些鬼东西怎么结合起来的？&lt;/p&gt;

&lt;p&gt;队列（Queues）是你的消息（messages）的终点，可以理解成装消息的容器。消息就一直在里面，直到有客户端（也就是消费者，Consumer）连接到这个队列并且将其取走为止。不过。你可以将一个队列配置成这样的：一旦消息进入这个队列，biu~，它就烟消云散了。这个有点跑题了……&lt;/p&gt;

&lt;p&gt;需要记住的是，队列是由消费者（Consumer）通过程序建立的，不是通过配置文件或者命令行工具。这没什么问题，如果一个消费者试图创建一个已经存在的队列，RabbitMQ就会起来拍拍他的脑袋，笑一笑，然后忽略这个请求。因此你可以将消息队列的配置写在应用程序的代码里面。这个概念不错。&lt;/p&gt;

&lt;p&gt;OK，你已经创建并且连接到了你的队列，你的消费者程序正在百无聊赖的敲着手指等待消息的到来，敲啊，敲啊…… 没有消息。发生了什么？你当然需要先把一个消息放进队列才行。不过要做这个，你需要一个交换机（Exchange）……&lt;/p&gt;

&lt;p&gt;交换机可以理解成具有路由表的路由程序，仅此而已。每个消息都有一个称为路由键（routing key）的属性，就是一个简单的字符串。交换机当中有一系列的绑定（binding），即路由规则（routes），例如，指明具有路由键 “X” 的消息要到名为timbuku的队列当中去。先不讨论这个，我们有点超前了。&lt;/p&gt;

&lt;p&gt;你的消费者程序要负责创建你的交换机&lt;strong&gt;们&lt;/strong&gt;（复数）。啥？你是说你可以有多个交换机？是的，这个可以有，不过为啥？很简单，每个交换机在自己独立的进程当中执行，因此增加多个交换机就是增加多个进程，可以充分利用服务器上的CPU核以便达到更高的效率。例如，在一个8核的服务器上，可以创建5个交换机来用5个核，另外3个核留下来做消息处理。类似的，在RabbitMQ的集群当中，你可以用类似的思路来扩展交换机一边获取更高的吞吐量。&lt;/p&gt;

&lt;p&gt;OK，你已经创建了一个交换机。但是他并不知道要把消息送到哪个队列。你需要路由规则，即绑定（binding）。一个绑定就是一个类似这样的规则：将交换机“desert（沙漠）”当中具有路由键“阿里巴巴”的消息送到队列“hideout（山洞）”里面去。换句话说，一个绑定就是一个基于路由键将交换机和队列连接起来的路由规则。例如，具有路由键“audit”的消息需要被送到两个队列，“log-forever”和“alert-the-big-dude”。要做到这个，就需要创建两个绑定，每个都连接一个交换机和一个队列，两者都是由“audit”路由键触发。在这种情况下，交换机会复制一份消息并且把它们分别发送到两个队列当中。交换机不过就是一个由绑定构成的路由表。&lt;/p&gt;

&lt;p&gt;现在复杂的东西来了：交换机有多种类型。他们都是做路由的，不过接受不同类型的绑定。为什么不创建一种交换机来处理所有类型的路由规则呢？因为每种规则用来做匹配分子的CPU开销是不同的。例如，一个“topic”类型的交换机试图将消息的路由键与类似“&lt;strong&gt;dogs.*&lt;/strong&gt;”的模式进行匹配。匹配这种末端的通配符比直接将路由键与“&lt;strong&gt;dogs&lt;/strong&gt;”比较（“direct”类型的交换机）要消耗更多的CPU。如果你不需要“topic”类型的交换机带来的灵活性，你可以通过使用“direct”类型的交换机获取更高的处理效率。那么有哪些类型，他们又是怎么处理的呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fanout Exchange&lt;/strong&gt; – 不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Direct Exchange&lt;/strong&gt; – 处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“&lt;strong&gt;dog&lt;/strong&gt;”的消息才被转发，不会转发&lt;strong&gt;dog.puppy&lt;/strong&gt;，也不会转发&lt;strong&gt;dog.guard&lt;/strong&gt;，只会转发&lt;strong&gt;dog&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Topic Exchange&lt;/strong&gt; – 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“&lt;em&gt;”匹配不多不少一个词。因此“audit.#”能够匹配到“&lt;strong&gt;audit.irs.corporate&lt;/strong&gt;”，但是“&lt;strong&gt;audit.&lt;/em&gt;&lt;/strong&gt;” 只会匹配到“&lt;strong&gt;audit.irs&lt;/strong&gt;”。我在RedHat的朋友做了一张不错的图，来表明topic交换机是如何工作的：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/10/topic-exchange.png&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1027&quot; title=&quot;topic-exchange&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/10/topic-exchange.png&quot; alt=&quot;&quot; width=&quot;444&quot; height=&quot;323&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;div&gt;&lt;/div&gt;


&lt;p&gt;&lt;span class=&quot;Apple-style-span&quot; style=&quot;font-size: 20px; line-height: normal;&quot;&gt;持久化这些小东西们&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;你花了大量的时间来创建队列、交换机和绑定，然后，砰～服务器程序挂了。你的队列、交换机和绑定怎么样了？还有，放在队列里面但是尚未处理的消息们呢？&lt;/p&gt;

&lt;p&gt;放松～如果你是用默认参数构造的这一切的话，那么，他们，都，biu~，灰飞烟灭了。是的，RabbitMQ重启之后会干净的像个新生儿。你必须重做所有的一切，亡羊补牢，如何避免将来再度发生此类杯具？&lt;/p&gt;

&lt;p&gt;队列和交换机有一个创建时候指定的标志durable，直译叫做坚固的。durable的唯一含义就是具有这个标志的队列和交换机会在重启之后重新建立，它不表示说在队列当中的消息会在重启后恢复。那么如何才能做到不只是队列和交换机，还有消息都是持久的呢？&lt;/p&gt;

&lt;p&gt;但是首先一个问题是，你真的需要消息是持久的吗？对于一个需要在重启之后回复的消息来说，它需要被写入到磁盘上，而即使是最简单的磁盘操作也是要消耗时间的。如果和消息的内容相比，你更看重的是消息处理的速度，那么不要使用持久化的消息。不过对于我们@DigiTar来说，持久化很重要。&lt;/p&gt;

&lt;p&gt;当你将消息发布到交换机的时候，可以指定一个标志“Delivery Mode”（投递模式）。根据你使用的AMQP的库不同，指定这个标志的方法可能不太一样（我们后面会讨论如何用Python搞定）。简单的说，就是将Delivery Mode设置成2，也就是持久的（persistent）即可。一般的AMQP库都是将Delivery Mode设置成1，也就是非持久的。所以要持久化消息的步骤如下：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;将交换机设成 durable。&lt;/li&gt;
    &lt;li&gt;将队列设成 durable。&lt;/li&gt;
    &lt;li&gt;将消息的 Delivery Mode 设置成2 。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;就这样，不是很复杂，起码没有造火箭复杂，不过也有可能犯点小错误。&lt;/p&gt;

&lt;p&gt;下面还要罗嗦一个东西……绑定（Bindings）怎么办？我们无法在创建绑定的时候设置成durable。没问题，如果你绑定了一个durable的队列和一个durable的交换机，RabbitMQ会自动保留这个绑定。类似的，如果删除了某个队列或交换机（无论是不是durable），依赖它的绑定都会自动删除。&lt;/p&gt;

&lt;p&gt;注意两点：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;RabbitMQ 不允许你绑定一个非坚固（non-durable）的交换机和一个durable的队列。反之亦然。要想成功必须队列和交换机都是durable的。&lt;/li&gt;
    &lt;li&gt;一旦创建了队列和交换机，就不能修改其标志了。例如，如果创建了一个non-durable的队列，然后想把它改变成durable的，唯一的办法就是删除这个队列然后重现创建。因此，最好仔细检查创建的标志。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;开始喂蛇了～&lt;/h3&gt;


&lt;p&gt;【译注】说喂蛇是因为Python的图标是条蛇。&lt;/p&gt;

&lt;p&gt;AMQP的一个空白地带是如何在Python当中使用。对于其他语言有一大坨材料。&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;Java – &lt;a href=&quot;http://www.rabbitmq.com/java-client.html&quot;&gt;http://www.rabbitmq.com/java-client.html&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;.NET – &lt;a href=&quot;http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/v1.5.0/rabbitmq-dotnet-client-1.5.0-user-guide.pdf&quot;&gt;http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/v1.5.0/rabbitmq-dotnet-client-1.5.0-user-guide.pdf&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;Ruby – &lt;a href=&quot;http://somic.org/2008/06/24/ruby-amqp-rabbitmq-example/&quot;&gt;http://somic.org/2008/06/24/ruby-amqp-rabbitmq-example/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;但是对Python老兄来说，你需要花点时间来挖掘一下。所以我写了这个，这样别的家伙们就不需要经历我这种抓狂的过程了。&lt;/p&gt;

&lt;p&gt;首先，我们需要一个Python的AMQP库。有两个可选：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://barryp.org/software/py-amqplib/&quot;&gt;py-amqplib&lt;/a&gt; – 通用的AMQP&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://launchpad.net/txamqp&quot;&gt;txAMQP&lt;/a&gt; – 使用 &lt;a href=&quot;http://www.twistedmatrix.com/&quot;&gt;Twisted&lt;/a&gt; 框架的AMQP库，因此允许异步I/O。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;根据你的需求，py-amqplib或者txAMQP都是可以的。因为是基于Twisted的，txAMQP可以保证用异步IO构建超高性能的AMQP程序。但是Twisted编程本身就是一个很大的主题……因此清晰起见，我们打算用 py-amqplib。&lt;strong&gt;更新：请参见Esteve Fernandez关于txAMQP的使用和代码样例的&lt;a href=&quot;http://blogs.digitar.com/jjww/2009/01/rabbits-and-warrens/#comment-681&quot; target=&quot;_blank&quot;&gt;回复&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AMQP支持在一个TCP连接上启用多个MQ通信channel，每个channel都可以被应用作为通信流。每个AMQP程序至少要有一个连接和一个channel。&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;from amqplib import client_0_8 as amqp
conn = amqp.Connection(host=&quot;localhost:5672 &quot;, userid=&quot;guest&quot;,
password=&quot;guest&quot;, virtual_host=&quot;/&quot;, insist=False)
chan = conn.channel()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;每个channel都被分配了一个整数标识，自动由Connection()类的.channel()方法维护。或者，你可以使用.channel(x)来指定channel标识，其中x是你想要使用的channel标识。通常情况下，推荐使用.channel()方法来自动分配channel标识，以便防止冲突。&lt;/p&gt;

&lt;p&gt;现在我们已经有了一个可以用的连接和channel。现在，我们的代码将分成两个应用，生产者（producer）和消费者（consumer）。我们先创建一个消费者程序，他会创建一个叫做“po_box”的队列和一个叫“sorting_room”的交换机：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;chan.queue_declare(queue=&quot;po_box&quot;, durable=True,
exclusive=False, auto_delete=False)
chan.exchange_declare(exchange=&quot;sorting_room&quot;, type=&quot;direct&quot;, durable=True,
auto_delete=False,)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;这段代码干了啥？首先，它创建了一个名叫“&lt;strong&gt;po_box&lt;/strong&gt;”的队列，它是durable的（重启之后会重新建立），并且最后一个消费者断开的时候不会自动删除（&lt;strong&gt;auto_delete=False&lt;/strong&gt;）。在创建durable的队列（或者交换机）的时候，将auto_delete设置成false是很重要的，否则队列将会在最后一个消费者断开的时候消失，与durable与否无关。如果将durable和auto_delete都设置成True，只有尚有消费者活动的队列可以在RabbitMQ意外崩溃的时候自动恢复。&lt;/p&gt;

&lt;p&gt;（你可以注意到了另一个标志，称为“exclusive”。如果设置成True，只有创建这个队列的消费者程序才允许连接到该队列。这种队列对于这个消费者程序是私有的）。&lt;/p&gt;

&lt;p&gt;还有另一个交换机声明，创建了一个名字叫“sorting_room”的交换机。auto_delete和durable的含义和队列是一样的。但是，.excange_declare() 还有另外一个参数叫做type，用来指定要创建的交换机的类型（如前面列出的）： &lt;strong&gt;fanout&lt;/strong&gt;, &lt;strong&gt;direct&lt;/strong&gt; 和 &lt;strong&gt;topic&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;到此为止，你已经有了一个可以接收消息的队列和一个可以发送消息的交换机。不过我们需要创建一个绑定，把它们连接起来。&lt;/p&gt;

&lt;p&gt;chan.queue_bind(queue=”po_box”, exchange=”sorting_room”,
routing_key=”jason”)&lt;/p&gt;

&lt;p&gt;这个绑定的过程非常直接。任何送到交换机“&lt;strong&gt;sorting_room&lt;/strong&gt;”的具有路由键“&lt;strong&gt;jason&lt;/strong&gt;” 的消息都被路由到名为“&lt;strong&gt;po_box&lt;/strong&gt;” 的队列。&lt;/p&gt;

&lt;p&gt;现在，你有两种方法从队列当中取出消息。第一个是调用&lt;strong&gt;chan.basic_get()&lt;/strong&gt;，主动从队列当中拉出下一个消息（如果队列当中没有消息，chan.basic_get()会返回None， 因此下面代码当中print msg.body 会在没有消息的时候崩掉）：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;msg = chan.basic_get(&quot;po_box&quot;)
print msg.body
chan.basic_ack(msg.delivery_tag)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;但是如果你想要应用程序在消息到达的时候立即得到通知怎么办？这种情况下不能使用&lt;strong&gt;chan.basic_get()&lt;/strong&gt;，你需要用&lt;strong&gt;chan.basic_consume()&lt;/strong&gt;注册一个新消息到达的回调。&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;def recv_callback(msg):
    print 'Received: ' + msg.body
chan.basic_consume(queue='po_box', no_ack=True,
callback=recv_callback, consumer_tag=&quot;testtag&quot;)
while True:
    chan.wait()
chan.basic_cancel(&quot;testtag&quot;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;chan.wait()&lt;/strong&gt; 放在一个无限循环里面，这个函数会等待在队列上，直到下一个消息到达队列。&lt;strong&gt;chan.basic_cancel()&lt;/strong&gt; 用来注销该回调函数。参数&lt;strong&gt;consumer_tag&lt;/strong&gt; 当中指定的字符串和&lt;strong&gt;chan.basic_consume()&lt;/strong&gt; 注册的一直。在这个例子当中&lt;strong&gt;chan.basic_cancel()&lt;/strong&gt; 不会被调用到，因为上面是个无限循环…… 不过你需要知道这个调用，所以我把它放在了代码里。&lt;/p&gt;

&lt;p&gt;需要注意的另一个东西是&lt;strong&gt;no_ack&lt;/strong&gt;参数。这个参数可以传给&lt;strong&gt;chan.basic_get()&lt;/strong&gt;和&lt;strong&gt;chan.basic_consume()&lt;/strong&gt;，默认是false。当从队列当中取出一个消息的时候，RabbitMQ需要应用显式地回馈说已经获取到了该消息。如果一段时间内不回馈，RabbitMQ会将该消息重新分配给另外一个绑定在该队列上的消费者。另一种情况是消费者断开连接，但是获取到的消息没有回馈，则RabbitMQ同样重新分配。如果将&lt;strong&gt;no_ack&lt;/strong&gt; 参数设置为true，则py-amqplib会为下一个AMQP请求添加一个no_ack属性，告诉AMQP服务器不需要等待回馈。但是，大多数时候，你也许想要自己手工发送回馈，例如，需要在回馈之前将消息存入数据库。回馈通常是通过调用&lt;strong&gt;chan.basic_ack()&lt;/strong&gt;方法，使用消息的&lt;strong&gt;delivery_tag&lt;/strong&gt;属性作为参数。参见&lt;strong&gt;chan.basic_get()&lt;/strong&gt; 的实例代码。&lt;/p&gt;

&lt;p&gt;好了，这就是消费者的全部代码。（下载：&lt;a href=&quot;http://blogs.digitar.com/jjww/code-samples/amqp_consumer.py&quot;&gt;amqp_consumer.py&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;不过没有人发送消息的话，要消费者何用？所以需要一个生产者。下面的代码示例表明如何将一个简单消息发送到交换区“&lt;strong&gt;sorting_room&lt;/strong&gt;”，并且标记为路由键“&lt;strong&gt;jason&lt;/strong&gt;” ：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;msg = amqp.Message(&quot;Test message!&quot;)
msg.properties[&quot;delivery_mode&quot;] = 2
chan.basic_publish(msg,exchange=&quot;sorting_room&quot;,routing_key=&quot;jason&quot;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;你也许注意到我们设置消息的&lt;strong&gt;delivery_mode&lt;/strong&gt;属性为2，因为队列和交换机都设置为durable的，这个设置将保证消息能够持久化，也就是说，当它还没有送达消费者之前如果RabbitMQ重启则它能够被恢复。&lt;/p&gt;

&lt;p&gt;剩下的最后一件事情（生产者和消费者都需要调用的）是关闭channel和连接：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;
&lt;pre&gt;chan.close()
conn.close()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;很简单吧。（下载：&lt;a href=&quot;http://blogs.digitar.com/jjww/code-samples/amqp_publisher.py&quot;&gt;amqp_publisher.py&lt;/a&gt;）&lt;/p&gt;

&lt;h3&gt;来真实地跑一下吧……&lt;/h3&gt;


&lt;p&gt;现在我们已经写好了生产者和消费者，让他们跑起来吧。假设你的RabbitMQ在localhost上安装并且运行。&lt;/p&gt;

&lt;p&gt;打开一个终端，执行&lt;strong&gt;python ./amqp_consumer.py&lt;/strong&gt;让消费者运行，并且创建队列、交换机和绑定。&lt;/p&gt;

&lt;p&gt;然后在另一个终端运行&lt;strong&gt;python ./amqp_publisher.py “AMQP rocks.”&lt;/strong&gt; 。如果一切良好，你应该能够在第一个终端看到输出的消息。&lt;/p&gt;

&lt;h3&gt;付诸使用吧&lt;/h3&gt;


&lt;p&gt;我知道这个教程是非常粗浅的关于AMQP/RabbitMQ和如何使用Python访问的教程。希望这个可以说明所有的概念如何在Python当中被组合起来。如果你发现任何错误，请联系原作者(&lt;a href=&quot;mailto:williamsjj@digitar.com&quot;&gt;williamsjj@digitar.com&lt;/a&gt;) 【译注：如果是翻译问题请联系译者】。同时，我很高兴回答我知道的问题。【译注：译者也是一样的】。接下来是，集群化（clustering）！不过我需要先把它弄懂再说。&lt;/p&gt;

&lt;p&gt;注：关于RabbitMQ的知识我主要来自这些来源，推荐阅读：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://blog.ftofficer.com/2010/03/translation-rabbitmq-python-rabbits-and-warrens/&quot;&gt;zeromq：消息中间件分析&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.rabbitmq.com/releases/rabbitmq-dotnet-client/v1.5.0/rabbitmq-dotnet-client-1.5.0-user-guide.pdf&quot;&gt;RabbitMQ .NET客户端库用户手册&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;http://jira.amqp.org/confluence/download/attachments/720900/amqp0-8.pdf?version=1&quot;&gt;高级消息队列协议（Advanced Message Queuing Protocol）：协议规约0.8 版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;–完–&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>KMP算法详解</title>
   <link href="http://dreambt.github.com/Algorithm/2011/10/19/kmp-algorithm"/>
   <updated>2011-10-19T10:42:28+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/10/19/kmp-algorithm</id>
   <content type="html">&lt;p&gt;KMP算法是拿来处理字符串匹配的。换句话说，给你两个字符串，你需要回答，B串是否是A串的子串（A串是否包含B串）。比如，字符串A=&quot;I'm matrix67&quot;，字符串B=&quot;matrix&quot;，我们就说B是A的子串。你可以委婉地问你的MM：“假如你要向你喜欢的人表白的话，我的名字是你的告白语中的子串吗？”
解决这类问题，通常我们的方法是枚举从A串的什么位置起开始与B匹配，然后验证是否匹配。假如A串长度为n，B串长度为m，那么这种方法的复杂度是O (mn)的。虽然很多时候复杂度达不到mn（验证时只看头一两个字母就发现不匹配了），但我们有许多“最坏情况”，比如，A= &quot;aaaaaaaaaaaaaaaaaaaaaaaaaab&quot;，B=&quot;aaaaaaaab&quot;。我们将介绍的是一种最坏情况下O(n)的算法（这里假设 m&amp;lt;=n），即传说中的KMP算法。
之所以叫做KMP，是因为这个算法是由Knuth、Morris、Pratt三个提出来的，取了这三个人的名字的头一个字母。这时，或许你突然明白了AVL 树为什么叫AVL，或者Bellman-Ford为什么中间是一杠不是一个点。有时一个东西有七八个人研究过，那怎么命名呢？通常这个东西干脆就不用人名字命名了，免得发生争议，比如“3x+1问题”。扯远了。
个人认为KMP是最没有必要讲的东西，因为这个东西网上能找到很多资料。但网上的讲法基本上都涉及到“移动(shift)”、“Next函数”等概念，这非常容易产生误解（至少一年半前我看这些资料学习KMP时就没搞清楚）。在这里，我换一种方法来解释KMP算法。&lt;/p&gt;

&lt;p&gt;假如，A=&quot;abababaababacb&quot;，B=&quot;ababacb&quot;，我们来看看KMP是怎么工作的。我们用两个指针i和j分别表示，A[i-j+ 1..i]与B[1..j]完全相等。也就是说，i是不断增加的，随着i的增加j相应地变化，且j满足以A[i]结尾的长度为j的字符串正好匹配B串的前 j个字符（j当然越大越好），现在需要检验A[i+1]和B[j+1]的关系。当A[i+1]=B[j+1]时，i和j各加一；什么时候j=m了，我们就说B是A的子串（B串已经整完了），并且可以根据这时的i值算出匹配的位置。当A[i+1]&amp;lt;&amp;gt;B[j+1]，KMP的策略是调整j的位置（减小j值）使得A[i-j+1..i]与B[1..j]保持匹配且新的B[j+1]恰好与A[i+1]匹配（从而使得i和j能继续增加）。我们看一看当 i=j=5时的情况。&lt;/p&gt;

&lt;p&gt;i = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B = a b a b a c b
j =  1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;此时，A[6]&amp;lt;&amp;gt;B[6]。这表明，此时j不能等于5了，我们要把j改成比它小的值j'。j'可能是多少呢？仔细想一下，我们发现，j'必须要使得B[1..j]中的头j'个字母和末j'个字母完全相等（这样j变成了j'后才能继续保持i和j的性质）。这个j'当然要越大越好。在这里，B [1..5]=&quot;ababa&quot;，头3个字母和末3个字母都是&quot;aba&quot;。而当新的j为3时，A[6]恰好和B[4]相等。于是，i变成了6，而j则变成了 4：&lt;/p&gt;

&lt;p&gt;i  = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B =  a b a b a c b
j =  1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;从上面的这个例子，我们可以看到，新的j可以取多少与i无关，只与B串有关。我们完全可以预处理出这样一个数组P[j]，表示当匹配到B数组的第j个字母而第j+1个字母不能匹配了时，新的j最大是多少。P[j]应该是所有满足B[1..P[j]]=B[j-P[j]+1..j]的最大值。
再后来，A[7]=B[5]，i和j又各增加1。这时，又出现了A[i+1]&amp;lt;&amp;gt;B[j+1]的情况：&lt;/p&gt;

&lt;p&gt;i  = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B =       a b a b a c b
j =        1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;由于P[5]=3，因此新的j=3：&lt;/p&gt;

&lt;p&gt;i  = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B =             a b a b a c b
j =              1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;这时，新的j=3仍然不能满足A[i+1]=B[j+1]，此时我们再次减小j值，将j再次更新为P[3]：&lt;/p&gt;

&lt;p&gt;i = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B =                   a b a b a c b
j =                   1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;现在，i还是7，j已经变成1了。而此时A[8]居然仍然不等于B[j+1]。这样，j必须减小到P[1]，即0：&lt;/p&gt;

&lt;p&gt;i = 1 2 3 4 5 6 7 8 9 ……
A = a b a b a b a a b a b …
B =                     a b a b a c b
j =                   0 1 2 3 4 5 6 7&lt;/p&gt;

&lt;p&gt;终于，A[8]=B[1]，i变为8，j为1。事实上，有可能j到了0仍然不能满足A[i+1]=B[j+1]（比如A[8]=&quot;d&quot;时）。因此，准确的说法是，当j=0了时，我们增加i值但忽略j直到出现A[i]=B[1]为止。
这个过程的代码很短（真的很短），我们在这里给出：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;程序代码&lt;/div&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;j:=0;
for i:=1 to n do
begin
   while (j&amp;gt;0) and (B[j+1]&amp;lt;&amp;gt;A[i]) do j:=P[j];
   if B[j+1]=A[i] then j:=j+1;
   if j=m then
   begin
       writeln('Pattern occurs with shift ',i-m);
       j:=P[j];
   end;
end;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;最后的j:=P[j]是为了让程序继续做下去，因为我们有可能找到多处匹配。
这个程序或许比想像中的要简单，因为对于i值的不断增加，代码用的是for循环。因此，这个代码可以这样形象地理解：扫描字符串A，并更新可以匹配到B的什么位置。&lt;/p&gt;

&lt;p&gt;现在，我们还遗留了两个重要的问题：一，为什么这个程序是线性的；二，如何快速预处理P数组。
为什么这个程序是O(n)的？其实，主要的争议在于，while循环使得执行次数出现了不确定因素。我们将用到时间复杂度的摊还分析中的主要策略，简单地说就是通过观察某一个变量或函数值的变化来对零散的、杂乱的、不规则的执行次数进行累计。KMP的时间复杂度分析可谓摊还分析的典型。我们从上述程序的j 值入手。每一次执行while循环都会使j减小（但不能减成负的），而另外的改变j值的地方只有第五行。每次执行了这一行，j都只能加1；因此，整个过程中j最多加了n个1。于是，j最多只有n次减小的机会（j值减小的次数当然不能超过n，因为j永远是非负整数）。这告诉我们，while循环总共最多执行了n次。按照摊还分析的说法，平摊到每次for循环中后，一次for循环的复杂度为O(1)。整个过程显然是O(n)的。这样的分析对于后面P数组预处理的过程同样有效，同样可以得到预处理过程的复杂度为O(m)。
预处理不需要按照P的定义写成O(m&lt;sup&gt;2)甚至O(m&lt;sup&gt;3)的。我们可以通过P[1],P[2],...,P[j-1]的值来获得P[j]的值。对于刚才的B=&quot;ababacb&quot;，假如我们已经求出了P[1],P[2],P[3]和P[4]，看看我们应该怎么求出P[5]和P[6]。P[4]=2，那么P&lt;/sup&gt;&lt;/sup&gt; [5]显然等于P[4]+1，因为由P[4]可以知道，B[1,2]已经和B[3,4]相等了，现在又有B[3]=B[5]，所以P[5]可以由P[4] 后面加一个字符得到。P[6]也等于P[5]+1吗？显然不是，因为B[ P[5]+1 ]&amp;lt;&amp;gt;B[6]。那么，我们要考虑“退一步”了。我们考虑P[6]是否有可能由P[5]的情况所包含的子串得到，即是否P[6]=P[ P[5] ]+1。这里想不通的话可以仔细看一下：&lt;/p&gt;

&lt;p&gt;1 2 3 4 5 6 7
B = a b a b a c b
P = 0 0 1 2 3 ?&lt;/p&gt;

&lt;p&gt;P[5]=3是因为B[1..3]和B[3..5]都是&quot;aba&quot;；而P[3]=1则告诉我们，B[1]和B[5]都是&quot;a&quot;。既然P[6]不能由P [5]得到，或许可以由P[3]得到（如果B[2]恰好和B[6]相等的话，P[6]就等于P[3]+1了）。显然，P[6]也不能通过P[3]得到，因为B[2]&amp;lt;&amp;gt;B[6]。事实上，这样一直推到P[1]也不行，最后，我们得到，P[6]=0。
怎么这个预处理过程跟前面的KMP主程序这么像呢？其实，KMP的预处理本身就是一个B串“自我匹配”的过程。它的代码和上面的代码神似：&lt;/p&gt;

&lt;div&gt;
&lt;div&gt;程序代码&lt;/div&gt;
&lt;div&gt;
&lt;pre&gt;&lt;code&gt;P[1]:=0;
j:=0;
for i:=2 to m do
begin
   while (j&amp;gt;0) and (B[j+1]&amp;lt;&amp;gt;B[i]) do j:=P[j];
   if B[j+1]=B[i] then j:=j+1;
   P[i]:=j;
end;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;最后补充一点：由于KMP算法只预处理B串，因此这种算法很适合这样的问题：给定一个B串和一群不同的A串，问B是哪些A串的子串。&lt;/p&gt;

&lt;p&gt;串匹配是一个很有研究价值的问题。事实上，我们还有后缀树，自动机等很多方法，这些算法都巧妙地运用了预处理，从而可以在线性的时间里解决字符串的匹配。我们以后来说。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java多线程总结</title>
   <link href="http://dreambt.github.com/Java/2011/10/18/java-multi-threaded"/>
   <updated>2011-10-18T13:20:03+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/10/18/java-multi-threaded</id>
   <content type="html">&lt;p&gt;首先要理解线程首先需要了解一些基本的东西，我们现在所使用的大多数操作系统都属于多任务，分时操作系统。正是由于这种操作系统的出现才有了多线程这个概念。我们使用的windows,linux就属于此列。什么是分时操作系统呢，通俗一点与就是可以同一时间执行多个程序的操作系统，在自己的电脑上面，你是不是一边听歌，一边聊天还一边看网页呢？但实际上，并不上cpu在同时执行这些程序，cpu只是将时间切割为时间片，然后将时间片分配给这些程序，获得时间片的程序开始执行，不等执行完毕，下个程序又获得时间片开始执行，这样多个程序轮流执行一段时间，由于现在cpu的高速计算能力，给人的感觉就像是多个程序在同时执行一样。
一般可以在同一时间内执行多个程序的操作系统都有进程的概念.一个进程就是一个执行中的程序,而每一个进程都有自己独立的一块内存空间,一组系统资源.在进程概念中,每一个进程的内部数据和状态都是完全独立的.因此可以想像创建并执行一个进程的系统开像是比较大的，所以线程出现了。在java中，程序通过流控制来执行程序流,程序中单个顺序的流控制称为线程,多线程则指的是在单个程序中可以同时运行多个不同的线程,执行不同的任务.多线程意味着一个程序的多行语句可以看上去几乎在同一时间内同时运行.（你可以将前面一句话的程序换成进程，进程是程序的一次执行过程,是系统运行程序的基本单位）&lt;/p&gt;

&lt;p&gt;线程与进程相似,是一段完成某个特定功能的代码,是程序中单个顺序的流控制;但与进程不同的是,同类的多个线程是共享一块内存空间和一组系统资源,而线程本身的数据通常只有微处理器的寄存器数据,以及一个供程序执行时使用的堆栈.所以系统在产生一个线程,或者在各个线程之间切换时,负担要比进程小的多,正因如此,线程也被称为轻负荷进程(light-weight process).一个进程中可以包含多个线程.&lt;/p&gt;

&lt;p&gt;多任务是指在一个系统中可以同时运行多个程序,即有多个独立运行的任务,每个任务对应一个进程，同进程一样,一个线程也有从创建,运行到消亡的过程,称为线程的生命周期.用线程的状态(state)表明线程处在生命周期的哪个阶段.线程有创建,可运行,运行中,阻塞,死亡五中状态.通过线程的控制与调度可使线程在这几种状态间转化每个程序至少自动拥有一个线程,称为主线程.当程序加载到内存时,启动主线程.&lt;/p&gt;

&lt;p&gt;[线程的运行机制以及调度模型]
java中多线程就是一个类或一个程序执行或管理多个线程执行任务的能力，每个线程可以独立于其他线程而独立运行，当然也可以和其他线程协同运行，一个类控制着它的所有线程，可以决定哪个线程得到优先级，哪个线程可以访问其他类的资源，哪个线程开始执行，哪个保持休眠状态。
下面是线程的机制图：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/10/20060404144316962.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1023&quot; title=&quot;20060404144316962&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/10/20060404144316962.jpg&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;300&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;线程的状态表示线程正在进行的活动以及在此时间段内所能完成的任务.线程有创建,可运行,运行中,阻塞,死亡五中状态.一个具有生命的线程,总是处于这五种状态之一：
&lt;strong&gt;1.创建状态&lt;/strong&gt;
使用new运算符创建一个线程后,该线程仅仅是一个空对象,系统没有分配资源,称该线程处于创建状态(new thread)
&lt;strong&gt;2.可运行状态&lt;/strong&gt;
使用start()方法启动一个线程后,系统为该线程分配了除CPU外的所需资源,使该线程处于可运行状态(Runnable)
&lt;strong&gt;3.运行中状态&lt;/strong&gt;
Java运行系统通过调度选中一个Runnable的线程,使其占有CPU并转为运行中状态(Running).此时,系统真正执行线程的run()方法.
&lt;strong&gt;4.阻塞状态&lt;/strong&gt;
一个正在运行的线程因某种原因不能继续运行时,进入阻塞状态(Blocked)
&lt;strong&gt;5.死亡状态&lt;/strong&gt;
线程结束后是死亡状态(Dead)&lt;/p&gt;

&lt;p&gt;同一时刻如果有多个线程处于可运行状态,则他们需要排队等待CPU资源.此时每个线程自动获得一个线程的优先级(priority),优先级的高低反映线程的重要或紧急程度.可运行状态的线程按优先级排队,线程调度依据优先级基础上的&quot;先到先服务&quot;原则.
线程调度管理器负责线程排队和CPU在线程间的分配,并由线程调度算法进行调度.当线程调度管理器选种某个线程时,该线程获得CPU资源而进入运行状态.&lt;/p&gt;

&lt;p&gt;线程调度是先占式调度,即如果在当前线程执行过程中一个更高优先级的线程进入可运行状态,则这个线程立即被调度执行.先占式调度分为:独占式和分时方式.
独占方式下,当前执行线程将一直执行下去,直 到执行完毕或由于某种原因主动放弃CPU,或CPU被一个更高优先级的线程抢占
分时方式下,当前运行线程获得一个时间片,时间到时,即使没有执行完也要让出CPU,进入可运行状态,等待下一个时间片的调度.系统选中其他可运行状态的线程执行
分时方式的系统使每个线程工作若干步,实现多线程同时运行&lt;/p&gt;

&lt;p&gt;另外请注意下面的线程调度规则（如果有不理解，不急，往下看）：
①如果两个或是两个以上的线程都修改一个对象，那么把执行修改的方法定义为被同步的（Synchronized）,如果对象更新影响到只读方法，那么只度方法也应该定义为同步的
②如果一个线程必须等待一个对象状态发生变化，那么它应该在对象内部等待，而不是在外部等待，它可以调用一个被同步的方法，并让这个方法调用wait()
③每当一个方法改变某个对象的状态的时候，它应该调用notifyAll()方法，这给等待队列的线程提供机会来看一看执行环境是否已发生改变
④记住wait(),notify(),notifyAll()方法属于Object类，而不是Thread类，仔细检查看是否每次执行wait()方法都有相应的notify()或notifyAll()方法，且它们作用与相同的对象 在java中每个类都有一个主线程，要执行一个程序，那么这个类当中一定要有main方法，这个man方法也就是java class中的主线程。你可以自己创建线程，有两种方法，一是继承Thread类，或是实现Runnable接口。一般情况下，最好避免继承，因为java中是单根继承，如果你选用继承，那么你的类就失去了弹性，当然也不能全然否定继承Thread,该方法编写简单,可以直接操作线程,适用于单重继承情况。至于选用那一种，具体情况具体分析。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eg.继承Thread&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;public class MyThread_1 extends Thread
{
public void run()
{
//some code
}
}&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;eg.实现Runnable接口&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;public class MyThread_2 implements Runnable
{
public void run()
{
//some code
}
}&lt;/pre&gt;


&lt;p&gt;当使用继承创建线程，这样启动线程：&lt;/p&gt;

&lt;pre&gt;new MyThread_1().start()&lt;/pre&gt;


&lt;p&gt;当使用实现接口创建线程，这样启动线程：&lt;/p&gt;

&lt;pre&gt;new Thread(new MyThread_2()).start()&lt;/pre&gt;


&lt;p&gt;注意，其实是创建一个线程实例，并以实现了Runnable接口的类为参数传入这个实例，当执行这个线程的时候，MyThread_2中run里面的代码将被执行。
下面是完成的例子：&lt;/p&gt;

&lt;pre&gt;public class MyThread implements Runnable
{ 

public void run()
{
System.out.println(&quot;My Name is &quot;+Thread.currentThread().getName());
}
public static void main(String[] args)
{
new Thread(new MyThread()).start();
}
}&lt;/pre&gt;


&lt;p&gt;执行后将打印出：
My Name is Thread-0&lt;/p&gt;

&lt;p&gt;你也可以创建多个线程，像下面这样&lt;/p&gt;

&lt;pre&gt;new Thread(new MyThread()).start();
new Thread(new MyThread()).start();
new Thread(new MyThread()).start();&lt;/pre&gt;


&lt;p&gt;那么会打印出：
My Name is Thread-0
My Name is Thread-1
My Name is Thread-2&lt;/p&gt;

&lt;p&gt;看了上面的结果，你可能会认为线程的执行顺序是依次执行的，但是那只是一般情况，千万不要用以为是线程的执行机制；影响线程执行顺序的因素有几点：首先看看前面提到的优先级别&lt;/p&gt;

&lt;pre&gt;public class MyThread implements Runnable
{ 

public void run()
{
System.out.println(&quot;My Name is &quot;+Thread.currentThread().getName());
}
public static void main(String[] args)
{
Thread t1=new Thread(new MyThread());
Thread t2=new Thread(new MyThread());
Thread t3=new Thread(new MyThread());
t2.setPriority(Thread.MAX_PRIORITY);//赋予最高优先级
t1.start();
t2.start();
t3.start();
}
}&lt;/pre&gt;


&lt;p&gt;再看看结果：
My Name is Thread-1
My Name is Thread-0
My Name is Thread-2&lt;/p&gt;

&lt;p&gt;线程的优先级分为10级，分别用1到10的整数代表，默认情况是5。上面的t2.setPriority(Thread.MAX_PRIORITY)等价与t2.setPriority(10）
然后是线程程序本身的设计，比如使用sleep,yield,join，wait等方法（详情请看JDKDocument)&lt;/p&gt;

&lt;pre&gt;public class MyThread implements Runnable
{
public void run()
{
try
{
int sleepTime=(int)(Math.random()*100);//产生随机数字，
Thread.currentThread().sleep(sleepTime);//让其休眠一定时间，时间又上面sleepTime决定
//public static void sleep(long millis)throw InterruptedException （API）
System.out.println(Thread.currentThread().getName()+&quot; 睡了 &quot;+sleepTime);
}catch(InterruptedException ie)//由于线程在休眠可能被中断，所以调用sleep方法的时候需要捕捉异常
{
ie.printStackTrace();
}
}
public static void main(String[] args)
{
Thread t1=new Thread(new MyThread());
Thread t2=new Thread(new MyThread());
Thread t3=new Thread(new MyThread());
t1.start();
t2.start();
t3.start();
}
}&lt;/pre&gt;


&lt;p&gt;执行后观察其输出：&lt;/p&gt;

&lt;p&gt;Thread-0 睡了 11
Thread-2 睡了 48
Thread-1 睡了 69&lt;/p&gt;

&lt;p&gt;上面的执行结果是随机的，再执行很可能出现不同的结果。由于上面我在run中添加了休眠语句，当线程休眠的时候就会让出cpu，cpu将会选择执行处于runnable状态中的其他线程，当然也可能出现这种情况，休眠的Thread立即进入了runnable状态，cpu再次执行它。
[线程组概念]
线程是可以被组织的，java中存在线程组的概念，每个线程都是一个线程组的成员,线程组把多个线程集成为一个对象,通过线程组可以同时对其中的多个线程进行操作,如启动一个线程组的所有线程等.Java的线程组由java.lang包中的Thread——Group类实现.
ThreadGroup类用来管理一组线程,包括:线程的数目,线程间的关系,线程正在执行的操作,以及线程将要启动或终止时间等.线程组还可以包含线程组.在Java的应用程序中,最高层的线程组是名位main的线程组,在main中还可以加入线程或线程组,在mian的子线程组中也可以加入线程和线程组,形成线程组和线程之间的树状继承关系。像上面创建的线程都是属于main这个线程组的。
借用上面的例子，main里面可以这样写：&lt;/p&gt;

&lt;pre&gt;public static void main(String[] args)
{
/***************************************
ThreadGroup(String name)
ThreadGroup(ThreadGroup parent, String name)
***********************************/
ThreadGroup group1=new ThreadGroup(&quot;group1&quot;);
ThreadGroup group2=new ThreadGroup(group1,&quot;group2&quot;);
Thread t1=new Thread(group2,new MyThread());
Thread t2=new Thread(group2,new MyThread());
Thread t3=new Thread(group2,new MyThread());
t1.start();
t2.start();
t3.start();
}&lt;/pre&gt;


&lt;p&gt;线程组的嵌套，t1,t2,t3被加入group2,group2加入group1。
另外一个比较多就是关于线程同步方面的，试想这样一种情况，你有一笔存款在银行，你在一家银行为你的账户存款，而你的妻子在另一家银行从这个账户提款，现在你有1000块在你的账户里面。你存入了1000，但是由于另一方也在对这笔存款进行操作，人家开始执行的时候只看到账户里面原来的1000元，当你的妻子提款1000元后，你妻子所在的银行就认为你的账户里面没有钱了，而你所在的银行却认为你还有2000元。
看看下面的例子：&lt;/p&gt;

&lt;pre&gt;class BlankSaving //储蓄账户
{
private static int money=10000;
public void add(int i)
{
money=money+i;
System.out.println(&quot;Husband 向银行存入了 [￥&quot;+i+&quot;]&quot;);
}
public void get(int i)
{
money=money-i;
System.out.println(&quot;Wife 向银行取走了 [￥&quot;+i+&quot;]&quot;);
if(money&amp;lt;0)
System.out.println(&quot;余额不足！&quot;);
}
public int showMoney()
{
return money;
}
} 

class Operater implements Runnable
{
String name;
BlankSaving bs;
public Operater(BlankSaving b,String s)
{
name=s;
bs=b;

}
public static void oper(String name,BlankSaving bs)
{

if(name.equals(&quot;husband&quot;))
{
try
{
for(int i=0;i&amp;lt;10;i++)
{
Thread.currentThread().sleep((int)(Math.random()*300));
bs.add(1000);
}
}catch(InterruptedException e){}
}else
{
try
{

for(int i=0;i&amp;lt;10;i++)
{
Thread.currentThread().sleep((int)(Math.random()*300));
bs.get(1000);
}
}catch(InterruptedException e){}
}
}
public void run()
{
oper(name,bs);
}
}
public class BankTest
{
public static void main(String[] args)throws InterruptedException
{
BlankSaving bs=new BlankSaving();
Operater o1=new Operater(bs,&quot;husband&quot;);
Operater o2=new Operater(bs,&quot;wife&quot;);
Thread t1=new Thread(o1);
Thread t2=new Thread(o2);
t1.start();
t2.start();
Thread.currentThread().sleep(500);
}

}&lt;/pre&gt;


&lt;p&gt;下面是其中一次的执行结果：&lt;/p&gt;

&lt;p&gt;---------first--------------
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Husband 向银行存入了 [￥1000]&lt;/p&gt;

&lt;p&gt;看到了吗，这可不是正确的需求，在husband还没有结束操作的时候，wife就插了进来，这样很可能导致意外的结果。解决办法很简单，就是将对数据进行操作方法声明为synchronized,当方法被该关键字声明后，也就意味着，如果这个数据被加锁，只有一个对象得到这个数据的锁的时候该对象才能对这个数据进行操作。也就是当你存款的时候，这笔账户在其他地方是不能进行操作的，只有你存款完毕，银行管理人员将账户解锁，其他人才能对这个账户进行操作。
修改public static void oper(String name,BlankSaving bs)为public static void oper(String name,BlankSaving bs)，再看看结果:&lt;/p&gt;

&lt;p&gt;Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Husband 向银行存入了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]
Wife 向银行取走了 [￥1000]&lt;/p&gt;

&lt;p&gt;当丈夫完成操作后，妻子才开始执行操作，这样的话，对共享对象的操作就不会有问题了。
[wait and notify]
你可以利用这两个方法很好的控制线程的执行流程，当线程调用wait方法后，线程将被挂起，直到被另一线程唤醒（notify）或则是如果wait方法指定有时间得话，在没有被唤醒的情况下，指定时间时间过后也将自动被唤醒。但是要注意一定，被唤醒并不是指马上执行，而是从组塞状态变为可运行状态，其是否运行还要看cpu的调度。
事例代码：&lt;/p&gt;

&lt;pre&gt;class MyThread_1 extends Thread
{
Object lock;
public MyThread_1(Object o)
{
lock=o;
}
public void run()
{
try
{
synchronized(lock)
{
System.out.println(&quot;Enter Thread_1 and wait&quot;);
lock.wait();
System.out.println(&quot;be notified&quot;);
}
}catch(InterruptedException e){}
}
}
class MyThread_2 extends Thread
{
Object lock;
public MyThread_2(Object o)
{
lock=o;
}
public void run()
{
synchronized(lock)
{
System.out.println(&quot;Enter Thread_2 and notify&quot;);
lock.notify();
}
}
}
public class MyThread
{
public static void main(String[] args)
{
int[] in=new int[0];//notice
MyThread_1 t1=new MyThread_1(in);
MyThread_2 t2=new MyThread_2(in);
t1.start();
t2.start();
}
}&lt;/pre&gt;


&lt;p&gt;执行结果如下：
Enter Thread_1 and wait
Enter Thread_2 and notify
Thread_1 be notified&lt;/p&gt;

&lt;p&gt;可能你注意到了在使用wait and notify方法得时候我使用了synchronized块来包装这两个方法，这是由于调用这两个方法的时候线程必须获得锁，也就是上面代码中的lock[]，如果你不用synchronized包装这两个方法的得话，又或则锁不一是同一把，比如在MyThread_2中synchronized(lock)改为synchronized(this),那么执行这个程序的时候将会抛出java.lang.IllegalMonitorStateException执行期异常。另外wait and notify方法是Object中的，并不在Thread这个类中。最后你可能注意到了这点：int[] in=new int[0];为什么不是创建new Object而是一个0长度的数组，那是因为在java中创建一个0长度的数组来充当锁更加高效。&lt;/p&gt;

&lt;p&gt;Thread作为java中一重要组成部分，当然还有很多地方需要更深刻的认识，上面只是对Thread的一些常识和易错问题做了一个简要的总结，若要真正的掌握java的线程，还需要自己多做总结&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu常用的终端命令</title>
   <link href="http://dreambt.github.com/Linux/2011/10/16/ubuntu-terminal"/>
   <updated>2011-10-16T12:12:47+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/10/16/ubuntu-terminal</id>
   <content type="html">&lt;p&gt;一、文件目录类&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.建立目录：mkdir 目录名&lt;/li&gt;
    &lt;li&gt;2.删除空目录：rmdir 目录名&lt;/li&gt;
    &lt;li&gt;3.无条件删除子目录： rm -rf 目录名&lt;/li&gt;
    &lt;li&gt;4.改变当前目录：cd 目录名 （进入用户home目录：cd ~；进入上一级目录：cd -）&lt;/li&gt;
    &lt;li&gt;5.查看自己所在目录：pwd&lt;/li&gt;
    &lt;li&gt;6.查看当前目录大小：du&lt;/li&gt;
    &lt;li&gt;7.显示目录文件列表：ls -l （-a：增加显示隐含目录）&lt;/li&gt;
    &lt;li&gt;其中：蓝：目录；绿：可执行文件；红：压缩文件；浅蓝：链接文件；灰：其他文件；红底白字：错误的链接文件&lt;/li&gt;
    &lt;li&gt;8.浏览文件：more 文件名.txt；less 文件名.txt&lt;/li&gt;
    &lt;li&gt;9.复制文件： cp 源文件 目标文件 （-r：包含目录）&lt;/li&gt;
    &lt;li&gt;10.查找文件：（1）find （2）locate 命令名&lt;/li&gt;
    &lt;li&gt;11.链接：（1）建立hard链接：ln 来源文件 链接文件（-d：创建目录链接）；（2）建立符号链接：ln -s 来源文件 链接文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;二、驱动挂载类&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.检查硬盘使用情况：df -T -h&lt;/li&gt;
    &lt;li&gt;2.检查磁盘分区：fdisk -l&lt;/li&gt;
    &lt;li&gt;3.挂载软硬光区：mount -t /dev/fdx|hdax /mnt/目录名，其中：modos–FAT16；vfat–FAT32；ntfs–NTFS；光驱–iso9660，支持中文名：mount -o iocharset=x /dev/hdax /mnt/目录名，挂载光驱：mount -t auto /dev/cdrom /mnt/cdrom，挂载ISO文件：mount -t iso9660 -o loop xxx.iso /path&lt;/li&gt;
    &lt;li&gt;4.解除挂载：umount /mnt/目录名，解除所有挂载：umount -a&lt;/li&gt;
    &lt;li&gt;5.建立文件系统：mkfs -t /dev/hdxx。其中：ftype：ext2、ext3、swap等&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;三、程序安装类&lt;/p&gt;

&lt;p&gt;1.RPM包安装：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;（1）安装 rpm -ivh somesoft.rpm&lt;/li&gt;
    &lt;li&gt;（2）反安装 rpm -e somefost.rpm&lt;/li&gt;
    &lt;li&gt;（3）查询 rpm -q somefost 或 rpm -qpi somefost.rpm（其中：p未安装；i包含的信息）&lt;/li&gt;
    &lt;li&gt;（4）查询安装后位置：rpm -ql somefost.rpm&lt;/li&gt;
    &lt;li&gt;（5）升级安装：rpm -Uvh somesoft.rpm&lt;/li&gt;
    &lt;li&gt;（6）强制安装：rpm -ivh –nodeps somesoft.rpm 或 rpm -ivh –nodeps –force somesoft.rpm&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;2.源代码包安装：&lt;/p&gt;

&lt;p&gt;查阅README&lt;/p&gt;

&lt;p&gt;基本用法 ：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;（1）配置：解压目录下 ./configure&lt;/li&gt;
    &lt;li&gt;（2）编译：解压目录下 make&lt;/li&gt;
    &lt;li&gt;（3）安装：解压目录下 make install&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3.src.rpm的安装&lt;/p&gt;

&lt;p&gt;需要用到rpmbuild命令加上–rebuild参数。如 rpmbuild –rebuild ***.src.rpm。然后在/usr/src/下找&lt;/p&gt;

&lt;p&gt;FC3下iso程序安装：system-config-packages –isodir=iso所在目录&lt;/p&gt;

&lt;p&gt;RH下iso程序安装：redhat-config-packages –isodir=iso所在目录&lt;/p&gt;

&lt;p&gt;四、压缩解压类&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.tar.gz类：（1）解压：tar -xvzf 文件.tar.gz；（2）tar.gz解至tar：gzip -d 文件.tar.gz（2）压缩：gzip 待压缩文件&lt;/li&gt;
    &lt;li&gt;2.tar未压缩类：（1）解包：tar -xvf 文件.tar；（2）打包：tar -cvf 文件.tar 文件列表&lt;/li&gt;
    &lt;li&gt;3.zip类：（1）解压：unzip 文件.zip -d dir；（2）压缩：zip zipfile 待压缩文件列表&lt;/li&gt;
    &lt;li&gt;4.bz2类：（1）解压：bunzip2 文件.bz2或bzip2 -d 文件.bz2；（2）压缩：bzip2 待压缩文件&lt;/li&gt;
    &lt;li&gt;5.z类：（1）解压：uncompress 文件.z；（2）压缩：compress 文件&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;五、进程控制类&lt;/p&gt;

&lt;p&gt;1.列出当前进程ID：ps -auxw&lt;/p&gt;

&lt;p&gt;2.终止进程：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;（1）终止单一进程：kill 进程ID号&lt;/li&gt;
    &lt;li&gt;（2）终止该程序所有进程：Killall 程序名&lt;/li&gt;
    &lt;li&gt;（3）终止X-Window程序：xkill&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;3.查看资源占用情况：（1）top （2）free （3）dmesg&lt;/p&gt;

&lt;p&gt;4.查看环境变量值：env&lt;/p&gt;

&lt;p&gt;5.重启：（1）reboot （2）Ctrl Alt Del （3）init 6&lt;/p&gt;

&lt;p&gt;6.关机：（1）shutdown -h now （2）halt （3）init 0&lt;/p&gt;

&lt;p&gt;7.切换桌面：switchdesk gnome|KDE|…&lt;/p&gt;

&lt;p&gt;六、程序运行类&lt;/p&gt;

&lt;p&gt;1.查询命令：whereis 命令名&lt;/p&gt;

&lt;p&gt;2.后台运行X-Window程序：程序名&amp;amp;&lt;/p&gt;

&lt;p&gt;3.强行退出X-Window程序：Ctrl Alt Backspace&lt;/p&gt;

&lt;p&gt;4.查看帮助：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;（1）简明帮助：命令名 –help | less&lt;/li&gt;
    &lt;li&gt;（2）更多帮助：man 命令名&lt;/li&gt;
    &lt;li&gt;（3）info 命令名&lt;/li&gt;
    &lt;li&gt;（4）help 命令名&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;5.查看系统路径：echo $PATH&lt;/p&gt;

&lt;p&gt;6.查看当前shell堆栈：echo $SHLVL&lt;/p&gt;

&lt;p&gt;7.&amp;lt; / &amp;gt;：输入/输出重定向；|：管道左的输入是管道右输入&lt;/p&gt;

&lt;p&gt;七、用户帐号类&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.增加用户帐号：（1）用 户 名：adduser 用户帐号名（2）设置密码： passwd 用户帐号名&lt;/li&gt;
    &lt;li&gt;2.删除用户帐号：userdel 用户帐号名&lt;/li&gt;
    &lt;li&gt;3.增加用户组：groupadd 用户组名&lt;/li&gt;
    &lt;li&gt;4.删除用户组：groupdel 用户组名&lt;/li&gt;
    &lt;li&gt;5.暂时终止用户帐号：passwd -l 用户帐号名&lt;/li&gt;
    &lt;li&gt;6.恢复被终止帐号：passwd -u 用户帐号名&lt;/li&gt;
    &lt;li&gt;7.权限设定&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;（1）chmod -a|u|g|o |-|=r|w|x 文件/目录名&lt;/p&gt;

&lt;p&gt;其中：a–所有用户（all）；u–本用户（user）；g–用户组（group）；o–其他用户（other users）&lt;/p&gt;

&lt;p&gt;–增加权限；—删除权限；=–设置权限&lt;/p&gt;

&lt;p&gt;文件：r–只读权限（read）；w–写权限（write）；x–执行权限（execute）&lt;/p&gt;

&lt;p&gt;目录：r–允许列目录下文件和子目录；w–允许生成和删除目录下文件；x–允许访问该目录&lt;/p&gt;

&lt;p&gt;（2）chmod xxx 文件/目录名&lt;/p&gt;

&lt;p&gt;其中：execute=1；write=2；read=4&lt;/p&gt;

&lt;p&gt;x取值：0–没有任何权限（常用）；1–只能执行（不常见）；2–只能写（不常见）；3–只能写和执行（不常见）；4–只读（常见）；5–只读和执行（常见）；6–读和写（常见）；7–读.写和执行&lt;/p&gt;

&lt;p&gt;八、vi编辑类&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.进入后为命令模式：（1）插入i；（2）打开0；（3）修改c；（4）取代r；（5）替换s&lt;/li&gt;
    &lt;li&gt;2.经（1）后进入全屏幕编辑模式。&lt;/li&gt;
    &lt;li&gt;3.命令模式–&amp;gt;编辑模式（a/i）；编辑模式–&amp;gt;命令模式（Esc）；命令模式–&amp;gt;末行模式（：）。&lt;/li&gt;
    &lt;li&gt;4.：w/w newfile保存&lt;/li&gt;
    &lt;li&gt;5.：q/q！退出iv；：wq保存退出&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;九、网络服务&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;1.显示网络接口参数：ifconfig&lt;/li&gt;
    &lt;li&gt;2.显示系统邮件：mail&lt;/li&gt;
    &lt;li&gt;3.启动/终止web服务：httpd -k start|stop|restart&lt;/li&gt;
    &lt;li&gt;4.查看网络状况：（1）联机状况：ping xxx.xxx.xxx.xxx；（2）显示网络状况：netstat ，其中：options：-a==所有sockets；-l==包含网络设备；-n==数字IP；-o==其他信息；-r==路由表；-t==只列TCP sockets；-u==只列UDP sockets；-w==只列raw sockets；-x==只列Unix Domain sockets&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;十、其他类&lt;/p&gt;

&lt;p&gt;1.显示显卡3D信息：glxinfo和glxgears&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby中常用的全局变量</title>
   <link href="http://dreambt.github.com/Ruby/2011/10/12/ruby-commonly-used-global-variables"/>
   <updated>2011-10-12T19:10:47+08:00</updated>
   <id>http://dreambt.github.com/Ruby/2011/10/12/ruby-commonly-used-global-variables</id>
   <content type="html">&lt;pre&gt;$! #最近一次的错误信息
$@ #错误产生的位置
$_ #gets最近读的字符串
$. #解释器最近读的行数(line number)
$&amp;amp; #最近一次与正则表达式匹配的字符串
$~ #作为子表达式组的最近一次匹配
$n #最近匹配的第n个子表达式(和$~[n]一样)
$= #是否区别大小写的标志
$/ #输入记录分隔符
$\ #输出记录分隔符
$0 #Ruby脚本的文件名
$* #命令行参数
$$ #解释器进程ID
$? #最近一次执行的子进程退出状态&lt;/pre&gt;

</content>
 </entry>
 
 <entry>
   <title>Struts2 ognl中的#、%和$符号用法说明</title>
   <link href="http://dreambt.github.com/J2EE/2011/10/08/struts2-ognl-symbol"/>
   <updated>2011-10-08T16:08:43+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2011/10/08/struts2-ognl-symbol</id>
   <content type="html">&lt;h1&gt;、%和$符号在OGNL表达式中经常出现，而这三种符号也是开发者不容易掌握和理解的部分。&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;1．#符号的&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用途一般有三种。
1)访问非根对象属性，例如示例中的#session.msg表达式，由于Struts 2中值栈被视为根对象，所以访问其他非根对象时，需要加#前缀。实际上，#相当于ActionContext. getContext()；#session.msg表达式相当于ActionContext.getContext().getSession(). getAttribute(”msg”) 。
2)用于过滤和投影（projecting）集合，如示例中的persons.{?#this.age&amp;gt;20}。
3)用来构造Map，例如示例中的#{'foo1':'bar1','foo2':'bar2'}。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2．%符号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;%符号的用途是在标志的属性为字符串类型时，计算OGNL表达式的值。如下面的代码所示：
构造Map
&amp;lt;s:set name=&quot;foobar&quot; value=&quot;#{'foo1':'bar','foo2':'bar2'}&quot; /&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;p&amp;gt;The value of key &quot;foo1&quot; is &amp;lt;s:property value=&quot;#foobar['foo1']&quot; /&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;p&amp;gt;不使用％：&amp;lt;s:url value=&quot;#foobar['foo1']&quot; /&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;p&amp;gt;使用％：&amp;lt;s:url value=&quot;%{#foobar['foo1']}&quot; /&amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3．$符号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;$符号主要有两个方面的用途。&lt;/p&gt;

&lt;p&gt;在国际化资源文件中，引用OGNL表达式，例如国际化资源文件中的代码：reg.agerange=国际化资源信息：年龄必须在${min}同${max}之间。&lt;/p&gt;

&lt;p&gt;在Struts 2框架的配置文件中引用OGNL表达式，例如下面的代码片断所示：
&amp;lt;validators&amp;gt;
&amp;lt;field name=”intb”&amp;gt;
&amp;lt;field-validator type=”int”&amp;gt;
&amp;lt;param name=”min”&amp;gt;10&amp;lt;/param&amp;gt;
&amp;lt;param name=”max”&amp;gt;100&amp;lt;/param&amp;gt;
&amp;lt;message&amp;gt;BAction-test校验：数字必须为${min}为${max}之间！&amp;lt;/message&amp;gt;
&amp;lt;/field-validator&amp;gt;
&amp;lt;/field&amp;gt;
&amp;lt;/validators&amp;gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何对SVN进行回滚操作</title>
   <link href="http://dreambt.github.com/Version Control/2011/09/29/how-to-rollback-of-svn"/>
   <updated>2011-09-29T14:18:34+08:00</updated>
   <id>http://dreambt.github.com/Version Control/2011/09/29/how-to-rollback-of-svn</id>
   <content type="html">&lt;p&gt;打开CMD，cd到co目录。执行下面的操作：
&lt;code&gt;svn merge --dry-run -r73:68 http://svn.alibaba-inc.com/repos/ali_QA/20_Scripts/05picassowr_v2.0/install
svn merge -r73:68 http://svn.alibaba-inc.com/repos/ali_QA/20_Scripts/05picassowr_v2.0/install
svn commit -m &quot;Reverted to revision 68.&quot;&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>批处理截取字符串方法详解</title>
   <link href="http://dreambt.github.com/Windows/2011/09/26/sunstring-in-batch"/>
   <updated>2011-09-26T21:21:54+08:00</updated>
   <id>http://dreambt.github.com/Windows/2011/09/26/sunstring-in-batch</id>
   <content type="html">&lt;p&gt;@echo off
set str=123456789
echo 第一个字符为：%str:~0,1%
echo 头两个字符为：%str:~0,2%
echo 头5个字符为：%str:~0,5%
echo 去掉最后一个字符后的字符串为：%str:~0,-1%
echo 去掉最后3个字符后的字符串为：%str:~0,-3%
echo 第4个字符为：%str:~3,1%
echo 第4个及其之后的3个字符为：%str:~3,4%
echo 最后一个字符为：%str:~-1%
echo 最后一个字符为：%str:~-1,1%
echo 最后一个字符为：%str:~-1,2%
echo 倒数第4个字符为：%str:~-4,1%
echo 倒数第4个及其之后的字符为：%str:~-4%
echo 倒数第4个及其之后的1个字符为：%str:~-4,2%
echo 倒数第4个及其之后的2个字符为：%str:~-4,3%
pause&lt;/p&gt;

&lt;p&gt;echo %var:~n,k%
我们在这里对每个参数做个说明:&quot;%var&quot;,即我们要从中要截取字符的字符串.&quot; ~ &quot;取字符标志符(我是这么理解的),&quot;n&quot; 我们将其理解为指针,&quot;k&quot;我们将其理解为偏移地址.(注:指针和偏移地址都是从零开始数的)&lt;/p&gt;

&lt;p&gt;@echo off
set str=123456789&lt;/p&gt;

&lt;p&gt;rem 定义一个str字符串为123456789
echo 第一个字符为：%str:~0,1%&lt;/p&gt;

&lt;p&gt;rem 指针为0,偏移地址为1,即从第0位开始,取1位
echo 头两个字符为：%str:~0,2%&lt;/p&gt;

&lt;p&gt;rem 指针为0,偏移地址为2,即从第0位开始,取2位
echo 头5个字符为：%str:~0,5%&lt;/p&gt;

&lt;p&gt;rem 指针为0,偏移地址为5,即从第0位开始,取5位
echo 去掉最后一个字符后的字符串为：%str:~0,-1%&lt;/p&gt;

&lt;p&gt;rem 当&quot;k&quot;为负值时,我们可以这样理解:从指针开始处开始取其后面所有字符,然后减去后面&quot;abs(k)位&quot;..所以这个句字我们可以做如下解释:从第0位开始取其全部字符为:123456789然后从后面减去abs(k)位,所以最后结果为:12345678
echo 去掉最后3个字符后的字符串为：%str:~0,-3%&lt;/p&gt;

&lt;p&gt;rem 该句解释同上
echo 最后一个字符为：%str:~-1%&lt;/p&gt;

&lt;p&gt;rem 参数&quot;n,&quot;和&quot;k&quot;都可以为缺省,缺省&quot;n,&quot;时可以理解为:从abs(k)位开始取其全部
echo 倒数第4个及其之后的字符为：%str:~-4%&lt;/p&gt;

&lt;p&gt;rem 解释同上
echo 最后一个字符为：%str:~-1,1%&lt;/p&gt;

&lt;p&gt;rem n为负值时,表示从后面开始截取字符,取k位(此时n应从1开始数)
echo 最后一个字符为：%str:~-1,2%&lt;/p&gt;

&lt;p&gt;rem 解释同上
echo 倒数第4个字符为：%str:~-4,1%&lt;/p&gt;

&lt;p&gt;rem 解释同上
echo 倒数第4个及其之后的1个字符为：%str:~-4,2%&lt;/p&gt;

&lt;p&gt;rem 解释同上
echo 倒数第4个及其之后的2个字符为：%str:~-4,3%&lt;/p&gt;

&lt;p&gt;rem 解释同上
pause&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java 容器类及遍历效率对比</title>
   <link href="http://dreambt.github.com/Java/2011/08/23/java-container-traversal-method-and-efficiency-compared"/>
   <updated>2011-08-23T10:15:40+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/08/23/java-container-traversal-method-and-efficiency-compared</id>
   <content type="html">&lt;h4&gt;Java的容器类&lt;/h4&gt;


&lt;p&gt;&lt;strong&gt;1)Collection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Collection是最基本的集合接口，一个Collection代表一组Object，Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)List&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以元素插入的次序来放置元素，不会重新排列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)Set&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不接爱重复元素，它会使用自己内部的一个排列机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4)Map&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一群成对的key-value对象，即所持有的是key-value pairs。Map中不能有重复的key，它拥有自己的内部排列机制.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5)Vector&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例 如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。&lt;/p&gt;

&lt;p&gt;Java容器类类库的用途是“保存对象”，它分为两类：&lt;/p&gt;

&lt;p&gt;Collection----一组独立的元素，通常这些元素都服从某种规则。List必须保持元素特定的顺序，而Set不能有重复元素。&lt;/p&gt;

&lt;p&gt;Map----一组成对的“键值对”对象，即其元素是成对的对象，最典型的应用就是数据字典，并且还有其它广泛的应用。另外，Map可以返回其所有键组成的Set和其所有值组成的Collection，或其键值对组成的Set，并且还可以像数组一样扩展多维Map，只要让Map中键值对的每个“值”是一个Map即可。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.迭代器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;迭代器是一种设计模式，它是一个对象，它可以遍历并选择序列中的对象，而开发人员不需要了解该序列的底层结构。迭代器通常被称为“轻量级”对象，因为创建它的代价小。&lt;/p&gt;

&lt;p&gt;Java中的Iterator功能比较简单，并且只能单向移动：&lt;/p&gt;

&lt;p&gt;(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。&lt;/p&gt;

&lt;p&gt;(2) 使用next()获得序列中的下一个元素。&lt;/p&gt;

&lt;p&gt;(3) 使用hasNext()检查序列中是否还有元素。&lt;/p&gt;

&lt;p&gt;(4) 使用remove()将迭代器新返回的元素删除。&lt;/p&gt;

&lt;p&gt;Iterator是Java迭代器最简单的实现，为List设计的ListIterator具有更多的功能，它可以从两个方向遍历List，也可以从List中插入和删除元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.List的功能方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;(interface)&lt;/p&gt;

&lt;p&gt;次序是List最重要的特点；它确保维护元素特定的顺序。List为Collection添加了许多方法，使得能够向List中间插入与移除元素(只推荐LinkedList使用)。一个List可以生成ListIterator，使用它可以从两个方向遍历List，也可以从List中间插入和删除元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ArrayList&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;由数组实现的List。它允许对元素进行快速随机访问，但是向List中间插入与移除元素的速度很慢。ListIterator只应该用来由后向前遍历ArrayList，而不是用来插入和删除元素，因为这比LinkedList开销要大很多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedList&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;对顺序访问进行了优化，向List中间插入与删除的开销不大，随机访问则相对较慢(可用ArrayList代替)。它具有方法addFirst()、addLast()、getFirst()、getLast()、removeFirst()、removeLast()，这些方法(没有在任何接口或基类中定义过)使得LinkedList可以当作堆栈、队列和双向队列使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.Set的功能方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt;(interface)&lt;/p&gt;

&lt;p&gt;存入Set的每个元素必须是唯一的，因为Set不保存重复元素。加入Set的Object必须定义equals()方法以确保对象的唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HashSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为快速查找而设计的Set。存入HashSet的对象必须定义hashCode()。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TreeSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保持次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LinkedHashSet&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;具有HashSet的查询速度，且内部使用链表维护元素的顺序(插入的次序)。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。&lt;/p&gt;

&lt;p&gt;HashSet采用散列函数对元素进行排序，这是专门为快速查询而设计的；TreeSet采用红黑树的数据结构进行排序元素；LinkedHashSet内部使用散列以加快查询速度，同时使用链表维护元素的次序，使得看起来元素是以插入的顺序保存的。需要注意的是，生成自己的类时，Set需要维护元素的存储顺序，因此要实现Comparable接口并定义compareTo()方法。&lt;/p&gt;

&lt;h4&gt;List遍历效率对比&lt;/h4&gt;


&lt;p&gt;&lt;strong&gt;测试程序&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

public class ListTest {
public static void main(String args[]){
List lists = new ArrayList();

for(Long i=0l;i&amp;lt;1000000l;i++){
lists.add(i);
}

Long oneOk = oneMethod(lists);
Long twoOk = twoMethod(lists);
Long threeOk = threeMethod(lists);
Long fourOk = fourMethod(lists);

System.out.println(&quot;One:&quot; + oneOk);
System.out.println(&quot;Two:&quot; + twoOk);
System.out.println(&quot;Three:&quot; + threeOk);
System.out.println(&quot;four:&quot; + fourOk);

}

public static Long oneMethod(Listlists){

Long timeStart = System.currentTimeMillis();
for(int i=0;i System.out.println(lists.get(i));
}
Long timeStop = System.currentTimeMillis();

return timeStop -timeStart ;
}

public static Long twoMethod(Listlists){

Long timeStart = System.currentTimeMillis();
for(Long string : lists) {
System.out.println(string);
}
Long timeStop = System.currentTimeMillis();

return timeStop -timeStart ;
}

public static Long threeMethod(Listlists){

Long timeStart = System.currentTimeMillis();
Iterator it = lists.iterator();
while (it.hasNext())
{
System.out.println(it.next());
}
Long timeStop = System.currentTimeMillis();

return timeStop -timeStart ;
}

public static Long fourMethod(Listlists){

Long timeStart = System.currentTimeMillis();
for(Iterator i = lists.iterator(); i.hasNext();) {
System.out.println(i.next());
}
Long timeStop = System.currentTimeMillis();

return timeStop -timeStart ;
}
}&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;One:14109
Two:14000
Three:15141
four:14297&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Oracle锁表与解表</title>
   <link href="http://dreambt.github.com/Database/2011/08/22/oracle-lock-table-and-unluck"/>
   <updated>2011-08-22T13:00:28+08:00</updated>
   <id>http://dreambt.github.com/Database/2011/08/22/oracle-lock-table-and-unluck</id>
   <content type="html">&lt;p&gt;这里不教授如何锁表，大家自己摸索~&lt;/p&gt;

&lt;p&gt;下面讲如何解表：&lt;/p&gt;

&lt;p&gt;有关视图
v$session        查询会话的信息
v$session_wait   查询等待的会话信息
v$lock           列出系统中的所有锁
dba_locks        对v$lock的格式化视图
v$locked_object  只包含DML的锁信息,包括回滚段和会话信息&lt;/p&gt;

&lt;p&gt;任何DML语句其实产生了两个锁，一个是表锁，一个是行锁。&lt;/p&gt;

&lt;p&gt;如果发生了锁等待，我们可能更想知道是谁锁了表而引起谁的等待。以下的语句可以查询到谁锁了表，而谁在等待。&lt;/p&gt;

&lt;pre&gt;SELECT /*+ rule */ s.username, 
decode(l.type,'TM','TABLE LOCK', 
'TX','ROW LOCK', 
NULL) LOCK_LEVEL, 
o.owner,o.object_name,o.object_type, 
s.sid,s.serial#,s.terminal,s.machine,s.program,s.osuser 
FROM v$session s,v$lock l,dba_objects o 
WHERE l.sid = s.sid 
AND l.id1 = o.object_id(+) 
AND s.username is NOT NULL&lt;/pre&gt;


&lt;pre&gt;SELECT /*+ rule */ lpad(' ',decode(l.xidusn ,0,3,0))||l.oracle_username User_name, o.owner,o.object_name,o.object_type,s.sid,s.serial# 
FROM v$locked_object l,dba_objects o,v$session s 
WHERE l.object_id=o.object_id 
AND l.session_id=s.sid 
ORDER BY o.object_id,xidusn DESC&lt;/pre&gt;


&lt;p&gt;以上查询结果是一个树状结构，如果有子节点，则表示有等待发生。&lt;/p&gt;

&lt;p&gt;如果想知道锁用了哪个回滚段，还可以关联到V$rollname，其中xidusn就是回滚段的USN&lt;/p&gt;

&lt;p&gt;杀锁命令&lt;/p&gt;

&lt;pre&gt;alter system kill session 'sid,serial#'&lt;/pre&gt;




&lt;address&gt;&lt;em&gt;更多知识请参考：&lt;/em&gt;
&lt;em&gt; &lt;a href=&quot;http://space.itpub.net/13636837/viewspace-624458&quot; target=&quot;_blank&quot;&gt;http://space.itpub.net/13636837/viewspace-624458&lt;/a&gt;&lt;/em&gt;&lt;/address&gt;

</content>
 </entry>
 
 <entry>
   <title>Facebook内部人才建设的5条潜规则</title>
   <link href="http://dreambt.github.com/Other/2011/08/17/facebook-five-unspoken-rules"/>
   <updated>2011-08-17T12:53:43+08:00</updated>
   <id>http://dreambt.github.com/Other/2011/08/17/facebook-five-unspoken-rules</id>
   <content type="html">&lt;p&gt;Facebook产品第二研究中心执行总监胡智鑫(George Hu)接受@IT你懂的 专访时谈到了一个成功互联网企业的内部人才建设规划，与目前中国最大的不同在于西方人更喜欢创造一份舒适又有挑战的工作，而在中国是一群人挤破脑袋去当一个“官”，老板们想方设法在公司内部制造官僚体系留人。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ffffff;&quot;&gt;&lt;a href=&quot;http://www.im47.cn/wp-content/uploads/2011/08/0251f273dc7a615029ba64002b34c6c3.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-1001&quot; title=&quot;0251f273dc7a615029ba64002b34c6c3&quot; src=&quot;http://www.im47.cn/wp-content/uploads/2011/08/0251f273dc7a615029ba64002b34c6c3.jpg&quot; alt=&quot;&quot; width=&quot;513&quot; height=&quot;301&quot; /&gt;&lt;/a&gt;
&lt;/span&gt;&lt;/p&gt;

&lt;center&gt;&lt;/center&gt;


&lt;p&gt;&lt;strong&gt;　　1、新人就是一个祼人，那怕你原来是CEO。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有几多Google的工程师跳槽到Facebook，其中一个曾经是街景项目的总监，但在前面两个月时间内，他和一个普通的技术员没什么两样在写代码，他原来的职务对他现在的工作没有一点影响。而半年后，因为他的能力出色，被任命为一个秘密项目的项目经理。据我所知在中国如果招一个技术总监，打死他也不肯写代码了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2、晋升没有周期，可能随时随地。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们没有加薪或晋升的固定时间，在Facebook只要完成一个重要项目并且在规定的时间内完成目标数据，公司立即对项目成员进行加薪和晋升。当然如果做假，也会有很严厉的惩罚。我的中国同学因为模仿Apple一个专利连升两级，但最后被查出是抄袭，被起诉，退回多加的薪水，并且开除。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　3、能力不行，或者走人或者做管理。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;晚上12点，几个程序员还在解决一个安全问题，这时候他们的主管送上了热腾腾的中国水饺，要知道这可是去5公里的中国餐馆买来的。和国内有点不同，这儿的一线员工是地位最高的，管理者类似国内的后勤工作，是为员工服务的。而在中国很多企业是把业务做不好的人升为做管理，并且还指挥有能力的人干活，这也是我不愿意回国的一个重要因素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　4、做一流的企业，给一流的薪水。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mark Zuckerberg创办这天开始，就开出了比Google、Apple更高的薪水，他们理念就是我们要做全世界一流的企业，那什么都要一流，包括薪水。当然一流的薪水得到的是一流的人才，这也是对人才市场定价的认同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　5、多一天懈怠，早一天回家。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;进公司的那天起，CHO就告诉我们，做好随时被裁员的准备。任何一个人进Facebook总有一天要离开，只是时间长短的问题。认真做好每一件事，珍惜每一天，离开Facebook的时候不后悔。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;span style=&quot;color: #888888;&quot;&gt;作者：董释德 http://weibo.com/itnidongde&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby入门(一):Ruby简介</title>
   <link href="http://dreambt.github.com/Ruby/2011/08/10/ruby"/>
   <updated>2011-08-10T21:02:55+08:00</updated>
   <id>http://dreambt.github.com/Ruby/2011/08/10/ruby</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;文章摘要&lt;/strong&gt;&lt;/p&gt;

&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;strong&gt;Ruby是如何来的&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;ScreenShot&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff; font-size: small;&quot;&gt;Ruby是如何来的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Ruby 的发明者&lt;a href=&quot;http://www.rubyist.net/~matz/&quot;&gt;松本行弘 Yukihiro “matz” Matsumoto&lt;/a&gt;，混合了他喜欢的语言（Perl、 Smalltalk、 Eiffel、 Ada 和 Lisp ） 产生了一种具有函数式及指令程序设计特性的新语言。他常说，他是“试着让 Ruby 更自然，而不是简单，就像生活一样”。&lt;/p&gt;

&lt;p&gt;除此之外，他还提到：Ruby 就像人的身体一样，表面上看来简单，但是内部却相当的复杂.&lt;/p&gt;

&lt;p&gt;在 1993 年，没有人会相信一个由日本业余语言设计者创建的面向对象的语言，能最终在世界范围内被广泛使用并且变得几乎像 Perl 那样流行。自从 1995 年 Ruby 公开发表以来，Ruby 在全球吸引了许多忠实的程序设计员。在 2006 年，Ruby 被广泛接受。在各大城市都有活跃的使用者并通过社区举办许许多多场场爆满的研讨会。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;在 TIOBE， 最流行的开发语言排名调查中， Ruby 排名为全球第 11 位。 根据这样的成长情况，他们预测“在半年之中 Ruby 将会进入最受欢迎开发语言的前 10 名。”有越来越多受欢迎的软件如 Ruby on Rails web framework 是使用 Ruby 撰写而成，也是造成 Ruby 如此快速成长的原因。&lt;/p&gt;

&lt;p&gt;Ruby 是开源软件。 不只是免费，而且可以自由的使用、复制、修改与发布。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff; font-size: small;&quot;&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先下载安装Ruby &lt;a title=&quot;http://www.ruby-lang.org/en/downloads/&quot; href=&quot;http://www.ruby-lang.org/en/downloads/&quot;&gt;http://www.ruby-lang.org/en/downloads/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装后，在命令行ruby -v 检查是否安装正确&lt;/p&gt;

&lt;p&gt;ruby提供了很好的irb的环境，直接在命令行敲入irb就可以，然后可以直接运行ruby 语句，这对实验ruby是非常好的环境，比如我就经常拿它来当计算器&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff; font-size: small;&quot;&gt;ScreenShot&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 一切皆是对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#一切皆是对象
puts 1.class
puts 0.1.class
puts true.class
puts false.class
puts nil.class&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;从上图可以看出，从简单类型，到真、假、空都是对象，方法调用参数也是可选的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.语句块和迭代器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#语句块&amp;amp;迭代器
3.times{puts &quot;Happy SiQi~&quot;}
1.upto(10){puts &quot;Hello world~&quot;}&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;上面两张图可以看出ruby操作循环的便利&lt;/p&gt;

&lt;pre&gt;#map
a=[1,2,3,4]
b=a.map{|x| x*2}
c=a.select{|x| x%2==0}&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;上图显示的是处理集合的威力&lt;/p&gt;

&lt;pre&gt;#hash
h={
:one=&amp;gt;1,
:two=&amp;gt;2
}
h[:one]
h[:two]
h.each do |key,value|
  print &quot;#{value}:#{key}&quot;
end&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;上图显示Hash处理的展示&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.表达式和操作符&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#表达式和操作符
puts 1+2
puts 1*2
puts 1+2==3
puts &quot;Hello&quot;+&quot; World!&quot;
puts &quot;Happy New Year&quot;*3
puts &quot;%s %d %s&quot; % [&quot;Jack&quot;,20,&quot;cool&quot;]&lt;/pre&gt;


&lt;p&gt;&lt;strong&gt;4. 方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.自定义方法&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#方法
#自定义方法
def SayHello(name=siqi)
  puts name
  3.times{puts &quot;你好!&quot;}
end
SayHello(&quot;Jack&quot;)&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;b.为已有的类添加方法&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#为已有的类添加方法
def Math.AddTwo(x)
  x+2
end
puts Math.AddTwo(5)&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;赋值语句&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#赋值语句
x=1
y=10
x+=1
puts &quot;x=#{x}&quot;
y-=1
puts &quot;y=#{y}&quot;
a,b=1,2
puts &quot;a=#{a},b=#{b}&quot;
a,b=b,a
puts &quot;a=#{a},b=#{b}&quot;
x,y,z=[1,2,3]
puts &quot;x=#{x},y=#{y},z=#{z}&quot;&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;为多个变量赋值是比较便利的&lt;/p&gt;

&lt;p&gt;下图展示方法是可以返回多个值的&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#可以返回多个值的
def LoveMovieAndSport(name)
  [name+&quot; Love StarWar&quot;, name+&quot; Love FootBar&quot;]
end
movie,sport=LoveMovieAndSport(&quot;Jack&quot;)
puts movie
puts sport&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;6.后缀&lt;/p&gt;

&lt;p&gt;？检查方法结果是否为真，!立即改变当前对象&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#后缀
#?检查方法结果是否为真，!立即改变当前对象
a=[4,2,1,3,7]
puts a.empty?
puts a.sort
puts a
a.sort!
puts a&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. Class 和 Module&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;pre&gt;#Class 和 Module
class Animal
  def GetLeg
    4000
  end
end
animal=Animal.new()
puts animal.GetLeg&lt;/pre&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;上图展示如何用module来组织类，是不是像.Net的命名空间？实际不是，这个我们后面会说到。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. gem包管理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;ruby的第三方插件是用gem方式来管理，这是一个非常容易发布和共享，一个简单的命令就可以安装上第三方的扩展库&lt;/p&gt;

&lt;p&gt;gem install rails 安装ruby on rails&lt;/p&gt;

&lt;p&gt;gem list 列出所有安装的ruby 包&lt;/p&gt;

&lt;p&gt;gem enviroment 显示gem的配置&lt;/p&gt;

&lt;p&gt;gem update rails 更新指定的包&lt;/p&gt;

&lt;p&gt;gem update   更新所有的包&lt;/p&gt;

&lt;p&gt;gem update --system 更新gem自身&lt;/p&gt;

&lt;p&gt;gem uninstall rails  卸载指定的包&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;
&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux下curl命令的使用</title>
   <link href="http://dreambt.github.com/Linux/2011/08/04/linux-curl"/>
   <updated>2011-08-04T13:30:44+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/08/04/linux-curl</id>
   <content type="html">&lt;p&gt;1)初体验&lt;/p&gt;

&lt;p&gt;curl http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;回车之后，www.yahoo.com 的html就稀里哗啦地显示在屏幕上了~&lt;/p&gt;

&lt;p&gt;2)保存页面
curl http://www.yahoo.com &amp;gt; page.html&lt;/p&gt;

&lt;p&gt;或者用curl的内置option，存下http的结果
curl -o page.html http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;3)如果需要proxy代理&lt;/p&gt;

&lt;p&gt;curl -x 123.45.67.89:1080 -o page.html http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;4)处理cookie信息
option: -D &amp;lt;-- 这个是把http的response里面的cookie信息存到一个特别的文档中去
curl -x 123.45.67.89:1080 -o page.html -D cookie0001.txt http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;5）下一次访问的时候，如何继续使用上次留下的cookie信息呢？要知道，很多网站都是靠监控您的cookie信息，来判断您是不是不按规矩访问他们的网站的。
这次我们使用这个option来把上次的cookie信息追加到http request里面去： -b
curl -x 123.45.67.89:1080 -o page1.html -D cookie0002.txt -b cookie0001.txt http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;6）浏览器信息
让我们随意指定自己这次访问所宣称的自己的浏览器信息： -A
curl -A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; -x 123.45.67.89:1080 -o page.html -D cookie0001.txt http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;这样，服务器端接到访问的需要，会认为您是个运行在Windows 2000上的IE6.0，嘿嘿嘿，其实也许您用的是苹果机呢！
而&quot;Mozilla/4.73 [en] (X11; U; Linux 2.2; 15 i686&quot;则能够告诉对方您是一台PC上跑着的Linux，用的是Netscape 4.73，呵呵呵&lt;/p&gt;

&lt;p&gt;7）另外一个服务器端常用的限制方法，就是检查http访问的referer。比如您先访问首页，再访问里面所指定的下载页，这第二次访问的referer地址就是第一次访问成功后的页面地址。这样，服务器端只要发现对下载页面某次访问的referer地址不 是首页的地址，就能够断定那是个盗连了~&lt;/p&gt;

&lt;p&gt;幸好curl给我们提供了设定referer的option： -e
curl -A &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)&quot; -x 123.45.67.89:1080 -e &quot;mail.yahoo.com&quot; -o page.html -D cookie0001.txt http://www.yahoo.com&lt;/p&gt;

&lt;p&gt;这样，就能够骗对方的服务器，您是从mail.yahoo.com点击某个链接过来的了，呵呵呵&lt;/p&gt;

&lt;p&gt;8）利用curl 下载文档&lt;/p&gt;

&lt;p&gt;curl -o 1.jpg http://cgi2.tky.3web.ne.jp/~zzh/screen1.JPG
curl -O http://cgi2.tky.3web.ne.jp/~zzh/screen1.JPG //按照服务器上的文档名保存
curl -O http://cgi2.tky.3web.ne.jp/~zzh/screen[1-10].JPG //序列下载
curl -O http://cgi2.tky.3web.ne.jp/~/[001-201].JPG
curl -o #2_#1.jpg http://cgi2.tky.3web.ne.jp/~/[001-201].JPG //自定义文档名的下载&lt;/p&gt;

&lt;h1&gt;1是变量，指的是这部分，第一次取值zzh，第二次取值nick&lt;/h1&gt;

&lt;h1&gt;2代表的变量，则是第二段可变部分---[001-201]，取值从001逐一加到201&lt;/h1&gt;

&lt;p&gt;这样，自定义出来下载下来的文档名，就变成了这样：
原来： ~zzh/001.JPG ---&amp;gt; 下载后： 001-zzh.JPG
原来： ~nick/001.JPG ---&amp;gt; 下载后： 001-nick.JPG&lt;/p&gt;

&lt;p&gt;这样一来，就不怕文档重名啦，呵呵&lt;/p&gt;

&lt;p&gt;9）断点续传&lt;/p&gt;

&lt;p&gt;curl -c -O http://cgi2.tky.3wb.ne.jp/~zzh/screen1.JPG&lt;/p&gt;

&lt;p&gt;10）分块下载 -r&lt;/p&gt;

&lt;p&gt;比如我们有一个http://cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 要下载（赵老师的电话朗诵 :D ）
我们就能够用这样的命令：
curl -r 0-10240 -o &quot;zhao.part1&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;amp;\
curl -r 10241-20480 -o &quot;zhao.part2&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;amp;\
curl -r 20481-40960 -o &quot;zhao.part3&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3 &amp;amp;\
curl -r 40961- -o &quot;zhao.part4&quot; http:/cgi2.tky.3web.ne.jp/~zzh/zhao1.mp3
这样就能够分块下载啦。
但是您需要自己把这些破碎的文档合并起来
假如您用UNIX或苹果，用 cat zhao.part* &amp;gt; zhao.mp3就能够
假如用的是Windows，用copy /b 来解决吧&lt;/p&gt;

&lt;p&gt;上面讲的都是http协议的下载，其实ftp也相同能够用。
用法：
curl -u name:passwd ftp://ip:port/path/file
或
curl ftp://name:passwd@ip:port/path/file&lt;/p&gt;

&lt;p&gt;11)上传 -T&lt;/p&gt;

&lt;p&gt;比如我们向ftp传一个文档：&lt;/p&gt;

&lt;p&gt;curl -T localfile -u name:passwd ftp://upload_site:port/path/&lt;/p&gt;

&lt;p&gt;当然，向http服务器上传文档也能够
curl -T localfile http://cgi2.tky.3web.ne.jp/~zzh/abc.cgi
注意，这时候，使用的协议是HTTP的PUT method&lt;/p&gt;

&lt;p&gt;http提交一个表单，比较常用的是POST模式和GET模式&lt;/p&gt;

&lt;p&gt;GET模式什么option都不用，只需要把变量写在url里面就能够了
比如：
curl http://www.yahoo.com/login.cgi?user=nickwolfe&amp;amp;password=12345&lt;/p&gt;

&lt;p&gt;POST模式的option则是 -d
比如：&lt;/p&gt;

&lt;p&gt;curl -d &quot;user=nickwolfe&amp;amp;password=12345&quot; http://www.yahoo.com/login.cgi&lt;/p&gt;

&lt;p&gt;就相当于向这个站点发出一次登陆申请~~~~~&lt;/p&gt;

&lt;p&gt;到底该用GET模式还是POST模式，要看对面服务器的程式设定。&lt;/p&gt;

&lt;p&gt;一点需要注意的是，POST模式下的文档上传，比如
&amp;lt;form method=&quot;POST&quot; enctype=&quot;multipar/form-data&quot; action=&quot;http://cgi2.tky.3web.ne.jp/~zzh/up_file.cgi&quot;&amp;gt;
&amp;lt;input type=file name=upload&amp;gt;
&amp;lt;input type=submit name=nick value=&quot;go&quot;&amp;gt;
&amp;lt;/form&amp;gt;
这样一个HTTP表单，我们要用curl进行模拟，就该是这样的语法：
curl -F upload=@localfile -F nick=go http://cgi2.tky.3web.ne.jp/~zzh/up_file.cgi&lt;/p&gt;

&lt;p&gt;12）https的时候使用本地证书
curl -E localcert.pem https://remote_server&lt;/p&gt;

&lt;p&gt;13）用curl通过dict协议去查字典~~~~~
curl dict://dict.org/d:computer&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ruby和Watir调用浏览器测试</title>
   <link href="http://dreambt.github.com/Test/2011/07/15/ruby-watir-test"/>
   <updated>2011-07-15T09:15:23+08:00</updated>
   <id>http://dreambt.github.com/Test/2011/07/15/ruby-watir-test</id>
   <content type="html">&lt;p&gt;gem update --system
gem install watir&lt;/p&gt;

&lt;p&gt;当使用Watir开发测试脚本的时候，通过给网页上的对象发送消息来与之交互。&lt;/p&gt;

&lt;p&gt;Watir 语法（Web Application Testing in Ruby)&lt;/p&gt;

&lt;h1&gt;watir的安装&lt;/h1&gt;

&lt;p&gt;watie的安装请查看 -&amp;gt; Ruby library的安装&lt;/p&gt;

&lt;h1&gt;使用Watir工具，需要在脚本中加上&lt;/h1&gt;

&lt;p&gt;require 'watir'&lt;/p&gt;

&lt;h1&gt;创建一个IE的实例&lt;/h1&gt;

&lt;p&gt;ie = Watir::IE.new
或者在创建的同时直接转到页面
ie = Watir::IE.start('http://www.text.com/')
Watir使用start方法同时创建一个浏览器实例并转到一个页面。
IE浏览速度
ie.speed = :fast
ie.speed = :slow&lt;/p&gt;

&lt;h1&gt;页面导航&lt;/h1&gt;

&lt;p&gt;ie.goto('http://www.text.com/')
注: ie.goto还可以运行javascript的代码如: ie.goto(&quot;javascript: ie.document.write(&quot;Hello World&quot;);&quot;)&lt;/p&gt;

&lt;h1&gt;取得当前网页的网址&lt;/h1&gt;

&lt;p&gt;ie.url&lt;/p&gt;

&lt;h1&gt;点击超链接&lt;/h1&gt;

&lt;p&gt;ie.link(:text , &quot;Pickaxe&quot;).click
ie.link(:href, /http:\/\/pragmaticprogrammer.com/).click
ie.link(:name =&amp;gt; 'foo', :index =&amp;gt; 1).click&lt;/p&gt;

&lt;h1&gt;超链接的uri&lt;/h1&gt;

&lt;p&gt;ie.link(:text , &quot;Pickaxe&quot;).href
ie.link(:index, 1).href
ie.link(:text =&amp;gt; &quot;reply&quot;, :index =&amp;gt; 2).href&lt;/p&gt;

&lt;h1&gt;超链接的文本&lt;/h1&gt;

&lt;p&gt;ie.link(:href , /http:\/\/pragmaticprogrammer.com/).text&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;a href='http://pragmaticprogrammer.com/titles/ruby/'&amp;gt;Pickaxe&amp;lt;/a&amp;gt;&lt;/p&gt;

&lt;h1&gt;img标签&lt;/h1&gt;

&lt;p&gt;ie.image(:name, 'image').src
ie.image(:index, 2).src&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;img name = img src='http://pragmaticprogrammer.com/titles/ruby/top.gif'&amp;gt;
&amp;lt;img name = img src='http://pragmaticprogrammer.com/titles/ruby/head.gif'&amp;gt;&lt;/p&gt;

&lt;h1&gt;设置复选框&lt;/h1&gt;

&lt;p&gt;ie.checkbox(:name, &quot;checkme&quot;).set
ie.checkbox(:name, &quot;checkme&quot;, &quot;1&quot;).set # 使用name和value属性设置复选框&lt;/p&gt;

&lt;h1&gt;清除复选框&lt;/h1&gt;

&lt;p&gt;ie.checkbox(:name, &quot;checkme&quot;).clear
ie.checkbox(:name, &quot;checkme&quot;, &quot;1&quot;).clear # 使用name和value属性清除复选框&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;input type = &quot;checkbox&quot; name = &quot;checkme&quot; value = &quot;1&quot;&amp;gt;&lt;/p&gt;

&lt;h1&gt;设置单选框&lt;/h1&gt;

&lt;p&gt;ie.radio(:name, &quot;clickme&quot;).set
ie.radio(:name=&amp;gt;'clickme', :index=&amp;gt;2).set
ie.radio(:name, &quot;clickme&quot;, &quot;1&quot;).set # 使用name和id属性设置单选框&lt;/p&gt;

&lt;h1&gt;使用name属性清除单选框&lt;/h1&gt;

&lt;p&gt;ie.radio(:name, &quot;clickme&quot;).clear
ie.radio(:name, &quot;clickme&quot;, &quot;1&quot;).clear # 使用name和id属性清除单选框&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;input type = &quot;radio&quot; name = &quot;clickme&quot; id = &quot;1&quot;&amp;gt;
&amp;lt;input type = &quot;radio&quot; name = &quot;clickme&quot; id = &quot;2&quot;&amp;gt;&lt;/p&gt;

&lt;h1&gt;设置下拉框&lt;/h1&gt;

&lt;p&gt;ie.select_list(:name, &quot;selectme&quot;).select('Python') # 使用text属性和值来设置下拉框
ie.select_list(:name, &quot;selectme&quot;).select_value('2') # 使用value属性和值来设置下拉框&lt;/p&gt;

&lt;h1&gt;使用name属性和值来清除下拉框&lt;/h1&gt;

&lt;p&gt;ie.select_list(:name, &quot;selectme&quot;).clearSelection&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;select name = &quot;selectme&quot;&amp;gt;
&amp;lt;option value = 1&amp;gt;Ruby
&amp;lt;option value = 2&amp;gt;Java
&amp;lt;option value = 3&amp;gt;Python
&amp;lt;option value = 4&amp;gt;C
&amp;lt;/select&amp;gt;&lt;/p&gt;

&lt;h1&gt;文本的框设置&lt;/h1&gt;

&lt;p&gt;ie.text_field(:name, &quot;typeinme&quot;).set(&quot;Watir World&quot;)&lt;/p&gt;

&lt;h1&gt;清空文本输入框&lt;/h1&gt;

&lt;p&gt;ie.text_field(:name, &quot;typeinme&quot;).clear&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;input type = &quot;text&quot; name = &quot;typeinme&quot;&amp;gt;&lt;/p&gt;

&lt;h1&gt;通过值或name属性点击button&lt;/h1&gt;

&lt;p&gt;ie.button(:value, &quot;Click Me&quot;).click
ie.button(:name, &quot;clickme&quot;).click&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;input type = &quot;button&quot; name = &quot;clickme&quot; value = &quot;Click Me&quot;&amp;gt;&lt;/p&gt;

&lt;h1&gt;通过值或name属性点击Submit&lt;/h1&gt;

&lt;p&gt;ie.button(:value, &quot;Submit&quot;).click
ie.button(:type, &quot;Submit&quot;).click
ie.button(:name, &quot;Submit&quot;).click&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;form. action = &quot;submit&quot; name = &quot;submitform&quot; method=&quot;post&quot;&amp;gt;
&amp;lt;input type = &quot;submit&quot; value = &quot;Submit&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/p&gt;

&lt;h1&gt;表单中的图片按钮&lt;/h1&gt;

&lt;p&gt;ie.button(:name, &quot;doit&quot;).click&lt;/p&gt;

&lt;p&gt;对应的HTML代码为：
&amp;lt;form. action = &quot;submit&quot; name = &quot;doitform&quot; method=&quot;post&quot;&amp;gt;
&amp;lt;input type=&quot;image&quot; src = &quot;images/doit.gif&quot; name = &quot;doit&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/p&gt;

&lt;h1&gt;没有按钮的表单&lt;/h1&gt;

&lt;p&gt;ie.form(:name, &quot;loginform&quot;).submit # 通过name,action以及method属性来提交表单
ie.form(:action, &quot;login&quot;).submit
对应的HTML代码为：
&amp;lt;form. action = &quot;login&quot; name = &quot;loginform&quot; method=&quot;get&quot;&amp;gt;
&amp;lt;input name=&quot;username&quot; type=&quot;text&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/p&gt;

&lt;h1&gt;框架&lt;/h1&gt;

&lt;p&gt;ie.show_frames可以打印出当前页面框架的数量和名称
Watir允许通过名称属性来访问框架，如ie.frame(&quot;menu&quot;)
如果要访问menu框架中的一个超链接，可以
ie.frame(&quot;menu&quot;).link(:text, &quot;Click Menu Item&quot;).click&lt;/p&gt;

&lt;h1&gt;嵌套框架&lt;/h1&gt;

&lt;p&gt;ie.frame(:name, &quot;frame1&quot;).form(:name, 'form1')&lt;/p&gt;

&lt;h1&gt;新窗口&lt;/h1&gt;

&lt;p&gt;一些Web应用会弹出新窗口或打开一个新窗口，可以使用attach方法来访问并控制新窗口。通过标示新窗口的URL或者title来访问。
ie2 = Watir::IE.attach(:url, 'http://www.text.com/')
ie3 = Watir::IE.attach(:title, 'Test New Window')
也可以使用正则表达式
ie4 = Watir::IE.attach(:title, /Test New/)
注意：不要把新窗口分配到你的ie变量，最好给新窗口一个不同的名字&lt;/p&gt;

&lt;h1&gt;访问Table元素：&lt;/h1&gt;

&lt;p&gt;t = $ie.table(:id,&quot;data&quot;)
t = Table.new($ie,:id,&quot;data&quot;)
t = $ie.table[1]&lt;/p&gt;

&lt;h1&gt;tr,td元素&lt;/h1&gt;

&lt;p&gt;tr = ie.row(:id,&quot;title&quot;)
tr = TableRow.new(ie,:id,&quot;title&quot;)&lt;/p&gt;

&lt;p&gt;td = ie.cell(:id,&quot;name&quot;)
td = TableCell.new(ie,:id,&quot;name&quot;)&lt;/p&gt;

&lt;h1&gt;Watir中Table，TableBody，TableRow，TableCell这几个类，都提供了一个索引方法&quot;&lt;a href=&quot;index&quot;&gt;&lt;/a&gt;&quot;来定位其下一层的子元素对象,该方法为实例方法,&quot;index&quot;为传入的参数,索引值从1开始,而非从0开始。&lt;/h1&gt;

&lt;p&gt;用法如下：
以table的第一行，第一个元素为例：
tr1 = t.&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;
td1 = tr1.&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;
也可以连续访问：td1 = t.&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;.&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;
如果td中还有其他元素，可以通过td的实例方法直接访问，以checkbox为例：
cb = td1.checkbox(:id,'navigate_id').click&lt;/p&gt;

&lt;p&gt;对于以上所提到的对象,都是从Element继承而来,所以click,enabled?,exists?,fireEvent,flash,focus等方法都直接可以使用。
如果你的td元素定位准确了，且鼠标响应事件没有错误的话，那么应该能看到点击后的效果。
建议多查一下Watir的API Reference &lt;a href=&quot;http://wtr.rubyforge.org/rdoc/&quot; target=&quot;_blank&quot;&gt;http://wtr.rubyforge.org/rdoc/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;代码如下：
t = ie.table(:id,&quot;CoolMenu2menutable&quot;)
td_logout=t.&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;.&lt;a href=&quot;16&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;先找到Table，再索引TR，再索引到TD&lt;/p&gt;

&lt;h1&gt;运行Ruby时不显示browser方法&lt;/h1&gt;

&lt;p&gt;运行Ruby程序文件时在后面加 &quot;-b&quot;
ex:
test.rb -b
也可以做成.bat文件
ex: test.bat
ruby.exe test.rb -b&lt;/p&gt;

&lt;h1&gt;获取隐含对象值&lt;/h1&gt;

&lt;p&gt;&amp;lt;INPUT type=hidden value=&quot;您的Email&quot; name=&quot;field1&quot;&amp;gt;
方法：values = ie.hidden(:name, 'field1').value&lt;/p&gt;

&lt;h1&gt;获取窗口对象&lt;/h1&gt;

&lt;p&gt;方法1： ie2 = Watir::IE.attach(:url,'http://www.google.cn/')   #根据URL获取
方法2： ie3 = Watir::IE.attach(:title,'Google')                #根据窗口标题获
方法3： ie4 = Watir::IE.attach(:title, /google.cn/)              #正则表达式匹配获取&lt;/p&gt;

&lt;p&gt;转自：&lt;a href=&quot;http://my.chinaunix.net/space.php?uid=20255298&amp;amp;do=blog&amp;amp;id=170598&quot; target=&quot;_blank&quot;&gt;http://my.chinaunix.net/space.php?uid=20255298&amp;amp;do=blog&amp;amp;id=170598&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Quality of Service服务质量</title>
   <link href="http://dreambt.github.com/Cloud/2011/07/02/quality-of-service"/>
   <updated>2011-07-02T22:13:44+08:00</updated>
   <id>http://dreambt.github.com/Cloud/2011/07/02/quality-of-service</id>
   <content type="html">&lt;p&gt;QoS（Quality of Service）服务质量，是网络的一种安全机制, 是用来解决网络延迟和阻塞等问题的一种技术。 在正常情况下，如果网络只用于特定的无时间限制的应用系统，并不需要QoS，比如Web应用，或E-mail设置等。但是对关键应用和多媒体应用就十分必要。当网络过载或拥塞时，QoS 能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。&lt;/p&gt;

&lt;h2&gt;背景&lt;/h2&gt;


&lt;p&gt;在因特网创建初期，没有意识到QoS应用的需要。因此，整个因特网运作如一个“竭尽全力”的系统。每段信息都有4个“服务类别”位和3个“优先级”位，但是他们完全没有派上用场。 依发送和接收者看来，数据包从起点到终点的传输过程中会发生许多事情，并产生如下有问题的结果：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;丢失数据包&lt;/strong&gt; - 当数据包到达一个缓冲器（buffer）已满的路由器时，则代表此次的发送失败，路由器会依网络的状况决定要丢弃一部份、不丢弃 或者是所有的数据包，而且这不可能在预先就知道，接收端的应用程序在这时必须请求重新传送，而这同时可能造成总体传输严重的延迟。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt; - 或许需要很长时间才能将数据包传送到终点，因为它会被漫长的队列迟滞，或需要运用间接路由以避免阻塞；也许能找到快速、直接的路由。总之，延迟非常难以预料。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传输顺序出错&lt;/strong&gt; - 当一群相关的数据包被路由经过因特网时，不同的数据包可能选择不同的路由器，这会导致每个数据包有不同的延迟时间。最后数据包到达目的地的顺序会和数据包从发送端发送出去的顺序不一致，这个问题必须要有特殊额外的协议负责刷新失序的数据包。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;出错&lt;/strong&gt; - 有些时候，数据包在被运送的途中会发生跑错路径、被合并 甚至是 毁坏的情况，这时接收端必须要能侦测出这些情况，并将它们统统判别为已遗失的数据包，再请求发送端再送一份同样的数据包。&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;


&lt;p&gt;参数&lt;/p&gt;

&lt;p&gt;QoS是通过给定的虚连接描述传输质量的ATM性能参数术语。这些参数包括：CTD、CDV、CER、CLR、CMR和SECBR 、ALL service classes 、Qos Classes、 traffic contract、traffic control。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;2_2&quot;&gt;&lt;/a&gt;含义&lt;/p&gt;

&lt;p&gt;QoS（Quality of Service）即服务质量。对于网络业务，服务质量包括传输的带宽、传送的时延、数据的丢包率等。在网络中可以通过保证传输的带宽、降低传送的时延、降低数据的丢包率以及时延抖动等措施来提高服务质量。&lt;/p&gt;

&lt;p&gt;网络资源总是有限的，只要存在抢夺网络资源的情况，就会出现服务质量的要求。服务质量是相对网络业务而言的，在保证某类业务的服务质量的同时，可能就是在损害其它业务的服务质量。例如，在网络总带宽固定的情况下，如果某类业务占用的带宽越多，那么其他业务能使用的带宽就越少，可能会影响其他业务的使用。因此，网络管理者需要根据各种业务的特点来对网络资源进行合理的规划和分配，从而使网络资源得到高效利用。　　下面从QoS服务模型出发，对目前使用最多、最成熟的一些QoS技术逐一进行描述。在特定的环境下合理地使用这些技术，可以有效地提高服务质量。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;2_3&quot;&gt;&lt;/a&gt;QoS服务模型&lt;/p&gt;

&lt;p&gt;通常QoS提供以下三种服务模型：&lt;/p&gt;

&lt;p&gt;l Best-Effort service（尽力而为服务模型）&lt;/p&gt;

&lt;p&gt;l Integrated service（综合服务模型，简称Int-Serv）&lt;/p&gt;

&lt;p&gt;l Differentiated service（区分服务模型，简称Diff-Serv）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Best-Effort服务模型Best-Effort是一个单一的服务模型，也是最简单的服务模型。对Best-Effort服务模型，网络尽最大的可能性来发送报文。但对时延、可靠性等性能不提供任何保证。Best-Effort服务模型是网络的缺省服务模型，通过FIFO队列来实现。它适用于绝大多数网络应用，如FTP、E-Mail等。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Int-Serv服务模型Int-Serv是一个综合服务模型，它可以满足多种QoS需求。该模型使用资源预留协议（RSVP），RSVP运行在从源端到目的端的每个设备上，可以监视每个流，以防止其消耗资源过多。这种体系能够明确区分并保证每一个业务流的服务质量，为网络提供最细粒度化的服务质量区分。但是，Inter-Serv模型对设备的要求很高，当网络中的数据流数量很大时，设备的存储和处理能力会遇到很大的压力。Inter-Serv模型可扩展性很差，难以在Internet核心网络实施。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Diff-Serv服务模型Diff-Serv是一个多服务模型，它可以满足不同的QoS需求。与Int-Serv不同，它不需要通知网络为每个业务预留资源。区分服务实现简单，扩展性较好。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h2&gt;功能&lt;/h2&gt;


&lt;p&gt;分类&lt;/p&gt;

&lt;p&gt;分类是指具有QoS的网络能够识别哪种应用产生哪种数据包。没有分类，网络就不能确定对特殊数据包要进行的处理。所有应用都会在数据包上留下可以用来识别源应用的标识。分类就是检查这些标识，识别数据包是由哪个应用产生的。以下是4种常见的分类方法。&lt;/p&gt;

&lt;p&gt;(1)协议 有些协议非常“健谈”，只要它们存在就会导致业务延迟，因此根据协议对数据包进行识别和优先级处理可以降低延迟。应用可以通过它们的EtherType进行识别。譬如，AppleTalk协议采用0x809B，IPX使用0x8137。根据协议进行优先级处理是控制或阻止少数较老设备所使用的“健谈”协议的一种强有力方法。&lt;/p&gt;

&lt;p&gt;(2)TCP和UDP端口号码 许多应用都采用一些TCP或UDP端口进行通信，如 HTTP采用TCP端口80。通过检查IP数据包的端口号码，智能网络可以确定数据包是由哪类应用产生的，这种方法也称为第四层交换，因为TCP和UDP都位于OSI模型的第四层。&lt;/p&gt;

&lt;p&gt;(3)源IP地址 许多应用都是通过其源IP地址进行识别的。由于服务器有时是专门针对单一应用而配置的，如电子邮件服务器，所以分析数据包的源IP地址可以识别该数据包是由什么应用产生的。当识别交换机与应用服务器不直接相连，而且许多不同服务器的数据流都到达该交换机时，这种方法就非常有用。&lt;/p&gt;

&lt;p&gt;(4)物理端口号码 与源IP地址类似，物理端口号码可以指示哪个服务器正在发送数据。这种方法取决于交换机物理端口和应用服务器的映射关系。虽然这是最简单的分类形式，但是它依赖于直接与该交换机连接的服务器。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;3_2&quot;&gt;&lt;/a&gt;标注&lt;/p&gt;

&lt;p&gt;在识别数据包之后，要对它进行标注，这样其他网络设备才能方便地识别这种数据。由于分类可能非常复杂，因此最好只进行一次。识别应用之后就必须对其数据包进行标记处理，以便确保网络上的交换机或路由器可以对该应用进行优先级处理。通过采纳标注数据的两种行业标准，即IEEE 802.1p或差异化服务编码点(DSCP)，就可以确保多厂商网络设备能够对该业务进行优先级处理。　　在选择交换机或路由器等产品时，一定要确保它可以识别两种标记方案。虽然DSCP可以替换在局域网环境下主导的标注方案IEEE 802.1p，但是与IEEE 802.1p相比，实施DSCP有一定的局限性。在一定时期内，与IEEE 802.1p 设备的兼容性将十分重要。作为一种过渡机制，应选择可以从一种方案向另一种方案转换的交换机。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;3_3&quot;&gt;&lt;/a&gt;优先级设置&lt;/p&gt;

&lt;p&gt;一旦网络可以区分电话通话和网上浏览，优先级处理就可以确保进行Internet上大型下载的同时不中断电话通话。为了确保准确的优先级处理，所有业务量都必须在网络骨干内进行识别。在工作站终端进行的数据优先级处理可能会因人为的差错或恶意的破坏而出现问题。黑客可以有意地将普通数据标注为高优先级，窃取重要商业应用的带宽，导致商业应用的失效。这种情况称为拒绝服务攻击。通过分析进入网络的所有业务量，可以检查安全攻击，并且在它们导致任何危害之前及时阻止。&lt;/p&gt;

&lt;p&gt;在局域网交换机中，多种业务队列允许数据包优先级存在。较高优先级的业务可以在不受较低优先级业务的影响下通过交换机，减少对诸如话音或视频等对时间敏感业务的延迟事故。　　为了提供优先级，交换机的每个端口必须有至少2个队列。虽然每个端口有更多队列可以提供更为精细的优先级选择，但是在局域网环境中，每个端口需要4个以上队列的可能性不大。当每个数据包到达交换机时，都要根据其优先级别分配到适当的队列，然后该交换机再从每个队列转发数据包。该交换机通过其排队机制确定下一步要服务的队列。有以下2种排队方式。&lt;/p&gt;

&lt;p&gt;(1)严格优先队列(SPQ) 这是一种最简单的排队方式，它首先为最高优先级的队列进行服务，直到该队列为空，然后为下一个次高优先级队列服务，依此类推。这种方法的优势是高优先级业务总是在低优先级业务之前处理。但是，低优先级业务有可能被高优先级业务完全阻塞。&lt;/p&gt;

&lt;p&gt;(2)加权循环(WRR) 这种方法为所有业务队列服务，并且将优先权分配给较高优先级队列。在大多数情况下，相对低优先级，WRR将首先处理高优先级，但是当高优先级业务很多时，较低优先级的业务并没有被完全阻塞。&lt;/p&gt;

&lt;p&gt;Qos可以根据报文中的802.1Q判断优先级&lt;/p&gt;

&lt;p&gt;补充：现在的路由器一般均支持QoS。&lt;/p&gt;

&lt;p&gt;路由器上的QoS可以通过下面几种手段获得：&lt;/p&gt;

&lt;p&gt;1.通过大带宽得到&lt;/p&gt;

&lt;p&gt;在路由器上除增加接口带宽以外不作任何额外工作来保障QoS。由于数据通信没有相应公认的数学模型作保障，该方法只能粗略地使用经验值作估计。通常认为当带宽利用率到达50％以后就应当扩容，保证接口带宽利用率小于50％。&lt;/p&gt;

&lt;p&gt;2.通过端到端带宽预留实现&lt;/p&gt;

&lt;p&gt;该方法通过使用RSVP或者类似协议在全网范围内通信的节点间端到端预留带宽。该方法能保证QoS，但是代价太高，通常只在企业网或者私网上运行，在大网公网上无法实现。&lt;/p&gt;

&lt;p&gt;3.通过接入控制、拥塞控制和区分服务等方式得到&lt;/p&gt;

&lt;p&gt;该方式无法完全保证QoS。这能与增加接口带宽等方式结合使用，在一定程度上提供相对的QoS。&lt;/p&gt;

&lt;p&gt;4.通过MPLS流量工程得到&lt;/p&gt;

&lt;h2&gt;需要QoS的应用&lt;/h2&gt;


&lt;p&gt;流量约定（&lt;strong&gt;SLA&lt;/strong&gt;, &lt;strong&gt;Service Level Agreement&lt;/strong&gt;服务等级协议）给数据流设定优先级，以此在网络／协议层面上，根据相互商定的尺度，设定有保障的性能、通过量、延迟等界限。一些特定形式的网络数据流需要定义服务质量，例如：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;多媒体流要求有保障的通过量&lt;/li&gt;
    &lt;li&gt;IP电话需要严格的抖动和延迟限制&lt;/li&gt;
    &lt;li&gt;性命攸关的应用系统，例如远程外科手术要求有可靠保证的可用性（也称作&lt;em&gt;硬性　QoS&lt;/em&gt;）.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这些类型的服务被称为&lt;em&gt;非弹性&lt;/em&gt;，意思是它们需要固定的带宽才能运作--如果得到多余的带宽，它们也无法使用；如果得到较少的带宽，则根本无法工作。相形之下，弹性应用可以从多余的带宽中受益。&lt;/p&gt;

&lt;h2&gt;应用&lt;/h2&gt;


&lt;p&gt;QoS是网络与用户之间以及网络上互相通信的用户之间关于信息传输与共享的质的约定，例如，传输延迟允许时间、最小传输画面失真度以及声像同步等, 是用来解决网络延迟和阻塞等问题的一种技术。现在的路由器一般均支持QoS。QoS 是网络的一种安全机制, 是用来解决网络延迟和阻塞等问题的一种技术。在正常情况下，如果网络只用于特定的无时间限制的应用系统，并不需要QoS，比如 Web应用，或E-mail设置等。但是对关键应用和多媒体应用就十分必要。当网络过载或拥塞时，QoS 能确保重要业务量不受延迟或丢弃，同时保证网络的高效运行。&lt;/p&gt;

&lt;p&gt;在Internet等计算机网络上为用户提供高质量的QoS必须解决以下问题：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;QoS的分类与定义。对QoS进行分类和定义的目的是使网络可以根据不同类型的QoS进行管理和分配资源。例如 ，给实时服务分配较大的带宽和较多的CPU处理时间等，另一方面，对QoS进行分类定义也方便用户根据不同的应用提出QoS需求。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;准入控制和协商。即根据网络中资源的使用情况，允许用户进入网络进行多媒体信息传输并协商其QoS。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源预约。为了给用户提供满意的QoS，必须对端系统、路由器以及传输带宽等相应的资源进行预约，以确保这些资源不被其他应用所强用。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;资源调度与管理。对资源进行预约之后，是否能得到这些资源，还依赖于相应的资源调度与管理系统。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;目前的Internet仅提供尽力而为(best-effort service)的传送服务，业务量尽快传送，没有明确的时间和可靠性保障。随着网络多媒体技术的飞速发展，Internet上的多媒体应用层出不穷，如IP电话、视频会议、视频点播(VOD)、远程教育等多媒体实时业务、电子商务在Internet上传送等。Internet已逐步从单一的数据传送网向数据、语音、图像等多媒体信息的综合传输网演化。这些不同的应用需要有不同的Qos(quality of service)要求，Qos通常用带宽、时延、时延抖动和分组丢失率来衡量。各种应用对服务质量的需求在迅速增长。&lt;/p&gt;

&lt;p&gt;显然，现有的尽力传送服务已无法满足各种应用对网络传输质量的不同要求，需要Internet提供多种服务质量类型的业务。而尽力而为的服务仍将提供给那些只需要连通性的应用。&lt;/p&gt;

&lt;p&gt;服务质量Qos系指用来表示服务性能之属性的任何组合。为了使其具有价值，这些属性必须是可提供的、可管理的、可验证和计费的，而且在使用时它们必须是始终如一的、可预测的、有的属性甚至是起决定性作用的。为了满足各种用户应用的需要，构建对IP最优并具备各种服务质量机制的网络是完全必要的。专线服务、语音、文件传递、存储转发、交互式视频和广播视频是现有应用的一些例子。&lt;/p&gt;

&lt;h2&gt;关键指标&lt;/h2&gt;


&lt;p&gt;QoS的关键指标主要包括：可用性、吞吐量、时延、时延变化(包括抖动和漂移)和丢失。下面详细叙述。&lt;/p&gt;

&lt;p&gt;可用性&lt;/p&gt;

&lt;p&gt;是当用户需要时网络即能工作的时间百分比。可用性主要是设备可靠性和网络存活性相结合的结果。对它起作用的还有一些其他因素，包括软件稳定性以及网络演进或升级时不中断服务的能力。&lt;/p&gt;

&lt;p&gt;吞吐量&lt;/p&gt;

&lt;p&gt;是在一定时间段内对网上流量(或带宽)的度量。对IP网而言可以从帧中继网借用一些概念。根据应用和服务类型，服务水平协议(SLA)可以规定承诺信息速率(CIR)、突发信息速率(BIR)和最大突发信号长度。承诺信息速率是应该予以严格保证的，对突发信息速率可以有所限定，以在容纳预定长度突发信号的同时容纳从话音到视像以及一般数据的各种服务。一般讲，吞吐量越大越好。&lt;/p&gt;

&lt;p&gt;时延&lt;/p&gt;

&lt;p&gt;指一项服务从网络入口到出口的平均经过时间。许多服务，特别是话音和视像等实时服务都是高度不能容忍时延的。当时延超过200-250毫秒时，交互式会话是非常麻烦的。为了提供高质量话音和会议电视，网络设备必须能保证低的时延。&lt;/p&gt;

&lt;p&gt;产生时延的因素很多，包括分组时延、排队时延、交换时延和传播时延。传播时延是信息通过铜线、光纤或无线链路所需的时间，它是光速的函数。在任何系统中，包括同步数字系列(SDH)、异步传输模式（ATM）和弹性分组环路(RPR)，传播时延总是存在的。&lt;/p&gt;

&lt;p&gt;时延变化&lt;/p&gt;

&lt;p&gt;QoS流程是指同一业务流中不同分组所呈现的时延不同。高频率的时延变化称作抖动，而低频率的时延变化称作漂移。抖动主要是由于业务流中相继分组的排队等候时间不同引起的，是对服务质量影响最大的一个问题。某些业务类型，特别是话音和视像等实时业务是极不容忍抖动的。分组到达时间的差异将在话音或视像中造成断续。所有传送系统都有抖动，只要抖动落在规定容差之内就不会影响服务质量。利用缓存可以克服过量的抖动，但这将增加时延，造成其他问题。&lt;/p&gt;

&lt;p&gt;漂移是任何同步传输系统都有的一个问题。在SDH系统中是通过严格的全网分级定时来克服漂移的。在异步系统中，漂移一般不是问题。漂移会造成基群失帧，使服务质量的要求不能满足。&lt;/p&gt;

&lt;p&gt;丢包&lt;/p&gt;

&lt;p&gt;不管是比特丢失还是分组丢失，对分组数据业务的影响比对实时业务的影响都大。在通话期间，丢失一个比特或一个分组的信息往往用户注意不到。在视像广播期间，这在屏幕上可能造成瞬间的波形干扰，然后视像很快恢复如初。即便是用传输控制协议(TCP)传送数据也能处理丢失，因为传输控制协议允许丢失的信息重发。事实上，一种叫做随机早丢(RED)的拥塞控制机制在故意丢失分组，其目的是在流量达到设定门限时抑制TCP传输速率，减少拥塞，同时还使TCP流失去同步，以防止因速率窗口的闭合引起吞吐量摆动。但分组丢失多了，会影响传输质量。所以，要保持统计数字，当超过预定门限时就向网络管理人员告警。&lt;/p&gt;

&lt;h2&gt;现状及相关技术&lt;/h2&gt;


&lt;p&gt;现在，IP网络如何提供服务质量QoS支持这一问题现已成为业界关注的焦点。对于由QoS控制来实现QoS保证，国际上不同组织和团体提出了不同的控制机制和策略，比较著名的有：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ISO/OSI提出了基于ODP分布式环境的QoS控制，但至今仍只停留在只给出了用户层的QoS参数说明和变成接口阶段，具体实现QoS控制策略并未提出；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ATM论坛提出了QoS控制的策略和实现，ATM控制是“连接预定”型（connection and reservation），它的核心内容是在服务建立之前，通过接纳控制和资源预留来提供服务的QoS保证，而在服务交互的过程中，用户进程和网络要严格按照约定的QoS实现服务QoS保证；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;3.IETF组织也已经提出了多种服务模型和机制来满足对QoS的需求，其中比较典型的有：RFC2115，RFC2117以及1998、1999年提出的 RFC26xx系列中的综合业务模型（Int-Serv）、差分业务模型(differentiated services)、多协议标签MPLS技术(Multi-Protocol Label Switching)、流量工程(traffic engineering)和QoS路由(QoS-based routing)等均用于解决Internet网络的QoS控制和管理。&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/QoS&quot;&gt;http://zh.wikipedia.org/wiki/QoS&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.wxiu.com/wxjs/network/200907/15-6002.html&quot;&gt;http://article.wxiu.com/wxjs/network/200907/15-6002.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://article.wxiu.com/wxjs/network/200907/15-6001.html&quot;&gt;http://article.wxiu.com/wxjs/network/200907/15-6001.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>从十大经典故事中学管理</title>
   <link href="http://dreambt.github.com/Other/2011/06/04/learn-management-from-10-classic-tale"/>
   <updated>2011-06-04T10:56:01+08:00</updated>
   <id>http://dreambt.github.com/Other/2011/06/04/learn-management-from-10-classic-tale</id>
   <content type="html">&lt;div&gt;员工管理和激励是一个复杂的事情，有时让管理者摸不着头脑，甚至感到头疼。销售管理往往并非现场管理，遥控管理无形之中增加了管理的难度。轻松一下，看看以下的十个经典故事，也许你会从中受到启发。&amp;nbsp;

&lt;strong&gt;一、分工&lt;/strong&gt;

&lt;/div&gt;


&lt;div&gt;&lt;strong&gt; &lt;/strong&gt;
一位年轻的炮兵军官上任后，到下属部队视察操练情况，发现有几个部队操练时有一个共同的情况：在操练中，总有一个士兵自始至终站在大炮的炮筒下，纹丝不动。经过询问，得到的答案是：操练条例就是这样规定的。原来，条例因循的是用马拉大炮时代的规则，当时站在炮筒下的士兵的任务是拉住马的缰绳，防止大炮发射后因后座力产生的距离偏差，减少再次瞄准的时间。现在大炮不再需要这一角色了。但条例没有及时调整，出现了不拉马的士兵。这位军官的发现使他受到了国防部的表彰。&amp;nbsp;

[分析]管理的首要工作就是科学分工。只有每个员工都明确自己的岗位职责，才不会产生推委、扯皮等不良现象。如果公司象一个庞大的机器，那么每个员工就是一个个零件，只有他们爱岗敬业，公司的机器才能得以良性运转。公司是发展的，管理者应当根据实际动态情况对人员数量和分工及时做出相应调整。否则，队伍中就会出现“不拉马的士兵”。如果队伍中有人滥竽充数，给企业带来的不仅仅是工资的损失，而且会导致其他人员的心理不平衡，最终导致公司工作效率整体下降。

&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;二、标准&lt;/strong&gt;&amp;nbsp;

有一个小和尚担任撞钟一职，半年下来，觉得无聊之极，“做一天和尚撞一天钟”而已。有一天，主持宣布调他到后院劈柴挑水，原因是他不能胜任撞钟一职。小和尚很不服气地问：“我撞的钟难道不准时、不响亮？”老主持耐心地告诉他：“你撞的钟虽然很准时、也很响亮，但钟声空泛、疲软，没有感召力。钟声是要唤醒沉迷的众生，因此，撞出的钟声不仅要洪亮，而且要圆润、浑厚、深沉、悠远。”

[分析]本故事中的主持犯了一个常识性管理错误，“做一天和尚撞一天钟”是由于主持没有提前公布工作标准造成的。如果小和尚进入寺院的当天就明白撞钟的标准和重要性，我想他也不会因怠工而被撤职。工作标准是员工的行为指南和考核依据。缺乏工作标准，往往导致员工的努力方向与公司整体发展方向不统一，造成大量的人力和物力资源浪费。因为缺乏参照物，时间久了员工容易形成自满情绪，导致工作懈怠。制定工作标准尽量做到数字化，要与考核联系起来，注意可操作性。

&lt;strong&gt;三、体制&lt;/strong&gt;

有七个人住在一起，每天共喝一桶粥，显然粥每天都不够。一开始，他们抓阄决定谁来分粥，每天轮一个。于是乎每周下来，他们只有一天是饱的，就是自己分粥的那一天。后来他们开始推选出一个道德高尚的人出来分粥。强权就会产生腐败，大家开始挖空心思去讨好他，贿赂他，搞得整个小团体乌烟障气。然后大家开始组成三人的分粥委员会及四人的评选委员会，互相攻击扯皮下来，粥吃到嘴里全是凉的。最后想出来一个方法：轮流分粥，但分粥的人要等其它人都挑完后拿剩下的最后一碗。为了不让自己吃到最少的，每人都尽量分得平均，就算不平，也只能认了。大家快快乐乐，和和气气，日子越过越好。

管理的真谛在“理”不在“管”。管理者的主要职责就是建立一个象“轮流分粥，分者后取”那样合理的游戏规则，让每个员工按照游戏规则自我管理。游戏规则要兼顾公司利益和个人利益，并且要让个人利益与公司整体利益统一起来。责任、权利和利益是管理平台的三根支柱，缺一不可。缺乏责任，公司就会产生腐败，进而衰退；缺乏权利，管理者的执行就变成废纸；缺乏利益，员工就会积极性下降，消极怠工。只有管理者把“责、权、利”的平台搭建好，员工才能“八仙过海，各显其能”。

&lt;strong&gt;四、表率&lt;/strong&gt;

春秋晋国有一名叫李离的狱官，他在审理一件案子时，由于听从了下属的一面之辞，致使一个人冤死。真相大白后，李离准备以死赎罪，晋文公说：官有贵贱，罚有轻重，况且这件案子主要错在下面的办事人员，又不是你的罪过。李离说：“我平常没有跟下面的人说我们一起来当这个官，拿的俸禄也没有与下面的人一起分享。现在犯了错误，如果将责任推到下面的办事人员身上，我又怎么做得出来”。他拒绝听从晋文公的劝说，伏剑而死。

正人先正己，做事先做人。管理者要想管好下属必须以身作则。示范的力量是惊人的。不但要象先人李离那样勇于替下属承担责任，而且要事事为先、严格要求自己，做到“己所不欲，勿施于人”。一旦通过表率树立起在员工中的威望，将会上下同心，大大提高团队的整体战斗力。得人心者得天下，做下属敬佩的领导将使管理事半功倍。

&lt;strong&gt;五、竞争&lt;/strong&gt;

国外一家森林公园曾养殖几百只梅花鹿，尽管环境幽静，水草丰美，又没有天敌，而几年以后，鹿群非但没有发展，反而病的病，死的死，竟然出现了负增长。后来他们买回几只狼放置在公园里，在狼的追赶捕食下，鹿群只得紧张地奔跑以逃命。这样一来，除了那些老弱病残者被狼捕食外，其它鹿的体质日益增强，数量也迅速地增长着。

流水不腐，户枢不蠹。人天生有种惰性，没有竞争就会固步自封，躺在功劳簿上睡大觉。竞争对手就是追赶梅花鹿的狼，时刻让梅花鹿清楚狼的位置和同伴的位置。跑在前面的梅花鹿可以得到更好的食物，跑在最后的梅花鹿就成了狼的食物。按照市场规则，给予“头鹿”奖励，让“末鹿”被市场淘汰。

&lt;strong&gt;六、沟通&lt;/strong&gt;

美国知名主持人“林克莱特”一天访问一名小朋友，问他说：“你长大后想要当什么呀？”小朋友天真的回答：“我要当飞机的驾驶员！”林克莱特接着问：“如果有一天，你的飞机飞到太平洋上空所有引擎都熄火了，你会怎么办？”小朋友想了说：“我会先告诉坐在飞机上的人绑好安全带，然后我挂上我的降落伞跳出去。”当在现场的观众笑的东倒西歪时，林克莱特继续注视这孩子，想看他是不是自作聪明的家伙。没想到，接著孩子的两行热泪夺眶而出，这才使得林克莱特发觉这孩子的悲悯之情远非笔墨所能形容。于是林克莱特问他说：“为甚么要这么做？”小孩的答案透露出一个孩子真挚的想法：“我要去拿燃料，我还要回来！！”。

你真的听懂了手下的话了吗？你是不是也习惯性地用自己的权威打断手下的语言？我们经常犯这样的错误：在手下还没有来得及讲完自己的事情前，就按照我们的经验大加评论和指挥。反过头来想一下，如果你不是领导，你还会这么做吗？打断手下的语言，一方面容易做出片面的决策，另一方面使员工缺乏被尊重的感觉。时间久了，手下将再也没有兴趣向上级反馈真实的信息。反馈信息系统被切断，领导就成了“孤家寡人”，在决策上就成了“睁眼瞎”。与手下保持畅通的信息交流，将会使你的管理如鱼得水，以便及时纠正管理中的错误，制定更加切实可行的方案和制度。

&lt;strong&gt;七、指导&lt;/strong&gt;

有一回，日本歌舞伎大师勘弥扮演古代一位徒步旅行的百姓，他要上场之前故意解开自己的鞋带，试图表现这个百姓长途旅行的疲态。正巧那天有位记者到后台采访，看见了这一幕。等演完戏后，记者问勘弥：“你为什么不当时指教学生呢，他们并没有松散自己的鞋带呀。”勘弥回答说：“要教导学生演戏的技能，机会多的是，在今天的场合，最重要的是要让他们保持热情。”

[分析]提高员工素质和能力是提高管理水准的有效方式。学习有利于提高团队执行力，便于增强团队凝聚力。手把手的现场指导可以及时纠正员工的错误，是提高员工素质的重要形式之一。但是指导必须注重技巧，就象勘弥大师那样要保护员工的热情。管理者必须避免教训式指导，应当语重心长的激励员工提高自身业务素质。除了现场指导外，还可以综合运用培训、交流会、内部刊物、业务竞赛等多种形式，激发员工不断提高自身素质和业务水平，形成一个积极向上的学习型团队。

&lt;strong&gt;八、锻炼&lt;/strong&gt;

一个人在高山之巅的鹰巢里，抓到了一只幼鹰，他把幼鹰带回家，养在鸡笼里。这只幼鹰和鸡一起啄食、嬉闹和休息。它以为自己是一只鸡。这只鹰渐渐长大，羽翼丰满了，主人想把它训练成猎鹰，可是由于终日和鸡混在一起，它已经变得和鸡完全一样，根本没有飞的愿望了。主人试了各种办法，都毫无效果，最后把它带到山顶上，一把将它扔了出去。这只鹰像块石头似的，直掉下去，慌乱之中它拼命地扑打翅膀，就这样，它终于飞了起来！

[分析]每个人都希望用自己的能力来证明自身价值，手下也不例外。给他们更大的空间去施展自己的才华，是对他们最大的尊重和支持。不要害怕他们失败，给予适当的扶持和指点，放开你手中的“雄鹰”，让他们翱翔于更宽阔的天空。是个猴子就给他们座山折腾折腾，是条龙就给他们条大江大河扑腾扑腾。他们的成长，将为你的工作带来更大的贡献。他们的成长，将促使你更进一步。

&lt;strong&gt;九、发挥&lt;/strong&gt;

一位著名企业家在做报告。当听众咨询他最成功的做法时，他拿起粉笔在黑板上画了一个圈，只是并没有画圆满，留下一个缺口。他反问道：“这是什么？”“零”、“圈”、“未完成的事业”、“成功”，台下的听众七嘴八舌地答道。他对这些回答未置可否：“其实，这只是一个未画完整的句号。你们问我为什么会取得辉煌的业绩，道理很简单：我不会把事情做得很圆满，就像画个句号，一定要留个缺口，让我的下属去填满它。”

事必躬亲，是对员工智慧的扼杀，往往事与愿违。长此以往，员工容易形成惰性，责任心大大降低，把责任全推给管理者。情况严重者，会导致员工产生腻烦心理，即便工作出现错误也不情愿向管理者提出。何况人无完人，个人的智慧毕竟是有限而且片面的。为员工画好蓝图，给员工留下空间，发挥他们的智慧，他们会画的更好。多让员工参与公司的决策事务，是对他们的肯定，也是满足员工自我价值实现的精神需要。赋予员工更多的责任和权利，他们会取得让你意想不到的成绩。

&lt;strong&gt;十、鞭策&lt;/strong&gt;

拿破仑一次打猎的时候，看到一个落水男孩，一边拼命挣扎，一边高呼救命。这河面并不宽，拿破仑不但没有跳水救人，反而端起猎枪，对准落水者，大声喊到：你若不自己爬上来，我就把你打死在水中。那男孩见求救无用，反而增添了一层危险，便更加拼命地奋力自救，终于游上岸。

对待自觉性比较差的员工，一味的为他创造良好的软环境、去帮助他，并不一定让他感受到“萝卜”的重要，有时还离不开“大棒”的威胁。偶尔利用你的权威对他们进行威胁，会及时制止他们消极散漫的心态，激发他们发挥出自身的潜力。自觉性强的员工也有满足、停滞、消沉的时候，也有依赖性，适当的批评和惩罚能够帮助他们认清自我，重新激发新的工作斗志。

&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Win7启动过程及启动项修复</title>
   <link href="http://dreambt.github.com/Windows/2011/05/18/win7-boot-process-and-restoration"/>
   <updated>2011-05-18T19:55:13+08:00</updated>
   <id>http://dreambt.github.com/Windows/2011/05/18/win7-boot-process-and-restoration</id>
   <content type="html">&lt;p&gt;先让我们看一下win7的启动过程的常识：&lt;/p&gt;

&lt;p&gt;电脑加电后，首先是启动BIOS程序，BIOS自检完毕后，找到硬盘上的主引导记录MBR，MBR读取DPT（分区表），从中找出活动的主分区，然后读取活动主分区的PBR（分区引导记录，也叫dbr），PBR再搜寻分区内的启动管理器文件 BOOTMGR，在BOOTMGR被找到后，控制权就交给了BOOTMGR。BOOTMGR读取\boot\bcd文件（BCD=Boot Configuration Data）,也就是“启动配置数据”，简单地说，win7下的bcd文件就相当于xp下的boot.ini文件），如果存在着多个操作系统并且选择操作系统的等待时间不为0的话，这时就会在显示器上显示操作系统的选择界面。在我们选择启动WINDOWS7后，BOOTMGR就会去启动盘寻找WINDOWS\system32\winload.exe，然后通过winload.exe加载win7内核，从而启动整个win7系统。&lt;/p&gt;

&lt;p&gt;可以把这个过程简单地概括为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BIOS--&amp;gt;MBR--&amp;gt;DPT--&amp;gt;pbr--&amp;gt;Bootmgr--&amp;gt;bcd--&amp;gt;Winload.exe--&amp;gt;内核加载 --&amp;gt;整个win7系统&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本文就来说一说MBR--&amp;gt;DPT--&amp;gt;pbr--&amp;gt; Bootmgr--&amp;gt;bcd这一段可能出现的故障的解决。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.MBR出现问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;主要是mbr代码被改写，因为被改写的代码不同，所以出错信息也各不相同。比如我们装了win7与ubuntu双系 统，ubuntu改写了mbr，在我们把ubuntu所在的分区格式化后，既进不了win7，也进不了ubuntu，开机的时候会出现如图的错误 提示：&lt;/p&gt;

&lt;blockquote&gt;GRUB Loading stage1.5.

GRUB loading, please wait...

Error 22&lt;/blockquote&gt;


&lt;p&gt;解决的办法就是重写mbr。对于重写mbr，我们所熟知的是在dos下用fdisk /mbr命令进行重写。fdisk /mbr所重写的mbr与xp是兼容的，但是，与win7已经不那么兼容了。实践表明：用fdisk /mbr命令重写win7的mbr后，需要重建bcd，否则不能正常启动win7。有网友指出，这里面的原因是fdisk /mbr命令改写了mbr中的硬盘签名。一般的分区工具都是可以重写mbr的，比如diskgenius，它所重写的mbr与win7是兼容的。 也可以用bootrec /fixmbr命令重写。要运行 Bootrec.exe 工具，必须启动 Windows RE。为此，请按照下列步骤操作：&lt;/p&gt;

&lt;blockquote&gt;插入windows 7安装光盘，从光盘启动电脑，在光盘启动完成后，按下shift+f10键，调出cmd命令提示符。在cmd命令提示符中输入：bootrec /fixmbr回车。&lt;/blockquote&gt;


&lt;p&gt;这样也就重写了mbr。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.分区表存在问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统盘不是活动的主分区，这种情形只要用分区工具（比如diskgenius)把系统盘设为活动的主分区即可。
pbr出现问题，主要是pbr代码被改写，因为被改写的代码不同，所以出错信息也不相同。比如Win7系统的活动分区，却被写入了适合于XP的 pbr，这样开机的时候就会出现如图的提示：&lt;/p&gt;

&lt;blockquote&gt;NTLDR is missing

Press Ctrl+Alt+Del to restart&lt;/blockquote&gt;


&lt;p&gt;简单的解决办法就是用bootrec /fixboot命令重写pbr:&lt;/p&gt;

&lt;blockquote&gt;插入win7安装光盘，从光盘启动，在光盘启动完成后，按下shift+f10键，调出cmd命令提示符。在命令提示符中输入：bootrec /fixboot回车。&lt;/blockquote&gt;


&lt;p&gt;这样也就重建了活动分区的pbr。
这里面还有一个常用的命令也要提一下，这就是bootsect：&lt;/p&gt;

&lt;blockquote&gt;插入win7安装光盘，从光盘启动，在光盘启动完成后，按下shift+f10键，调出cmd命令提示符。在cmd命令提示符中输 入：bootsect /nt60 sys /mbr回车。&lt;/blockquote&gt;


&lt;p&gt;这个命令会改写活动分区的pbr，并同时会改写mbr，使得mbr和pbr适合于win7和vista。
bootsect.exe程序位于win7安装光盘的boot目录下，可以把这个文件提取出来，在xp下的命令行可以运行这个程序，也可以在 winpe下的命令行运行这个程序，因而这个程序在使用时很方便。而bootrec.exe命令的使用就没这么方便了。所以BOOTSECT命令被应用得更为广泛一些。
另外有一个要点需要指出，vista的安装光盘里面的boot文件夹也存在着这个小工具，但vista的bootsect命令没有/mbr参数，因而它只能改写pbr，而不能改写mbr，这是必须要注意的。实践表明：把一个硬盘的mbr清零，然后运行win7的bootsect命令，确实可以发现mbr被恢复正常。这也就表明了win7的bootsect命令的确能够重写mbr。
另外，bootsect命令也可以重写xp的mbr和pbr，而这也是bootrec命令所做不到的。xp的恢复控制台用fixmbr命令改写mbr,用 fixboot命令改写pbr。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.引导文件的问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一般可以用bcdboot命令重新写入引导文件：&lt;/p&gt;

&lt;blockquote&gt;插入win7安装光盘，从光盘启动，在光盘启动完成后，按下shift+f10键，调出cmd命令提示符。在命令提示符中输入：
bcdboot x:\windows /s x:&lt;/blockquote&gt;


&lt;p&gt;注意，这前一个x:是win7的windows文件夹所在的盘，一般是c:，如果你的不是c盘，请改为对应的盘符。这后一个x:是活动主分区的盘符所在，一般也是c盘。所以这个命令一般的写法是：bcdboot c:\windows /s c:
但需要注意，在windows re环境下所看到的盘符与你在win7下所看到的盘符未必一样。所以需要首先用dir /a命令确认各盘是否正确。
比如：&lt;/p&gt;

&lt;blockquote&gt;cd /d c:
dir /a&lt;/blockquote&gt;


&lt;p&gt;这两个命令的作用是，首先进入c:盘的根目录，然后显示c盘根目录下的所有文件和文件夹，根据所显示的文件或者文件夹，可以判断这个盘具体是你在 win7下所看到的哪一个盘。
win7的引导文件主要是bootmgr和boot文件夹里面的文件，而boot文件夹里面的文件主要是bcd文件。bcdboot命令会在指定 的分区内重新写入全部win7的引导文件。
如果只是bcd文件有问题，则可以用bootrec命令重建bcd:&lt;/p&gt;

&lt;blockquote&gt;插入win7安装光盘，从光盘启动，在光盘启动完成后，按下shift+f10键，调出cmd命令提示符。在命令提示符中输入：
bootrec /RebuildBcd&lt;/blockquote&gt;


&lt;p&gt;这个命令如果搜到没有写入bcd的win7或者vista的操作系统，会提示你是否写入，按提示输入Y也就会写入了的。
或者用bcdedit命令手动改写bcd，但操作要复杂得多。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;具体案例分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;案例一：开机的时候出现：&lt;/p&gt;

&lt;blockquote&gt;BOOTMGR is missing
press ctrl+alt+del to restart.&lt;/blockquote&gt;


&lt;p&gt;翻译成汉语就是：bootmgr缺失，按Ctrl + Alt + Del重新启动
这是很常见的故障。既然是bootmgr缺失，我们一般只要用bcdboot命令重建引导文件即可。
这种情形产生的原因，一般可能有：bootmgr文件确实没有了，这是最为常见的。一种则是由磁盘错误导致的，这种情形下，在winpe下运行一下 chkdsk /f命令也可能解决。有朋友使用 Diskeeper 对MFT碎片进行整理，开机的时候也出现了这个提示。估计可能是用DISKEEPER进行的MFT磁盘整理后，这或者是diskeeper的一个bug， 因而不建议用diskeeper进行mft碎片整理。
一位网友因为好奇。把C盘设成了活动的（active partition ）。是这样设置活动的：对计算机点右键-管理-硬盘管理。右键点C盘，设置为活动的。靠。怎么回事啊。
重启后居然无法启动！显示bootmgr is missing，Ctrl+Alt+Delete to restart。然后还是如此。
这是从网上找到的一个案例，分析可以得出结论。他所装的windows7应该存在着一个隐藏的“系统保留”分区，这个隐藏的系统保留分区才是真正的活动主 分区，而他的c盘则应该不是活动的。他把c盘设为活动，这也就意味着取消了“系统保留”分区的活动状态。但引导文件是在“系统保留”分区，而不是在c 盘，c盘变成了活动的主分区，mbr就会启动c盘的pbr，而c盘的pbr又会去c盘找bootmgr,但c盘没有bootmgr，所以出错也就是必然的 了。解决的办法其实只要简单地再把系统保留分区设为活动即可。
这位朋友制造了问题，但好象并没能最后解决问题。真所谓会者不难，难者不会。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;案例二：开机的时候出现：&lt;/p&gt;

&lt;blockquote&gt;BOOTMGR is compressed
Press Ctrl+Alt+Del to restart&lt;/blockquote&gt;


&lt;p&gt;翻译成汉语就是：
bootmgr被压缩，按Ctrl + Alt + Del重新启动
这种情形产生的原因是因为对系统盘进行了压缩。奇怪的是，对于这种情形，我们用bcdboot命令重建引导文件却并不能解决。
但是，我们可以运行命令：compact /u /a /f /i /s c:*
这样可以使得问题得到解决。compact程序位于windows\system32文件夹下，所以我们要先用CD命令进入windows\system32目录。这里是假设c:盘是bootmgr所在的盘，如果不是，要改为对应的盘符。
网上有朋友用这个命令的时候并没有解决问题，原因则在于，这位朋友所运行的命令是：compact /u /a /f /i /s c:\
没有后面这个＊，所以命令并没有实现运行者的目的。从命令本身所提供的帮助说明来看，这个＊似乎是没有必要的，但实际操作表明，这个＊是必须的。
这个命令会把已经压缩的C盘文件完全解压，真所谓解铃还須系铃人。
注意，只运行命令：compact /u /a /f /i c:\bootmgr
并不能解决问题。
有网友发现，运行“Bootrec.exe /fixmbr、Bootrec /fixboot&quot;然后重启，这样可以解决问题。测试表明，其实只需要运行Bootrec /fixboot这一个命令即可。这是另类的解决的办法。猜想可能是，对驱动压缩后，PBR中的BPB表并没有随之修改，所以BPB表中所记录的分区信息 与实际的分区信息不一致。运行Bootrec /fixboot命令后重写了bpb，这样就使得二者变为了一致。&lt;/p&gt;

&lt;p&gt;实践表明：用bootsect命令也能实现对这个问题的解决。
有网友发贴，说是装了xp与vista双系统，启动vista系统出现了BOOTMGR is compressed ，于是他在xp下取消了系统盘的压缩状态。但这位网友的话未必可信，因为如果ntldr也被压缩了的话，则xp启动的时候会出现：&lt;/p&gt;

&lt;blockquote&gt;ntldr is compressed
Press Ctrl+Alt+Del to restart&lt;/blockquote&gt;


&lt;p&gt;除非这位朋友只压缩了bootmgr，而没有压缩ntldr,但这一般不太可能。这种压缩一般是对整个盘进行压缩的时候产生的，如果压缩指定文件的话，一 般不会有人去压缩bootmgr和ntldr的。实践表明，在win7下，即便指定对整个的系统盘进行压缩，一般也不能压缩bootmgr的，会 提示拒绝访问，但是，在开机的时候仍会出现出错提示：&lt;/p&gt;

&lt;blockquote&gt;bootmgr is compressed&lt;/blockquote&gt;


&lt;p&gt;案例三：
先装的win7，后装的linux,在linux系统出问题后，既进不了linux,也进不了win7，这里面的原因是mbr和活动分区 的pbr被改写。只要重建mbr和活动分区的pbr，也就可以进入win7了。最简单的办法是用bootsect命令解决：&lt;/p&gt;

&lt;blockquote&gt;bootsect /nt60 sys /mbr&lt;/blockquote&gt;


&lt;p&gt;案例四：
先装的win7，后装的xp,没有了win7的启动项：
这个需要三步解决问题：
一、用bcdboot命令重建win7的引导文件。
二、用bootsect命令恢复win7的mbr和pbr
三、进入win7后，用bcdedit命令添加xp的启动项。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>开启本地DNS缓存来加速网页浏览</title>
   <link href="http://dreambt.github.com/Linux/2011/05/12/open-local-dns-cache-to-speed-up-web-browsing"/>
   <updated>2011-05-12T15:57:08+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/05/12/open-local-dns-cache-to-speed-up-web-browsing</id>
   <content type="html">&lt;p&gt;如果你觉得DNS解析慢，或者上网慢的话，可以尝试一下：&lt;/p&gt;

&lt;p&gt;﻿安装dnsmasq：&lt;/p&gt;

&lt;blockquote&gt;sudo apt-get install dnsmasq&lt;/blockquote&gt;


&lt;p&gt;修改配置文件：&lt;/p&gt;

&lt;blockquote&gt;sudo gedit /etc/dhcp/dhclient.conf&lt;/blockquote&gt;


&lt;p&gt;找到下面的内容并将前面的#去掉&lt;/p&gt;

&lt;blockquote&gt;#prepend domain-name-servers 127.0.0.1&lt;/blockquote&gt;


&lt;p&gt;保存退出。
接着就是添加本地DNS：&lt;/p&gt;

&lt;blockquote&gt;sudo gedit /etc/resolv.conf&lt;/blockquote&gt;


&lt;p&gt;在最下面加上&lt;/p&gt;

&lt;blockquote&gt;nameserver 127.0.0.1&lt;/blockquote&gt;


&lt;p&gt;当然你还可以加别的DNS服务，比如谷歌的8.8.8.8等，保存退出。
最后再重启一下服务就可以了：&lt;/p&gt;

&lt;blockquote&gt;sudo /etc/init.d/dnsmasq restart&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>服务器返回状态码图解</title>
   <link href="http://dreambt.github.com/Web Design/2011/05/11/server-returns-status-code"/>
   <updated>2011-05-11T10:33:14+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2011/05/11/server-returns-status-code</id>
   <content type="html">&lt;p&gt;HTTP 400 – 请求无效
HTTP 401.1 – 未授权：登录失败
HTTP 401.2 – 未授权：服务器配置问题导致登录失败
HTTP 401.3 – ACL 禁止访问资源
HTTP 401.4 – 未授权：授权被筛选器拒绝
HTTP 401.5 – 未授权：ISAPI 或 CGI 授权失败
HTTP 403 – 禁止访问
HTTP 403 – 对 Internet 服务管理器 (HTML) 的访问仅限于 Localhost
HTTP 403.1 禁止访问：禁止可执行访问
HTTP 403.2 – 禁止访问：禁止读访问
HTTP 403.3 – 禁止访问：禁止写访问
HTTP 403.4 – 禁止访问：要求 SSL
HTTP 403.5 – 禁止访问：要求 SSL 128
HTTP 403.6 – 禁止访问：IP 地址被拒绝
HTTP 403.7 – 禁止访问：要求客户证书
HTTP 403.8 – 禁止访问：禁止站点访问
HTTP 403.9 – 禁止访问：连接的用户过多
HTTP 403.10 – 禁止访问：配置无效
HTTP 403.11 – 禁止访问：密码更改
HTTP 403.12 – 禁止访问：映射器拒绝访问
HTTP 403.13 – 禁止访问：客户证书已被吊销
HTTP 403.15 – 禁止访问：客户访问许可过多
HTTP 403.16 – 禁止访问：客户证书不可信或者无效
HTTP 403.17 – 禁止访问：客户证书已经到期或者尚未生效
HTTP 404.1 – 无法找到 Web 站点
HTTP 404 – 无法找到文件
HTTP 405 – 资源被禁止
HTTP 406 – 无法接受
HTTP 407 – 要求代理身份验证
HTTP 410 – 永远不可用
HTTP 412 – 先决条件失败
HTTP 414 – 请求 – URI 太长&lt;/p&gt;

&lt;p&gt;HTTP 500 – 内部服务器错误
HTTP 500.100 – 内部服务器错误 – ASP 错误
HTTP 500-11 服务器关闭
HTTP 500-12 应用程序重新启动
HTTP 500-13 – 服务器太忙
HTTP 500-14 – 应用程序无效
HTTP 500-15 – 不允许请求 global.asa
Error 501 – 未实现
HTTP 502 – 网关错误
&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/B3FpEc5W/syTtl.jpg&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;2061&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>开源软件许可证总览</title>
   <link href="http://dreambt.github.com/Linux/2011/05/05/overviewof-open-source-software-license"/>
   <updated>2011-05-05T12:49:34+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/05/05/overviewof-open-source-software-license</id>
   <content type="html">&lt;p&gt;你 知道这个世上有多少种开源软件的许可证吗？GPL，BSD，MIT，Apache？GUN上有个网页，上面记录了几乎所有的开源软件的许可证，有开源的， 有商用的，有软件的，有文档的，多得你都不想看了，天杀的，程序员们还真能鼓捣啊。不过，主流的也就几种——GPL、BSD、MIT、Mozilla、 Apache等等。&lt;/p&gt;

&lt;p&gt;那么，你知道怎么区别他们吧？怎么选择他们吗？这里有一张比较复图。
&lt;img src=&quot;http://pic.yupoo.com/dreambt/B2LIOxv2/medium.jpg&quot; alt=&quot;&quot; /&gt;
下面是另一个图，这个图来自这里，这个图并不恶搞，但其非常简单地说明了如何选择一个开源的许可证：
&lt;img src=&quot;http://pic.yupoo.com/dreambt/B2LIOJLg/medium.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>J2EE系统各个层次的编码方式</title>
   <link href="http://dreambt.github.com/J2EE/2011/05/02/all-levels-of-encoding-in-j2ee-system"/>
   <updated>2011-05-02T11:26:45+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2011/05/02/all-levels-of-encoding-in-j2ee-system</id>
   <content type="html">&lt;p&gt;Web容器默认的编码方式：ISO-8859-1 (解析POST数据)&lt;/p&gt;

&lt;p&gt;JDBC驱动程序默认的编码方式：ISO-8859-1 所以我们将其设置为GBK或GB2312&lt;/p&gt;

&lt;p&gt;Java内部使用的字符集：Unicode&lt;/p&gt;

&lt;p&gt;操作系统：GBK&lt;/p&gt;

&lt;p&gt;浏览器发送请求(传输URI)：UTF-8&lt;/p&gt;

&lt;p&gt;javascript：UTF-8（沿用java的字符处理方式，内部是使用unicode来处理所有字符的）&lt;/p&gt;

&lt;p&gt;当从Unicode编码向某个字符集转换时，如果在该字符集中没有对应的编码，则得到0x3f(即？)&lt;/p&gt;

&lt;p&gt;从其他字符集(比如GBK)向Unicode编码转换时，如果这个二进制数在该字符集(GBK)中没有标识任何的字符，则得到的结果是0xfffd&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;使用Java从控制台读取中文并向控制台输出的过程：&lt;/p&gt;

&lt;p&gt;GBK编码 Unicode编码 GBK编码&lt;/p&gt;

&lt;p&gt;内存中使用的是Unicode编码&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu下Grub2修复详细步骤</title>
   <link href="http://dreambt.github.com/Linux/2011/04/29/ubuntu-grub2-restoration"/>
   <updated>2011-04-29T22:21:46+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/04/29/ubuntu-grub2-restoration</id>
   <content type="html">&lt;p&gt;有没有重装双系统之后找不到启动项的经历？&lt;/p&gt;

&lt;p&gt;有没有进入Grub修复模式却不知道用什么命令修复启动项？&lt;/p&gt;

&lt;p&gt;好吧，看了本文也许你就会留下幸福的泪水，好吧，废话少说。&lt;/p&gt;

&lt;h2&gt;一、开机提示grub&amp;gt;或者还有Grub界面请尝试&lt;/h2&gt;


&lt;p&gt;用工具盘启动，在grub菜单上按c进入命令行状态
在grub&amp;gt;提示符下输入
grub&amp;gt;find /boot/grub/core.img (有/boot分区的用find /grub/core.img)
系统会显示(hdx,y) (查找到的分区号），然后输入
grub&amp;gt;root (hdx,y)
grub&amp;gt;kernel /boot/grub/core.img (/boot分区的用 kernel /grub/core.img)
grub&amp;gt;boot
执行boot后能转入grub2菜单，重启ubuntu后，再在ubuntu终端下执行
$sudo grub-install /dev/sda
(或sdb，sdc等，根据第几硬盘而定）修复grub
注意：如果ubuntu的启动分区使用ext4格式，要有支持ext4格式的grub才能修复&lt;/p&gt;

&lt;h2&gt;二、上面的方法不可以的话，就用Live CD吧～&lt;/h2&gt;


&lt;p&gt;用ubuntu9.10的liveCD试用ubuntu启动后，打开终端
假如你的ubuntu的 / 分区是sda9，又假如 /boot分区是 sda6，在终端下输入
$sudo -i
$mount /dev/sda7 /mnt
$mount /dev/sda6 /mnt/boot （如果没 /boot 单独分区这步跳过）
$grub-install --root-directory=/mnt/ /dev/sda
和前面一样，要装入第二硬盘的把sda改为sdb
修复后无法引导windows，可以用下面的方法解决：
进入ubuntu系统，打开终端，重建grub列表
$sudo update-grub
重新写入第一分区mbr
$sudo grub-install /dev/sda
如果想修改启动顺序，可以修改/boot/grub目录下的grub.cfg文件
注意此文件不可写的，先执行一下命令
$sudo chmod +w /boot/grub/grub.cfg
然后再执行
$sudo gedit /boot/grub/grub.cfg
修改，类似于grub1的menu.lst修改Grub rescue模式
rescue模式下可使用的命令有：set，ls，insmod，root，prefix(设置启动路径)
ls --列出分区
ls (hd0,8)/ --查看(hd0,8)分区根目录
找到grub目录，然后继续
grub rescue&amp;gt;root=(hd0,x)
grub rescue&amp;gt;prefix=/boot/grub --(grub的目录)
grub rescue&amp;gt;set root=(hd0,x)
grub rescue&amp;gt;set prefix=(hd0,x)/boot/grub
grub rescue&amp;gt;insmod normal
grub&amp;gt;normal --------若出现启动菜单，按c进入命令行模式
grub&amp;gt;linux /boot/vmlinuz root=/dev/sdax
grub&amp;gt;initrd /boot/initrd.img
grub&amp;gt;boot
完成
进入系统后，更新GRUB或重装GRUB:
更新：sudo update-grub
重装：sudo grub-install /dev/xxx (这儿的xxx是sda或者sdb)&lt;/p&gt;

&lt;h2&gt;三、如果还不行，不用重装系统的最后一招了&lt;/h2&gt;


&lt;p&gt;&lt;strong&gt;详细步骤1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Boot to the LiveCD Desktop.&lt;/p&gt;

&lt;p&gt;Open a terminal – Applications, Accessories, Terminal.&lt;/p&gt;

&lt;p&gt;Determine your normal system partition – (the switch is a lowercase “L”)&lt;/p&gt;

&lt;p&gt;sudo fdisk -l&lt;/p&gt;

&lt;p&gt;If you aren’t sure, rundf -Th . Look for the correct disk size and ext3 or ext4 format.&lt;/p&gt;

&lt;p&gt;Mount your normal system partition:&lt;/p&gt;

&lt;p&gt;Substitute the correct partition: sda1, sdb5, etc.&lt;/p&gt;

&lt;p&gt;sudo mount /dev/sdXX /mnt # Example: sudo mount /dev/sda1 /mnt&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细步骤2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Only if you have a separate boot partition :&lt;/p&gt;

&lt;p&gt;sdYY is the /boot partition designation (examply sdb3)&lt;/p&gt;

&lt;p&gt;sudo mount /dev/sdYY /mnt/boot&lt;/p&gt;

&lt;p&gt;Mount devices:sudo mount --bind /dev/ /mnt/dev&lt;/p&gt;

&lt;p&gt;To ensure that only the grub utilities from the LiveCD get executed, mount /usrsudo mount --bind /usr/ /mnt/usr&lt;/p&gt;

&lt;p&gt;mount proc filesystemsudo mount --bind /proc/ /mnt/proc&lt;/p&gt;

&lt;p&gt;Chroot into your normal system device:sudo chroot /mnt&lt;/p&gt;

&lt;p&gt;If there is no /boot/grub/grub.cfg or it’s not correct, create one usingupdate-grub&lt;/p&gt;

&lt;p&gt;Reinstall GRUB 2:&lt;/p&gt;

&lt;p&gt;Substitute the correct device – sda, sdb, etc. Do not specify a partition number.&lt;/p&gt;

&lt;p&gt;grub-install /dev/sdX&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细步骤3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Verify the install (use the correct device, for example sda . Do not specify a partition): sudo grub-install --recheck /dev/sdX&lt;/p&gt;

&lt;p&gt;Exit chroot : CTRL-D on keyboard&lt;/p&gt;

&lt;p&gt;Unmount devices:sudo umount /mnt/dev&lt;/p&gt;

&lt;p&gt;If you mounted a separate /boot partition:sudo umount /mnt/boot&lt;/p&gt;

&lt;p&gt;Unmount last device:sudo umount /mnt&lt;/p&gt;

&lt;p&gt;Reboot.reboot&lt;/p&gt;

&lt;p&gt;Post-Restoration Commands&lt;/p&gt;

&lt;p&gt;Once the user can boot to a working system, try to determine why the system failed to boot.&lt;/p&gt;

&lt;p&gt;The following commands may prove useful in locating and/or fixing the problem.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;详细步骤4&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To refresh the available devices and settings in /boot/grub/grub.cfg&lt;/p&gt;

&lt;p&gt;sudo update-grub&lt;/p&gt;

&lt;p&gt;To look for the bootloader location.&lt;/p&gt;

&lt;p&gt;grub-probe -t device /boot/grub&lt;/p&gt;

&lt;p&gt;To install GRUB 2 to the sdX partition’s MBR (sda, sdb, etc.)&lt;/p&gt;

&lt;p&gt;sudo grub-install /dev/sdX&lt;/p&gt;

&lt;p&gt;To recheck the installation. (sda, sdb, etc.) sudo grub-install --recheck /dev/sdX&lt;/p&gt;

&lt;p&gt;Please check the following link for further details.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>用MD5做散列函数的新Base64算法</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/27/md5-based-base64-algorithm"/>
   <updated>2011-04-27T21:03:38+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/27/md5-based-base64-algorithm</id>
   <content type="html">&lt;p&gt;吃完晚饭没事，随便写了点东西，没想到弄巧成拙，写出来一堆代码，仁者见仁智者见智。大家拿去用吧，o(∩_∩)o 哈哈~&lt;/p&gt;

&lt;p&gt;[code]
public class WL {
private int base = 63;
private String base64 = &quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_&quot;;&lt;/p&gt;

&lt;p&gt;public String getWL(String url) {
String hex = MD5.getMD5(url.getBytes());
int hexLen = hex.length();
int subHexLen = hexLen / 8;
StringBuffer result = new StringBuffer();
for (int i = 0; i &amp;lt; subHexLen; ++i) {
String subHex = hex.substring(8 * i, 8 * i + 7);
Long num = 0x3FFFFFFF &amp;amp; Long.parseLong(subHex, 16);
for (int j = 0; j &amp;lt; 5; ++j) {
Long val = 0x0000003F &amp;amp; num;
result.append(base64.charAt(val.intValue()));
num = num &amp;gt;&amp;gt; 6;
}
result.append(&quot;|&quot;);
}
return result.toString().substring(0, 23);
}&lt;/p&gt;

&lt;p&gt;public static void main(String[] args) {
WL wl = new WL();
System.out.println(wl.getWL(&quot;http://www.im47.net/&quot;));
}
}
[/code]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(10) CART: 分类与回归树</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/21/data-mining-classical-algorithm-10-cart"/>
   <updated>2011-04-21T19:41:19+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/21/data-mining-classical-algorithm-10-cart</id>
   <content type="html">&lt;p&gt;如果一个人必须去选择在很大范围的情形下性能都好的、同时不需要应用开发者付出很多的努力并且易于被终端用户理解的分类技术的话，那么Brieman, Friedman, Olshen和Stone（1984）提出的分类树方法是一个强有力的竞争者。我们将首先讨论这个分类的过程，然后在后续的节中我们将展示这个过程是如何被用来预测连续的因变量。Brieman等人用来实现这些过程的程序被称为分类和回归树（CART, Classification and Regression Trees）方法。&lt;/p&gt;

&lt;p&gt;分类树
在分类树下面有两个关键的思想。第一个是关于递归地划分自变量空间的想法；第二个想法是用验证数据进行剪枝。&lt;/p&gt;

&lt;p&gt;递归划分
让我们用变量y表示因变量（分类变量），用x1, x2, x3,...,xp表示自变量。通过递归的方式把关于变量x的p维空间划分为不重叠的矩形。这个划分是以递归方式完成的。首先，一个自变量被选择，比如xi和xi的一个值si，比方说选择si把p维空间为两部分：一部分是p维的超矩形，其中包含的点都满足xi&amp;lt;=si，另一个p维超矩形包含所有的点满足xi&amp;gt;si。接着，这两部分中的一个部分通过选择一个变量和该变量的划分值以相似的方式被划分。这导致了三个矩形区域（从这里往后我们把超矩形都说成矩形）。随着这个过程的持续，我们得到的矩形越来越小。这个想法是把整个x空间划分为矩形，其中的每个小矩形都尽可能是同构的或“纯”的。“纯”的意思是（矩形）所包含的点都属于同一类。我们认为包含的点都只属于一个类（当然，这不总是可能的，因为经常存在一些属于不同类的点，但这些点的自变量有完全相同的值）。&lt;/p&gt;

&lt;p&gt;更多内容参阅：&lt;/p&gt;

&lt;p&gt;http://www.core.org.cn/NR/rdonlyres/Sloan-School-of-Management/15-062Data-MiningSpring2003/338F02AD-0DD8-4199-8727-35FCF5A15B57/0/L3ClassTrees.pdf&lt;/p&gt;

&lt;p&gt;http://www.cqvip.com/onlineread/onlineread.asp?ID=28180864&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(9) 朴素贝叶斯分类器 Naive Bayes</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/20/data-mining-classical-algorithm-9-naive-bayes"/>
   <updated>2011-04-20T19:40:41+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/20/data-mining-classical-algorithm-9-naive-bayes</id>
   <content type="html">&lt;h1&gt;贝叶斯分类器&lt;/h1&gt;


&lt;p&gt;贝叶斯分类器的分类原理是通过某对象的先验概率，利用贝叶斯公式计算出其后验概率，即该对象属于某一类的概率，选择具有最大后验概率的类作为该对象所属的类。目前研究较多的贝叶斯分类器主要有四种，分别是：Naive Bayes、TAN、BAN和GBN。
贝叶斯网络是一个带有概率注释的有向无环图，图中的每一个结点均表示一个随机变量,图中两结点 间若存在着一条弧，则表示这两结点相对应的随机变量是概率相依的，反之则说明这两个随机变量是条件独立的。网络中任意一个结点X 均有一个相应的条件概率表(Conditional Probability Table，CPT)，用以表示结点X 在其父结点取各可能值时的条件概率。若结点X 无父结点,则X 的CPT 为其先验概率分布。贝叶斯网络的结构及各结点的CPT 定义了网络中各变量的概率分布。
贝叶斯分类器是用于分类的贝叶斯网络。该网络中应包含类结点C，其中C 的取值来自于类集合( c1 , c2 , ... , cm)，还包含一组结点X = ( X1 , X2 , ... , Xn)，表示用于分类的特征。对于贝叶斯网络分类器，若某一待分类的样本D，其分类特征值为x = ( x1 , x2 , ... , x n) ，则样本D 属于类别ci 的概率P( C = ci | X1 = x1 , X2 = x 2 , ... , Xn = x n) ，( i = 1 ,2 , ... , m) 应满足下式：
P( C = ci | X = x) = Max{ P( C = c1 | X = x) , P( C = c2 | X = x ) , ... , P( C = cm | X = x ) }
而由贝叶斯公式：
P( C = ci | X = x) = P( X = x | C = ci) * P( C = ci) / P( X = x)
其中，P( C = ci) 可由领域专家的经验得到,而P( X = x | C = ci) 和P( X = x) 的计算则较困难。
应用贝叶斯网络分类器进行分类主要分成两阶段。第一阶段是贝叶斯网络分类器的学习，即从样本数 据中构造分类器，包括结构学习和CPT 学习；第二阶段是贝叶斯网络分类器的推理，即计算类结点的条件概率，对分类数据进行分类。这两个阶段的时间复杂性均取决于特征值间的依赖程度，甚至可以是 NP 完全问题，因而在实际应用中，往往需要对贝叶斯网络分类器进行简化。根据对特征值间不同关联程度的假设，可以得出各种贝叶斯分类器，Naive Bayes、TAN、BAN、GBN 就是其中较典型、研究较深入的贝叶斯分类器。&lt;/p&gt;

&lt;h1&gt;朴素贝叶斯&lt;/h1&gt;


&lt;p&gt;分类是将一个未知样本分到几个预先已知类的过程。数据分类问题的解决是一个两步过程：第一步,建立一个模型，描述预先的数据集或概念集。通过分析由属性 描述的样本（或实例，对象等）来构造模型。假定每一个样本都有一个预先定义的类，由一个被称为类标签的属性确定。为建立模型而被分析的数据元组形成训练数 据集，该步也称作有指导的学习。
在众多的分类模型中，应用最为广泛的两种分类模型是决策树模型(Decision Tree Model)和&lt;strong&gt;朴素贝叶斯模型&lt;/strong&gt;（Naive Bayesian Model，NBC）。决策树模型通过构造树来解决分类问题。首先利用训练数据集来构造一棵决策树，一旦树建立起来，它就可为未知样本产生一个分类。在分 类问题中使用决策树模型有很多的优点，决策树便于使用，而且高效；根据决策树可以很容易地构造出规则，而规则通常易于解释和理解；决策树可很好地扩展到大 型数据库中，同时它的大小独立于数据库的大小；决策树模型的另外一大优点就是可以对有许多属性的数据集构造决策树。决策树模型也有一些缺点，比如处理缺失 数据时的困难，过度拟合问题的出现，以及忽略数据集中属性之间的相关性等。
和决策树模型相比，&lt;strong&gt;朴素贝叶斯模型&lt;/strong&gt;发源于古典数学理论，有着坚实的数学基础，以 及稳定的分类效率。同时，NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。理论上，NBC模型与其他分类方法相比具有最小的误差率。 但是实际上并非总是如此，这是因为NBC模型假设属性之间相互独立，这个假设在实际应用中往往是不成立的，这给NBC模型的正确分类带来了一定影响。在属 性个数比较多或者属性之间相关性较大时，NBC模型的分类效率比不上决策树模型。而在属性相关性较小时，NBC模型的性能最为良好。&lt;/p&gt;

&lt;h2&gt;朴素贝叶斯模型：&lt;/h2&gt;

&lt;p&gt;Vmap=arg max P( Vj | a1,a2...an)
Vj属于V集合
其中Vmap是给定一个example,得到的最可能的目标值.
其中a1...an是这个example里面的属性.&lt;/p&gt;

&lt;h2&gt;这里面,Vmap目标值,就是后面计算得出的概率最大的一个.所以用max 来表示&lt;/h2&gt;

&lt;p&gt;贝叶斯公式应用到 P( Vj | a1,a2...an)中.
可得到 Vmap= arg max P(a1,a2...an | Vj ) P( Vj ) / P (a1,a2...an)
又因为朴素贝叶斯分类器默认a1...an他们互相独立的.
所以P(a1,a2...an)对于结果没有用处. [因为所有的概率都要除同一个东西之后再比较大小,最后结果也似乎影响不大]
可得到Vmap= arg max P(a1,a2...an | Vj ) P( Vj )
然后
&quot;朴素贝叶斯分类器基于一个简单的假定：给定目标值时属性之间相互条件独立。换言之。该假定说明给定实力的目标值情况下。观察到联合的a1,a2...an的概率正好是对每个单独属性的概率乘积： P(a1,a2...an | Vj ) = &lt;strong&gt;Π&lt;/strong&gt; i P( ai| Vj )
....
朴素贝叶斯分类器：Vnb =arg max P( Vj ) Π i P ( ai | Vj )
&quot;
Vnb = arg max P ( Vj )
此处Vj ( yes | no )，对应天气的例子。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(8) kNN: k-nearest neighbor classification</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/19/data-mining-classical-algorithm-8-knn-k-nearest-neighbor-classification"/>
   <updated>2011-04-19T19:39:59+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/19/data-mining-classical-algorithm-8-knn-k-nearest-neighbor-classification</id>
   <content type="html">&lt;h1&gt;邻近算法&lt;/h1&gt;


&lt;div&gt;&lt;a href=&quot;http://imgsrc.baidu.com/baike/pic/item/b74124f3c4b8a34e352accfb.jpg&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201004/28/0_1272437957U444.gif&quot; alt=&quot;&quot; /&gt;
&lt;/a&gt;
&lt;h3&gt;KNN算法的决策过程&lt;/h3&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;k-Nearest Neighbor algorithm&lt;/strong&gt;
右图中，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如果K=3，由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类，如果K=5，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。
K最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相 似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决 策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 KNN方法虽然从原理上也依赖于极限定理，但在类别决策时，只与极少量的相邻样本有关。由于KNN方法主要靠周围有限的邻近的样本，而不是靠判别类域的方 法来确定所属类别的，因此对于类域的交叉或重叠较多的待分样本集来说，KNN方法较其他方法更为适合。
KNN算法不仅可以用于分类，还可以用于回归。通过找出一个样本的k个最近邻居，将这些邻居的属性的平均值赋给该样本，就可以得到该样本的属性。更有用的方法是将不同距离的邻居对该样本产生的影响给予不同的权值(weight)，如权值与距离成正比。
该算法在分类时有个主要的不足是，当样本不平衡时，如一个类的样本容量很大，而其他类样本容量 很小时，有可能导致当输入一个新样本时，该样本的K个邻居中大容量类的样本占多数。因此可以采用权值的方法（和该样本距离小的邻居权值大）来改进。该方法 的另一个不足之处是计算量较大，因为对每一个待分类的文本都要计算它到全体已知样本的距离，才能求得它的K个最近邻点。目前常用的解决方法是事先对已知样 本点进行剪辑，事先去除对分类作用不大的样本。该算法比较适用于样本容量比较大的类域的自动分类，而那些样本容量较小的类域采用这种算法比较容易产生误 分。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(7) AdaBoost</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/18/data-mining-classical-algorithm-7-adaboost"/>
   <updated>2011-04-18T19:39:49+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/18/data-mining-classical-algorithm-7-adaboost</id>
   <content type="html">&lt;p&gt;Adaboost是一种迭代算法，其核心思想是针对同一个训练集训练不同的分类器(弱分类器)，然后把这些弱分类器集合起来，构成一个更强的最终分类器 (强分类器)。其算法本身是通过改变数据分布来实现的，它根据每次训练集之中每个样本的分类是否正确，以及上次的总体分类的准确率，来确定每个样本的权 值。将修改过权值的新数据集送给下层分类器进行训练，最后将每次训练得到的分类器最后融合起来，作为最后的决策分类器。使用adaboost分类器可以排 除一些不必要的训练数据特徵，并将关键放在关键的训练数据上面。
目前，对adaboost算法的研究以及应用大多集中于分类问题，同时近年也出 现了一些在回归问题上的应用。就其应用adaboost系列主要解决了: 两类问题、 多类单标签问题、多类多标签问题、大类单标签问题，回归问题。它用全部的训练样本进行学习。
该算法其实是一个简单的弱分类算法提升过程，这个过程通过不断的训练，可以提高对数据的分类能力。整个过程如下所示：
1. 先通过对N个训练样本的学习得到第一个弱分类器 ；
2. 将 分错的样本和其他的新数据一起构成一个新的N个的训练样本，通过对这个样本的学习得到第二个弱分类器 ；
3. 将 和 都分错了的样本加上其他的新样本构成另一个新的N个的训练样本，通过对这个样本的学习得到第三个弱分类器 ；
4. 最终经过提升的强分类器 。即某个数据被分为哪一类要通过 ， ……的多数表决。
2.3 Adaboost(Adaptive Boosting)算法
对于boosting算法，存在两个问题：
1. 如何调整训练集，使得在训练集上训练的弱分类器得以进行；
2. 如何将训练得到的各个弱分类器联合起来形成强分类器。
针对以上两个问题，adaboost算法进行了调整：
1. 使用加权后选取的训练数据代替随机选取的训练样本，这样将训练的焦点集中在比较难分的训练数据样本上；
2. 将弱分类器联合起来，使用加权的投票机制代替平均投票机制。让分类效果好的弱分类器具有较大的权重，而分类效果差的分类器具有较小的权重。
Adaboost算法是Freund和Schapire根据在线分配算法提出的，他们详细分析 了Adaboost算法错误率 的上界，以及为了使强分类器 达到错误率 ，算法所需要的最多迭代次数等相关问题。与Boosting算法不同的是，adaboost算法不需要预先知道弱学习算法学习正确率的下限即弱分类器的误 差，并且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度， 这样可以深入挖掘弱分类器算法的能力。
Adaboost算法中不同的训练集是通过调整每个样本对应的权重来实现的。开始时，每个样本 对应的权重是相同的，即 其中 n 为样本个数，在此样本分布下训练出一弱分类器 。对于 分类错误的样本，加大其对应的权重；而对于分类正确的样本，降低其权重，这样分错的样本就被突出出来，从而得到一个新的样本分布 。在新的样本分布下，再次对弱分类器进行训练，得到弱分类器。依次类推，经过 T 次循环，得到 T 个弱分类器，把这 T 个弱分类器按一定的权重叠加（boost）起来，得到最终想要的强分类器。
Adaboost算法的具体步骤如下：
1. 给定训练样本集 ，其中 分别对应于正例样本和负例样本； 为训练的最大循环次数；
2. 初始化样本权重 ，即为训练样本的初始概率分布；
3. 第一次迭代：
(1) 训练样本的概率分布 下，训练弱分类器：
(2) 计算弱分类器的错误率：
(3) 选取 ，使得 最小
(4) 更新样本权重：
(5) 最终得到的强分类器：
Adaboost算法是经过调整的Boosting算法，其能够对弱学习得到的弱分类器的错误 进行适应性调整。上述算法中迭代了 次的主循环，每一次循环根据当前的权重分布 对样本x定一个分布P，然后对这个分布下的样本使用若学习算法得到一个错误率为 的弱分类器 ，对于这个算法定义的弱学习算法，对所有的 ，都有 ，而这个错误率的上限并不需要事先知道，实际上 。每一次迭代，都要对权重进行更新。更新的规则是：减小弱分类器分类效果较好的数据的概率，增大弱分类器分类效果较差的数据的概率。最终的分类器是 个弱分类器的加权平均。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(6) PageRank</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/17/data-mining-classical-algorithm-6-pagerank"/>
   <updated>2011-04-17T19:38:38+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/17/data-mining-classical-algorithm-6-pagerank</id>
   <content type="html">&lt;p&gt;PageRank是Google算法的重要内容。2001年9月被授予美国专利，专利人是Google创始人之一拉里·佩奇（Larry Page）。因此，PageRank里的page不是指网页，而是指佩奇，即这个等级方法是以佩奇来命名的。
&lt;a href=&quot;http://baike.baidu.com/view/105.htm&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt;的 PageRank根据网站的外部链接和内部链接的数量和质量俩衡量网站的价值。PageRank背后的概念是，每个到页面的链接都是对该页面的一次投票， 被链接的越多，就意味着被其他网站投票越多。这个就是所谓的“链接流行度”——衡量多少人愿意将他们的网站和你的网站挂钩。PageRank这个概念引自 学术中一篇论文的被引述的频度——即被别人引述的次数越多，一般判断这篇论文的权威性就越高。
Google有一套自动化方法来计算这些投票。Google的PageRank分值从0到 10；PageRank为10表示最佳，但非常少见，类似里氏震级（Richter scale），PageRank级别也不是线性的，而是按照一种指数刻度。这是一种奇特的数学术语，意思是PageRank4不是比PageRank3好 一级——而可能会好6到7倍。因此，一个PageRank5的网页和PageRank8的网页之间的差距会比你可能认为的要大的多。
PageRank较高的页面的排名往往要比PageRank较低的页面高，而这导致了人们对链 接的着魔。在整个SEO社区，人们忙于争夺、交换甚至销售链接，它是过去几年来人们关注的焦点，以至于Google修改了他的系统，并开始放弃某些类型的 链接。比如，被人们广泛接受的一条规定，来自缺乏内容的“link farm”（链接工厂）网站的链接将不会提供页面的PageRank，从PageRank较高的页面得到链接但是内容不相关（比如说某个流行的漫画书网站 链接到一个叉车规范页面），也不会提供页面的PageRank。Google选择降低了PageRank对更新频率，以便不鼓励人们不断的对其进行监测。
Google PageRank一般一年更新四次，所以刚上线的新网站不可能获得PR值。你的网站很可能在相当长的时间里面看不到PR值的变化，特别是一些新的网站。PR值暂时没有，这不是什么不好的事情，耐心等待就好了。
为您的网站获取外部链接是一件好事，但是无视其他SEO领域的工作而进行急迫的链接建设就是浪费时间，要时刻保持一个整体思路并记住以下几点：
·Google的排名算法并不是完全基于外部链接的
·高PageRank并不能保证Google高排名
·PageRank值更新的比较慢，今天看到的PageRank值可能是三个月前的值&lt;/p&gt;

&lt;h2&gt;因此我们不鼓励刻意的去追求PageRank，因为决定排名的因素可以有上百种。尽管如 此，PageRank还是一个用来了解Google对您的网站页面如何评价的相当好的指示，建议网站设计者要充分认识PageRank在Google判断 网站质量中的重要作用，从设计前的考虑到后期网站更新都要给予PageRank足够的分析，很好的利用。我们要将PageRank看作是一种业余爱好而不 是一种信仰。&lt;/h2&gt;

&lt;p&gt;通过对由超过 50,000 万个变量和 20 亿个词汇组成的方程进行计算，PageRank 能够对网页的重要性做出客观的评价。PageRank 并不计算直接链接的数量，而是将从网页 A 指向网页 B 的链接解释为由网页 A 对网页 B 所投的一票。这样，PageRank 会根据网页 B 所收到的投票数量来评估该页的重要性。
此外，PageRank 还会评估每个投票网页的重要性，因为某些网页的投票被认为具有较高的价值，这样，它所链接的网页就能获得较高的价值。重要网页获得的 PageRank（网页排名）较高，从而显示在搜索结果的顶部。Google 技术使用网上反馈的综合信息来确定某个网页的重要性。搜索结果没有人工干预或操纵，这也是为什么 Google 会成为一个广受用户信赖、不受付费排名影响且公正客观的信息来源。
－－－－－－－－－－－－－－－
其实简单说就是民主表决。打个比方，假如我们要找李开复博士，有一百个人举手说自己是李开复。那么谁是真的呢？也许有好几个真的，但即使如此谁又是大家真正想找的呢？:-) 如果大家都说在 Google 公司的那个是真的，那么他就是真的。
在互联网上，如果一个网页被很多其它网页所链接，说明它受到普遍的承认和信赖，那么它的排名就 高。这就是 Page Rank 的核心思想。 当然 Google 的 Page Rank 算法实际上要复杂得多。比如说，对来自不同网页的链接对待不同，本身网页排名高的链接更可靠，于是给这些链接予较大的权重。Page Rank 考虑了这个因素，可是现在问题又来了，计算搜索结果的网页排名过程中需要用到网页本身的排名，这不成了先有鸡还是先有蛋的问题了吗？
Google 的两个创始人拉里·佩奇 （Larry Page ）和谢尔盖·布林 (Sergey Brin) 把这个问题变成了一个二维矩阵相乘的问题，并且用迭代的方法解决了这个问题。他们先假定所有网页的排名是相同的，并且根据这个初始值，算出各个网页的第一 次迭代排名，然后再根据第一次迭代排名算出第二次的排名。他们两人从理论上证明了不论初始值如何选取，这种算法都保证了网页排名的估计值能收敛到他们的真 实值。值得一提的事，这种算法是完全没有任何人工干预的。
理论问题解决了，又遇到实际问题。因为互联网上网页的数量是巨大的，上面提到的二维矩阵从理论 上讲有网页数目平方之多个元素。如果我们假定有十亿个网页，那么这个矩阵 就有一百亿亿个元素。这样大的矩阵相乘，计算量是非常大的。拉里和谢尔盖两人利用稀疏矩阵计算的技巧，大大的简化了计算量，并实现了这个网页排名算法。今 天 Google 的工程师把这个算法移植到并行的计算机中，进一步缩短了计算时间，使网页更新的周期比以前短了许多。
我来 Google 后，拉里 (Larry) 在和我们几个新员工座谈时，讲起他当年和谢尔盖(Sergey) 是怎么想到网页排名算法的。他说：&quot;当时我们觉得整个互联网就像一张大的图 （Graph)，每个网站就像一个节点，而每个网页的链接就像一个弧。我想，互联网可以用一个图或者矩阵描述，我也许可以用这个发现做个博士论文。&quot; 他和谢尔盖就这样发明了 Page Rank 的算法。
网页排名的高明之处在于它把整个互联网当作了一个整体对待。它无意识中符合了系统论的观点。相比之下，以前的信息检索大多把每一个网页当作独立的个体对待，很多人当初只注意了网页内容和查询语句的相关性，忽略了网页之间的关系。
今天，Google 搜索引擎比最初复杂、完善了许多。但是网页排名在 Google 所有算法中依然是至关重要的。在学术界, 这个算法被公认为是文献检索中最大的贡献之一，并且被很多大学引入了信息检索课程 (Information Retrieval) 的教程。
如何提高你网页的 PR 值？
什么是PR值呢? PR值全称为PageRank，PR是英文Pagerank 的缩写形式，Pagerank取自Google的创始人LarryPage，它是Google排名运算法则（排名公式）的一部分，Pagerank是 Google对网页重要性的评估，是Google用来衡量一个网站的好坏的唯一标准。PageRank(网页级别)是Google用于评测一个网页“重要 性”的一种方法。在揉合了诸如Title标识和Keywords标识等所有其它因素之后，Google通过PageRank来调整结果，使那些更具“重要 性”的网页在搜索结果中另网站排名获得提升，从而提高搜索结果的相关性和质量。 PR值的级别从1到10级，10级为满分。PR值越高说明该网页越受欢迎。Google把自己的网站的PR值定到10，这说明Google这个网站是非常 受欢迎的，也可以说这个网站非常重要。Google大受青睐的另一个原因就是它的网站索引速度。向Google提交你的网站直到为Google收录，一般 只需两个星期。如果你的网站已经为Google收录，那么通常Google会每月一次遍历和更新(重新索引)你的网站信息。不过对于那些PR值 (Pagerank)较高的网站，Google索引周期会相应的短一些。一个PR值为1的网站表明这个网站不太具有流行度，而PR值为7到10则表明这个 网站非常受欢迎。PR值最高为10，一般PR值达到4，就算是一个不错的网站了。那么PR值都受那些因素影响呢？下面我们一起来看看。
第一：网站外部链接的数量和质量
在计算网站排名时，Pagerank会将网站的外部链接数考虑进去。并不能说一个网站的外部链 接数越多其PR值就越高，如果这样的话，一个网站尽可能获得最多的外部链接就OK了，有这种想法是错误的。Google对一个网站上的外部链接数的重视程 度并不意味着你因此可以不求策略地与任何网站建立连接。这是因为Google并不是简单地由计算网站的外部链接数来决定其等级。Google的 Pagerank系统不单考虑一个网站的外部链接质量，也会考虑其数量。这个问题看来很有复杂。首先让我们来解释一下什么是阻尼因数(damping factor)。阻尼因素就是当你投票或链接到另外一个站点时所获得的实际PR分值。阻尼因数一般是0.85。当然比起你网站的实际PR值，它就显得微不 足道了。
现在让我们来看看这个PR分值的计算公式：PR(A)=(1- d)+d(PR(t1)/C(t1)+...+PR(tn)/C(tn)) 公式解释：其中PR(A)表示的是从一个外部链接站点t1上，依据Pagerank?系统给你的网站所增加的PR分值；PR(t1)表示该外部链接网站本 身的PR分值；C(t1)则表示该外部链接站点所拥有的外部链接数量。大家要谨记：一个网站的投票权值只有该网站PR分值的0.85，
那么，是不是说对一个网站而言，它所拥有的较高网站质量和较高PR分值的外部链接数量越多就越 好呢？错，因为－Google的Pagerank系统不单考虑一个网站的外部链接质量，也会考虑其数量.比方说，对一个有一定PR值的网站X来说，如果你 的网站Y是它的唯一一个外部链接，那么Google就相信网站X将你的网站Y视做它最好的一个外部链接，从而会给你的网站Y更多的分值。可是，如果网站X 上已经有49个外部链接，那么Google就相信网站X只是将你的网站视做它第50个好的网站。因而你的外部链接站点上的外部链接数越多，你所能够得到的 PR分值反而会越低，它们呈反比关系。
说它对是因为－一般情况下，一个PR分值大于等于6的外部链接站点，可显著提升你的PR分值。 但如果这个外部链接站点已经有100个其它的外部链接时，那你能够得到的PR分值就几乎为零了。同样，如果一个外部链接站点的PR值仅为2，但你却是它的 唯一一个外部链接，那么你所获得的PR值要远远大于那个PR值为6，外部链接数为100的网站。
而且这个0.85的权值平均分配给其链接的每个外部网站。
第二：Google在你的网站抓取的页面数
Google在你的网站抓取的页面数，数目越多，Pagerank值越高。但通常Google 并不会主动抓取你的网站的所有页面，尤其是网址里带有“?”的动态链接，Google不主动，那就要我们主动了，最笨的办法是把网站所有的页面都提交给 Google，但我想没有谁真会这么做，但页面不多的话可以试试。更好的办法是制作一个静态Html页面，通常被称作“网站地图”或“网站导航”，它里面 包含你要添加的所有网址，然后把这个静态页面提交给Google。
第三：网站被世界三大知名网站 DMOZ，Yahoo和Looksmart 收录
众所周知，Google的Pagerank系统对那些门户网络目录如DMOZ，Yahoo和 Looksmart尤为器重。特别是对DMOZ。一个网站上的DMOZ链接对Google的Pagerank?来说，就好像一块金子一样珍贵。如果你的网 站为ODP收录，则可有效提升你的页面等级。向ODP提交你的站点并为它收录，其实并不是一件难事，只是要多花点时间而已。只要确保你的网站提供了良好的 内容，然后在ODP合适的目录下点击&quot;增加站点&quot;，按照提示一步步来就OK了。至少要保证你的索引页(INDEX PAGE)被收录进去。所以，如果你的网站内容涉及完全不同的几块内容，你可以把每个内容的网页分别向ODP提交－不过请记住&quot;欲速则不达&quot;。等到 Google对其目录更新后，你就能看到你的PR值会有什么变化了。如果你的网站为Yahoo和Looksmart所收录，那么你的PR值会得到显著提 升。如果你的网站是非商业性质的或几乎完全是非商业性质的内容，那么你可以通过zeall.com使你的网站为著名的网络目录Looksmart所收录。 Looksmart也是从Zeal网络目录获得非商业搜索列表。
Google PR值的更新周期是多长时间？
一般情况下PR值更新的周期是2.5～3个月！最近一次PR更新是2008年1月中旬。
PageRank相关算法总结：
1.PageRank
基本思想：如果网页T存在一个指向网页A的连接，则表明T的所有者认为A比较重要，从而把T的一部分重要性得分赋予A。这个重要性得分值为：PR（T）/C(T)
其中PR（T）为T的PageRank值，C(T)为T的出链数，则A的PageRank值为一系列类似于T的页面重要性得分值的累加。
优点：是一个与查询无关的静态算法，所有网页的PageRank值通过离线计算获得；有效减少在线查询时的计算量，极大降低了查询响应时间。
不足：人们的查询具有主题特征，PageRank忽略了主题相关性，导致结果的相关性和主题性降低；另外，PageRank有很严重的对新网页的歧视。
2.Topic-Sensitive PageRank（主题敏感的PageRank）
基本思想：针对PageRank对主题的忽略而提出。核心思想：通过离线计算出一个 PageRank向量集合，该集合中的每一个向量与某一主题相关，即计算某个页面关于不同主题的得分。主要分为两个阶段：主题相关的PageRank向量 集合的计算和在线查询时主题的确定。
优点：根据用户的查询请求和相关上下文判断用户查询相关的主题（用户的兴趣）返回查询结果准确性高。
不足：没有利用主题的相关性来提高链接得分的准确性。
3.Hilltop
基本思想：与PageRank的不同之处：仅考虑专家页面的链接。主要包括两个步骤：专家页面搜索和目标页面排序。
优点：相关性强，结果准确。
不足：专家页面的搜索和确定对算法起关键作用，专家页面的质量决定了算法的准确性，而专家页面 的质量和公平性难以保证；忽略了大量非专家页面的影响，不能反应整个Internet的民意；当没有足够的专家页面存在时，返回空，所以Hilltop适 合对于查询排序进行求精。
那么影响google PageRank的因素有哪些呢?
1 与pr高的网站做链接:
2 内容质量高的网站链接
3加入搜索引擎分类目录
4 加入免费开源目录
5 你的链接出现在流量大、知名度高、频繁更新的重要网站上
6google对DPF格式的文件比较看重。
7安装Google工具条
8域名和tilte标题出现关键词与meta标签等
9反向连接数量和反向连接的等级
10Google抓取您网站的页面数量
11导出链接数量
PageRank科学排名遏止关键字垃圾
目前，五花八门的网站为争夺网上排名采用恶意点击和输入关键字垃圾的手段来吸引网民的眼球，无论对于互联网企业还是互联网用户，这都不是一个好现象。
为了解决这样的问题，Google 创始人之一拉里.佩奇（Larry Page）发明了一种算法PageRank，是由搜索引擎根据网页之间相互的超链接进行计算的网页排名。它经常和搜索引擎优化有关。PageRank 系统目前被Google 用来体现网页的相关性和重要性，以便科学排名，遏止关键字垃圾。
PageRank这个概念引自一篇学术论文的被媒体转载的频度，一般被转载的次数越多，这篇论文的权威性就越高，价值也就越高。PageRank是1998年在斯坦福大学问世的，2001
年9 月被授予美国专利。如今它在 Google 所有算法中依然是至关重要的。在学术界, 这个算法被公认为是文献检索中最大的贡献之一，并且被很多大学引入了信息检索课程(Information Retrieval) 的教程。
PageRank 通过对由超过 5 亿个变量和 20 亿个词汇组成的方程进行计算，能科学公正地标识网页的等级或重要性。PR级别为1到10，PR值越高说明该网页越重要。例如：一个PR 值为1 的网站表明这个网站不太具有流行度，而PR 值为7到10则表明这个网站极其重要。PageRank级别不是一般的算术级数，而是按照一种几何级数来划分的。PageRank3 不是比PageRank2 好一级，而可能会好到数倍。
PageRank根据网站的外部链接和内部链接的数量和质量来衡量网站的价值。 PageRank的概念是，每个到页面的链接都是对该页面的一次投票，被链接得越多，就意味着被其他网站投票越多。Google 有一套自动化方法来计算这些投票，但Google 的排名算法不完全基于外部链接。PageRank 对来自不同网页的链接会区别对待，来自网页本身排名高的链接更受青睐，给这些链接有较大的权重。
同时，Google 不只是看一个网站的投票数量，或者这个网站的外部链接数量。它会对那些投票的网站进行分析。如果这些网站的PR 值比较高，则其投票的网站可从中受益。因此，Google 的技术专家提醒人们，在建设网站的外部链接时，应尽可能瞄准那些PR 值高且外部链接数又少的网站。这样的外部链接站点越多，你的PR 值就会越高，从而使得你的Google 排名得到显著提升。
PageRank的另一作用是对关键字垃圾起到巨大的遏制作用。眼下，一些垃圾网站为了提高点击率，用一些与站点内容无关的关键字垃圾壮声威，比如用明星的名字、用公共突
发事件称谓等。这些网页的目的或是为了骗取广告点击，或是为了传播病毒。还有一些无赖式的博客评论也从中搅局，在网上招摇过市，骗取网民的注意力，这也被网络技术人员
视为垃圾。
PageRank目前使用一种基于信任和名誉的算法帮助遏止关键字垃圾，它忽视这些关键字垃圾的存在，以网页相互链接评级别论高低。Google 排名之所以大受追捧，是由于它并非
只使用关键字或代理搜索技术， 而是将自身建立在高级的网页级别技术基础之上。 别的搜索引擎提供给搜索者的是多种渠道值为 8 的网站信息得来的一个粗略的搜索结果，而Google 提供给它的搜索者的则是它自己产生的高度精确的搜索结果。这就是为什么网站管理员会千方百计去提高自己网站在Google 的排名了。
PageRank一般一年更新四次，所以刚上线的新网站不可能获得PR 值。不过PR 值暂时没有，并不是什么不好的事情，耐心等待就能得到Google 的青睐。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(5) 最大期望(EM)算法</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/16/data-mining-classical-algorithm-5"/>
   <updated>2011-04-16T19:36:49+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/16/data-mining-classical-algorithm-5</id>
   <content type="html">&lt;p&gt;在统计计算中，最大期望（EM，Expectation–Maximization）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。最大期望算法经过两个步骤交替进行计算，第一步是计算期望（E），也就是将隐藏变量象能够观测到的一样包含在内从而计算最大似然的期望值；另外一步是最大化（M），也就是最大化在 E 步上找到的最大似然的期望值从而计算参数的最大似然估计。M 步上找到的参数然后用于另外一个 E 步计算，这个过程不断交替进行。&lt;/p&gt;

&lt;h2&gt;最大期望过程说明&lt;/h2&gt;


&lt;p&gt;我们用 &lt;img src=&quot;http://upload.wikimedia.org/math/f/f/5/ff58c8e0e55b508d25fa7aff97d497b1.png&quot; alt=&quot;\textbf{y}&quot; /&gt; 表示能够观察到的不完整的变量值，用 &lt;img src=&quot;http://upload.wikimedia.org/math/f/2/a/f2a48e1cd2da440643ea07a3b2f60e6f.png&quot; alt=&quot;\textbf{x}&quot; /&gt; 表示无法观察到的变量值，这样 &lt;img src=&quot;http://upload.wikimedia.org/math/f/2/a/f2a48e1cd2da440643ea07a3b2f60e6f.png&quot; alt=&quot;\textbf{x}&quot; /&gt; 和 &lt;img src=&quot;http://upload.wikimedia.org/math/f/f/5/ff58c8e0e55b508d25fa7aff97d497b1.png&quot; alt=&quot;\textbf{y}&quot; /&gt; 一起组成了完整的数据。&lt;img src=&quot;http://upload.wikimedia.org/math/f/2/a/f2a48e1cd2da440643ea07a3b2f60e6f.png&quot; alt=&quot;\textbf{x}&quot; /&gt;可能是实际测量丢失的数据，也可能是能够简化问题的隐藏变量，如果它的值能够知道的话。例如，在&lt;a title=&quot;混合模型&quot; href=&quot;http://zh.wikipedia.org/w/index.php?title=%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;混合模型&lt;/a&gt;（&lt;a title=&quot;en:mixture model&quot; href=&quot;http://en.wikipedia.org/wiki/mixture_model&quot;&gt;Mixture Model&lt;/a&gt;）中，如果“产生”样本的混合元素成分已知的话最大似然公式将变得更加便利（参见下面的例子）。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;.E4.BC.B0.E8.AE.A1.E6.97.A0.E6.B3.95.E8.A7.82.E6.B5.8B.E7.9A.84.E6.95.B0.E6.8D.AE&quot; name=&quot;.E4.BC.B0.E8.AE.A1.E6.97.A0.E6.B3.95.E8.A7.82.E6.B5.8B.E7.9A.84.E6.95.B0.E6.8D.AE&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;估计无法观测的数据&lt;/h3&gt;


&lt;p&gt;让 &lt;img src=&quot;http://upload.wikimedia.org/math/5/a/3/5a34bb082daf037b3c4b14c13af6855b.png&quot; alt=&quot;p\,&quot; /&gt; 代表矢量 θ: &lt;img src=&quot;http://upload.wikimedia.org/math/e/8/7/e8761ada1a3ed08273a0b5659a07de7a.png&quot; alt=&quot;p( \mathbf y, \mathbf x | \theta)&quot; /&gt; 定义的参数的全部数据的&lt;a title=&quot;概率分布&quot; href=&quot;http://zh.wikipedia.org/wiki/%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83&quot;&gt;概率分布&lt;/a&gt;（连续情况下）或者&lt;a title=&quot;概率集聚函数&quot; href=&quot;http://zh.wikipedia.org/w/index.php?title=%E6%A6%82%E7%8E%87%E9%9B%86%E8%81%9A%E5%87%BD%E6%95%B0&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;概率集聚函数&lt;/a&gt;（离散情况下），那么从这个函数就可以得到全部数据的&lt;a title=&quot;最大似然值&quot; href=&quot;http://zh.wikipedia.org/w/index.php?title=%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E5%80%BC&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;最大似然值&lt;/a&gt;，另外，在给定的观察到的数据条件下未知数据的&lt;a title=&quot;条件分布&quot; href=&quot;http://zh.wikipedia.org/w/index.php?title=%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B8%83&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;条件分布&lt;/a&gt;可以表示为：&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(4) The Apriori algorithm</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/15/data-mining-classical-algorithm-4-the-apriori-algorithm"/>
   <updated>2011-04-15T19:36:24+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/15/data-mining-classical-algorithm-4-the-apriori-algorithm</id>
   <content type="html">&lt;p&gt;Apriori算法是一种最有影响的挖掘布尔关联规则频繁项集的算法。其核心是基于两阶段频集思想的递推算法。该关联规则在分类上属于单维、单层、布尔关联规则。在这里，所有支持度大于最小支持度的项集称为频繁项集，简称频集。&lt;/p&gt;

&lt;p&gt;Apriori演算法所使用的前置统计量包括了：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;最大规则物件数：规则中物件组所包含的最大物件数量&lt;/li&gt;
    &lt;li&gt;最小支援：规则中物件或是物件组必顸符合的最低案例数&lt;/li&gt;
    &lt;li&gt;最小信心水准：计算规则所必须符合的最低信心水准门槛&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;该算法的基本思想是：首先找出所有的频集，这些项集出现的频繁性至少和预定义的最小支持度一 样。然后由频集产生强关联规则，这些规则必须满足最小支持度和最小可信度。然后使用第1步找到的频集产生期望的规则，产生只包含集合的项的所有规则，其中 每一条规则的右部只有一项，这里采用的是中规则的定义。一旦这些规则被生成，那么只有那些大于用户给定的最小可信度的规则才被留下来。为了生成所有频集， 使用了递推的方法。
可能产生大量的候选集,以及可能需要重复扫描数据库，是Apriori算法的两大缺点。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(3) Support vector machines</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/14/data-mining-classical-algorithm-3-support-vector-machines"/>
   <updated>2011-04-14T19:35:00+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/14/data-mining-classical-algorithm-3-support-vector-machines</id>
   <content type="html">&lt;p&gt;支持向量机，英文为Support Vector Machine，简称SV机（论文中一般简称SVM）。它是一种監督式學習的方法，它广泛的应用于统计分类以及回归分析中。&lt;/p&gt;

&lt;p&gt;支持向量机属于一般化线性分类器.他们也可以认为是提克洛夫规范化（Tikhonov Regularization）方法的一个特例.这族分类器的特点是他们能够同时最小化经验误差与最大化几何边缘区.因此支持向量机也被称为最大边缘区分类器。在统计计算中，最大期望（EM）算法是在概率（probabilistic）模型中寻找参数最大似然估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variabl）。最大期望经常用在机器学习和计算机视觉的数据集聚（Data Clustering）领域。最大期望算法经过两个步骤交替进行计算，第一步是计算期望（E），也就是将隐藏变量象能够观测到的一样包含在内从而计算最大似然的期望值；另外一步是最大化（M），也就是最大化在 E 步上找到的最大似然的期望值从而计算参数的最大似然估计。M 步上找到的参数然后用于另外一个 E 步计算，这个过程不断交替进行。&lt;/p&gt;

&lt;p&gt;Vapnik等人在多年研究统计学习理论基础上对线性分类器提出了另一种设计最佳准则。其原理也从线性可分说起，然后扩展到线性不可分的情况。甚至扩展到 使用非线性函数中去，这种分类器被称为支持向量机(Support Vector Machine,简称SVM)。支持向量机的提出有很深的理论背景。 支持向量机方法是在近年来提出的一种新方法。
SVM的主要思想可以概括为两点： (1) 它是针对线性可分情况进行分析，对于线性不可分的情况，通过使用非线性映射算法将低维输入空间线性不可分的样本转化为高维特征空间使其线性可分，从而 使得高维特征空间采用线性算法对样本的非线性特征进行线性分析成为可能；(2) 它基于结构风险最小化理论之上在特征空间中建构最优分割超平面，使得学习器得到全局最优化,并且在整个样本空间的期望风险以某个概率满足一定上界。
在学习这种方法时，首先要弄清楚这种方法考虑问题的特点，这就要从线性可分的最简单情况讨论 起，在没有弄懂其原理之前，不要急于学习线性不可分等较复杂的情况，支持向量机在设计时，需要用到条件极值问题的求解，因此需用拉格朗日乘子理论，但对多 数人来说，以前学到的或常用的是约束条件为等式表示的方式，但在此要用到以不等式作为必须满足的条件，此时只要了解拉格朗日理论的有关结论就行。&lt;/p&gt;

&lt;h2&gt;介绍&lt;/h2&gt;


&lt;p&gt;支持向量机将向量映射到一个更高维的空间里，在这个空间里建立有一个最大间隔超平面。在分开数据的超平面的两边建有两个互相平行的超平面。分隔超平 面使两个平行超平面的距离最大化。假定平行超平面间的距离或差距越大，分类器的总误差越小。一个极好的指南是C.J.C Burges的《模式识别支持向量机指南》。van der Walt 和 Barnard 将支持向量机和其他分类器进行了比较。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;.E5.8A.A8.E6.9C.BA&quot; name=&quot;.E5.8A.A8.E6.9C.BA&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;动机&lt;/h3&gt;


&lt;div&gt;
&lt;div&gt;&lt;a title=&quot;有很多个分类器(超平面）可以把数据分开，但是只有一个能够达到最大分割。&quot; href=&quot;http://zh.wikipedia.org/wiki/File:Classifier.png&quot;&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/zh/thumb/c/c8/Classifier.png/180px-Classifier.png&quot; border=&quot;0&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;151&quot; /&gt;&lt;/a&gt;
&lt;div&gt;
&lt;div&gt;&lt;a title=&quot;放大&quot; href=&quot;http://zh.wikipedia.org/wiki/File:Classifier.png&quot;&gt;&lt;img src=&quot;http://zh.wikipedia.org/skins-1.5/common/images/magnify-clip.png&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;11&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
有很多个分类器(超平面）可以把数据分开，但是只有一个能够达到最大分割。&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们通常希望分类的过程是一个机器学习的过程。这些数据点并不需要是&lt;img src=&quot;http://upload.wikimedia.org/math/a/1/f/a1fd49f304c1094efe3fda098d5eaa5f.png&quot; alt=&quot;\mathbb{R}^2&quot; /&gt;中的点，而可以是任意&lt;img src=&quot;http://upload.wikimedia.org/math/5/6/e/56ef1cb9c0683de06f05e34c0bd42537.png&quot; alt=&quot;\mathbb{R}^p&quot; /&gt;(统计学符号)中或者&lt;img src=&quot;http://upload.wikimedia.org/math/3/0/c/30c28f76ef7517dbd19df4d4c683dbe6.png&quot; alt=&quot;\mathbb{R}^n&quot; /&gt; (计算机科学符号) 的点。我们希望能够把这些点通过一个n-1维的&lt;a title=&quot;超平面&quot; href=&quot;http://zh.wikipedia.org/wiki/%E8%B6%85%E5%B9%B3%E9%9D%A2&quot;&gt;超平面&lt;/a&gt;分开，通常这个被称为&lt;a title=&quot;线性分类器&quot; href=&quot;http://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%88%86%E7%B1%BB%E5%99%A8&quot;&gt;线性分类器&lt;/a&gt;。有很多分类器都符合这个要求，但是我们还希望找到分类最佳的平面，即使得属于两个不同类的数据点间隔最大的那个面，该面亦称为&lt;strong&gt;最大间隔超平面&lt;/strong&gt;。如果我们能够找到这个面，那么这个分类器就称为最大间隔分类器。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;.E9.97.AE.E9.A2.98.E5.AE.9A.E4.B9.89&quot; name=&quot;.E9.97.AE.E9.A2.98.E5.AE.9A.E4.B9.89&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;问题定义&lt;/h3&gt;


&lt;div&gt;
&lt;div&gt;&lt;a title=&quot;设样本属于两个类，用该样本训练svm得到的最大间隔超平面。在超平面上的样本点也称为支持向量.&quot; href=&quot;http://zh.wikipedia.org/wiki/File:SVM_margins.png&quot;&gt;&lt;img src=&quot;http://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/SVM_margins.png/180px-SVM_margins.png&quot; border=&quot;0&quot; alt=&quot;&quot; width=&quot;180&quot; height=&quot;220&quot; /&gt;&lt;/a&gt;
&lt;div&gt;
&lt;div&gt;&lt;a title=&quot;放大&quot; href=&quot;http://zh.wikipedia.org/wiki/File:SVM_margins.png&quot;&gt;&lt;img src=&quot;http://zh.wikipedia.org/skins-1.5/common/images/magnify-clip.png&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;11&quot; /&gt;&lt;/a&gt;&lt;/div&gt;
设样本属于两个类，用该样本训练svm得到的最大间隔超平面。在超平面上的样本点也称为支持向量.&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;我们考虑以下形式的样本点&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/7/3/c/73c2271c2efadc59ca11fea82796020c.png&quot; alt=&quot;\{ (\mathbf{x}_1, c_1), (\mathbf{x}_2, c_2), \ldots, (\mathbf{x}_n, c_n)\}&quot; /&gt;&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;其中&lt;em&gt;c&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;为1或−1 --用以表示数据点属于哪个类. &lt;img src=&quot;http://upload.wikimedia.org/math/3/f/0/3f052ba8a0742f689f895fd252fa157f.png&quot; alt=&quot; \mathbf{x}_i &quot; /&gt; 是一个&lt;em&gt;p&lt;/em&gt; − (统计学符号), 或 &lt;em&gt;n&lt;/em&gt; − (计算机科学符号) 维向量，其每个元素都被缩放到[0,1]或[-1,1].缩放的目的是防止方差大的随机变量主导分类过程.我们可以把这些数据称为“训练数据”，希望我们的支持向量机能够通过一个超平面正确的把他们分开。超平面的数学形式可以写作&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/4/8/7/4875c57f22ae0726fe413a3be97da5df.png&quot; alt=&quot;\mathbf{w}\cdot\mathbf{x} - b=0.&quot; /&gt;&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;根据几何知识，我们知道&lt;img src=&quot;http://upload.wikimedia.org/math/2/c/5/2c5a3544056eab0411512e37fedea46d.png&quot; alt=&quot;\mathbf{w}&quot; /&gt;向量垂直于分类超平面。加入位移&lt;strong&gt;b&lt;/strong&gt;的目的是增加间隔.如果没有&lt;em&gt;b&lt;/em&gt;的话，那超平面将不得不通过原点，限制了这个方法的灵活性。&lt;/p&gt;

&lt;p&gt;由于我们要求最大间隔，因此我们需要知道支持向量以及（与最佳超平面）平行的并且离支持向量最近的超平面。我们可以看到这些平行超平面可以由方程族：&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/f/3/4/f34af0e1112d160e98feffbceb7d110a.png&quot; alt=&quot;\mathbf{w}\cdot\mathbf{x} - b=1,&quot; /&gt;&lt;/dd&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/0/3/0/03034da6a72ea9fbed8496cf3e3e9294.png&quot; alt=&quot;\mathbf{w}\cdot\mathbf{x} - b=-1.&quot; /&gt;&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;来表示。&lt;/p&gt;

&lt;p&gt;如果这些训练数据是线性可分的，那就可以找到这样两个超平面，在它们之间没有任何样本点并且这两个超平面之间的距离也最大.通过几何不难得到这两个超平面之间的距离是 2/|&lt;em&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/em&gt;|，因此我们需要最小化 |&lt;em&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/em&gt;|。同时为了使得样本数据点都在超平面的间隔区以外，我们需要保证对于所有的 &lt;em&gt;i&lt;/em&gt; 满足其中的一个条件&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/9/d/6/9d692015b7c3120ba24d6b4ed69e7fe3.png&quot; alt=&quot;\mathbf{w}\cdot\mathbf{x_i} - b \ge 1\qquad\mathrm{or}&quot; /&gt;&lt;/dd&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/f/f/6/ff60a9e0368a9230d64b4a0bd593d038.png&quot; alt=&quot;\mathbf{w}\cdot\mathbf{x_i} - b \le -1\qquad\mathrm{}&quot; /&gt;&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;这两个式子可以写作：&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/e/2/5/e25615c8322690f31073b67037a9dffa.png&quot; alt=&quot;c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1, \quad 1 \le i \le n.\qquad\qquad(1)&quot; /&gt;&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;&lt;a id=&quot;.E5.8E.9F.E5.9E.8B&quot; name=&quot;.E5.8E.9F.E5.9E.8B&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;原型&lt;/h3&gt;


&lt;p&gt;现在寻找最佳超平面这个问题就变成了在(1)这个约束条件下最小化|&lt;em&gt;&lt;strong&gt;w&lt;/strong&gt;&lt;/em&gt;|.这是一个&lt;a title=&quot;二次规划&quot; href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92&quot;&gt;二次規劃&lt;/a&gt;QP(quadratic programming)&lt;a title=&quot;最优化&quot; href=&quot;http://zh.wikipedia.org/wiki/%E6%9C%80%E4%BC%98%E5%8C%96&quot;&gt;最优化&lt;/a&gt;中的问题。&lt;/p&gt;

&lt;p&gt;更清楚的，它可以表示如下：&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;最小化 &lt;img src=&quot;http://upload.wikimedia.org/math/2/b/5/2b50a93790c7dec2ca1a735eb253c403.png&quot; alt=&quot;||\mathbf{w}||^2\over2&quot; /&gt;, 满足 &lt;img src=&quot;http://upload.wikimedia.org/math/3/5/2/35299c944f7732a9b377dfac7f84b2f1.png&quot; alt=&quot;c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1, \quad 1 \le i \le n.&quot; /&gt;。&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;1/2 这个因子是为了数学上表达的方便加上的。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;.E5.AF.B9.E5.81.B6.E5.9E.8B.28Dual_Form.29&quot; name=&quot;.E5.AF.B9.E5.81.B6.E5.9E.8B.28Dual_Form.29&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;对偶型(Dual Form)&lt;/h3&gt;


&lt;p&gt;把原型的分类规则写作对偶型，可以看到分类器其实是一个关于支持向量（即那些在间隔区边缘的训练样本点）的函数。&lt;/p&gt;

&lt;p&gt;支持向量机的对偶型如下： &lt;img src=&quot;http://upload.wikimedia.org/math/8/b/8/8b868abe02465e531792cb69c817cc54.png&quot; alt=&quot;\max \sum_{i=1}^n\alpha_i - \sum_{i,j} \alpha_i \alpha_j c_i c_j x_i^Tx_j&quot; /&gt; 并满足α&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt; &amp;gt; = 0&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;.E8.BD.AF.E9.97.B4.E9.9A.94&quot; name=&quot;.E8.BD.AF.E9.97.B4.E9.9A.94&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;软间隔&lt;/h2&gt;


&lt;p&gt;1995年, &lt;a title=&quot;Corinna Cortes&quot; href=&quot;http://zh.wikipedia.org/w/index.php?title=Corinna_Cortes&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Corinna Cortes&lt;/a&gt; 与Vapnik 提出了一种改进的最大间隔区方法，这种方法可以处理标记错误的样本。如果可区分正负例的超平面不存在，则“软边界”将选择一个超平面尽可能清晰地区分样 本，同时使其与分界最清晰的样本的距离最大化。这一成果使术语“支持向量机”（或“SVM”）得到推广。这种方法引入了松驰参数ξ&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;以衡量对数据&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;的误分类度。&lt;/p&gt;

&lt;dl&gt;&lt;dd&gt;&lt;img src=&quot;http://upload.wikimedia.org/math/a/4/8/a488b29a2187d7443084565d09e4abf5.png&quot; alt=&quot;c_i(\mathbf{w}\cdot\mathbf{x_i} - b) \ge 1 - \xi_i \quad 1 \le i \le n \quad\quad(2)&quot; /&gt;。&lt;/dd&gt;&lt;/dl&gt;


&lt;p&gt;随后，将目标函数与一个针对非0ξ&lt;sub&gt;&lt;em&gt;i&lt;/em&gt;&lt;/sub&gt;的惩罚函数相加，在增大间距和缩小错误惩罚两大目标之间进行权衡优化。如果惩罚函数是一个线性函数，则等式(3)变形为&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(2) The k-means algorithm</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/13/data-mining-classical-algorithm-2-the-k-means-algorithm"/>
   <updated>2011-04-13T19:34:05+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/13/data-mining-classical-algorithm-2-the-k-means-algorithm</id>
   <content type="html">&lt;p&gt;k-means algorithm算法是一个聚类算法，把n的对象根据他们的属性分为k个分割，k &amp;lt; n。它与处理混合正态分布的最大期望算法很相似，因为他们都试图找到数据中自然聚类的中心。它假设对象属性来自于空间向量，并且目标是使各个群组内部的均 方误差总和最小。&lt;/p&gt;

&lt;p&gt;假设有k个群组Si, i=1,2,...,k。μi是群组Si内所有元素xj的重心，或叫中心点。
k平均聚类发明于1956年， 该算法最常见的形式是采用被称为劳埃德算法(Lloyd algorithm)的迭代式改进探索法。劳埃德算法首先把输入点分成k个初始化分组，可以是随机的或者使用一些启发式数据。然后计算每组的中心点，根据 中心点的位置把对象分到离它最近的中心，重新确定分组。继续重复不断地计算中心并重新分组，直到收敛，即对象不再改变分组（中心点位置不再改变）。
劳埃德算法和k平均通常是紧密联系的，但是在实际应用中，劳埃德算法是解决k平均问题的启发式法则，对于某些起始点和重心的组合，劳埃德算法可能实际上收敛于错误的结果。（上面函数中存在的不同的最优解）
虽然存在变异，但是劳埃德算法仍旧保持流行，因为它在实际中收敛非常快。实际上，观察发现迭代次数远远少于点的数量。然而最近，David Arthur和Sergei Vassilvitskii提出存在特定的点集使得k平均算法花费超多项式时间达到收敛。
近似的k平均算法已经被设计用于原始数据子集的计算。
从算法的表现上来说，它并不保证一定得到全局最优解，最终解的质量很大程度上取决于初始化的分组。由于该算法的速度很快，因此常用的一种方法是多次运行k平均算法，选择最优解。
k平均算法的一个缺点是，分组的数目k是一个输入参数，不合适的k可能返回较差的结果。另外，算法还假设均方误差是计算群组分散度的最佳参数。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>数据挖掘十大经典算法(1) C4.5</title>
   <link href="http://dreambt.github.com/Algorithm/2011/04/12/data-mining-classical-algorithm-1-c4-5"/>
   <updated>2011-04-12T19:28:58+08:00</updated>
   <id>http://dreambt.github.com/Algorithm/2011/04/12/data-mining-classical-algorithm-1-c4-5</id>
   <content type="html">&lt;p&gt;Quinlan, J. R. 1993. C4.5: Programs for Machine Learning.
Morgan Kaufmann Publishers Inc.&lt;/p&gt;

&lt;p&gt;机器学习中，决策树是一个预测模型；他代表的是对象属性与对象值之间的一种映射关系。树中每个节点表示某个对象，而每个分叉路径则代表的某个可能的属性值，而每个叶结点则对应从根节点到该叶节点所经历的路径所表示的对象的值。决策树仅有单一输出，若欲有复数输出，可以建立独立的决策树以处理不同输出。&lt;/p&gt;

&lt;p&gt;从数据产生决策树的机器学习技术叫做决策树学习, 通俗说就是决策树。&lt;/p&gt;

&lt;p&gt;决策树学习也是数据挖掘中一个普通的方法。在这里，每个决策树都表述了一种树型结构，他由他的分支来对该类型的对象依靠属性进行分类。每个决策树可以依靠对源数据库的分割进行数据测试。这个过程可以递归式的对树进行修剪。 当不能再进行分割或一个单独的类可以被应用于某一分支时，递归过程就完成了。另外，随机森林分类器将许多决策树结合起来以提升分类的正确率。&lt;/p&gt;

&lt;p&gt;决策树同时也可以依靠计算条件概率来构造。决策树如果依靠数学的计算方法可以取得更加理想的效果。&lt;/p&gt;

&lt;p&gt;决策树是如何工作的
决策树一般都是自上而下的来生成的。
选择分割的方法有好几种，但是目的都是一致的：对目标类尝试进行最佳的分割。
从根到叶子节点都有一条路径，这条路径就是一条“规则”。
决策树可以是二叉的，也可以是多叉的。
对每个节点的衡量：
1)        通过该节点的记录数
2)        如果是叶子节点的话，分类的路径
3)        对叶子节点正确分类的比例。
有些规则的效果可以比其他的一些规则要好。&lt;/p&gt;

&lt;p&gt;由于ID3算法在实际应用中存在一些问题，于是Quilan提出了C4.5算法，严格上说C4.5只能是ID3的一个改进算法。相信大家对ID3算法都很.熟悉了，这里就不做介绍。
C4.5算法继承了ID3算法的优点，并在以下几方面对ID3算法进行了改进：
1) 用信息增益率来选择属性，克服了用信息增益选择属性时偏向选择取值多的属性的不足；
2) 在树构造过程中进行剪枝；
3) 能够完成对连续属性的离散化处理；
4) 能够对不完整数据进行处理。
C4.5算法有如下优点：产生的分类规则易于理解，准确率较高。其缺点是：在构造树的过程中，需要对数据集进行多次的顺序扫描和排序，因而导致算法的低效。此外，C4.5只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时程序无法运行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来自搜索的其他内容：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;C4.5算法是机器学习算法中的一种分类决策树算法,其核心算法是ID3算法.
分类决策树算法是从大量事例中进行提取分类规则的自上而下的决策树.
决策树的各部分是:
根:   学习的事例集.
枝:   分类的判定条件.
叶:   分好的各个类.
§4.3.2     ID3算法
1.概念提取算法CLS
1)     初始化参数C={E},E包括所有的例子,为根.
2)       IF     C中的任一元素e同属于同一个决策类则创建一个叶子
节点YES终止.
ELSE     依启发式标准,选择特征Fi={V1,V2,V3,．．．Vn}并创建
判定节点&lt;/p&gt;

&lt;p&gt;划分C为互不相交的N个集合C1,C2,C3,．．．,Cn；
3)     对任一个Ci递归.
2.     ID3算法
1)     随机选择C的一个子集W   (窗口).
2)     调用CLS生成W的分类树DT(强调的启发式标准在后).
3)     顺序扫描C搜集DT的意外(即由DT无法确定的例子).
4)     组合W与已发现的意外,形成新的W.
5)     重复2)到4),直到无例外为止.&lt;/p&gt;

&lt;p&gt;启发式标准:
只跟本身与其子树有关,采取信息理论用熵来量度.
熵是选择事件时选择自由度的量度,其计算方法为
P   =   freq(Cj,S)/|S|;
INFO(S)=   -   SUM(   P&lt;em&gt;LOG(P)   )   ;       SUM()函数是求j从1到n和.
Gain(X)=Info(X)-Infox(X);
Infox(X)=SUM(   (|Ti|/|T|)&lt;/em&gt;Info(X);
为保证生成的决策树最小,ID3算法在生成子树时,选取使生成的子树的熵(即Gain(S))最小的的特征来生成子树.&lt;/p&gt;

&lt;p&gt;§4.3.3:   ID3算法对数据的要求
1.     所有属性必须为离散量.
2.     所有的训练例的所有属性必须有一个明确的值.
3.     相同的因素必须得到相同的结论且训练例必须唯一.&lt;/p&gt;

&lt;p&gt;§4.3.4:   C4.5对ID3算法的改进:
1.     熵的改进,加上了子树的信息.
Split_Infox(X)=   -   SUM(     (|T|/|Ti|   )   *LOG(|Ti|/|T|)     );
Gain   ratio(X)=     Gain(X)/Split   Infox(X);
2.     在输入数据上的改进.
1)
因素属性的值可以是连续量,C4.5对其排序并分成不同的集合后按照ID3算法当作离散量进行处理,但结论属性的值必须是离散值.
2)   训练例的因素属性值可以是不确定的,以   ?   表示,但结论必须是确定的
3.     对已生成的决策树进行裁剪,减小生成树的规模.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>关于Unix时间戳(Unix timestamp)</title>
   <link href="http://dreambt.github.com/Linux/2011/04/11/unix-timestamp"/>
   <updated>2011-04-11T16:04:58+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/04/11/unix-timestamp</id>
   <content type="html">&lt;p&gt;时间戳是自 1970 年 1 月 1 日（00:00:00 GMT）以来的秒数，它也被称为 Unix 时间戳（Unix Timestamp）。&lt;/p&gt;

&lt;p&gt;Unix时间戳(Unix timestamp)，或称Unix时间(Unix time)、POSIX时间(POSIX time)，是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。&lt;/p&gt;

&lt;h3&gt;如何在不同编程语言中获取现在的Unix时间戳(Unix timestamp)？&lt;/h3&gt;


&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;200&quot;&gt;Java&lt;/td&gt;
&lt;td&gt;time&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;td&gt;Math.round(new Date().getTime()/1000)
getTime()返回数值的单位是毫秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Microsoft .NET / C#&lt;/td&gt;
&lt;td&gt;epoch = (DateTime.Now.ToUniversalTime().Ticks - 621355968000000000) / 10000000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;SELECT unix_timestamp(now())&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;td&gt;time&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;time()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;SELECT extract(epoch FROM now())&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;先 import time 然后 time.time()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;获取Unix时间戳：Time.now 或 Time.new
显示Unix时间戳：Time.now.to_i&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Server&lt;/td&gt;
&lt;td&gt;SELECT DATEDIFF(s, '1970-01-01 00:00:00', GETUTCDATE())&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unix / Linux&lt;/td&gt;
&lt;td&gt;date +%s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VBScript / ASP&lt;/td&gt;
&lt;td&gt;DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, Now())&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他操作系统
(如果Perl被安装在系统中)&lt;/td&gt;
&lt;td&gt;命令行状态：perl -e &quot;print time&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;如何在不同编程语言中实现Unix时间戳(Unix timestamp) → 普通时间？&lt;/h3&gt;


&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;200&quot;&gt;Java&lt;/td&gt;
&lt;td&gt;String date = new java.text.SimpleDateFormat(&quot;dd/MM/yyyy HH:mm:ss&quot;).format(new java.util.Date(Unix timestamp * 1000))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;td&gt;先 var unixTimestamp = new Date(Unix timestamp * 1000) 然后 commonTime = unixTimestamp.toLocaleString()&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linux&lt;/td&gt;
&lt;td&gt;date -d @Unix timestamp&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;from_unixtime(Unix timestamp)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;td&gt;先 my $time = Unix timestamp 然后 my ($sec, $min, $hour, $day, $month, $year) = (localtime($time))[0,1,2,3,4,5,6]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;date('r', Unix timestamp)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;SELECT TIMESTAMP WITH TIME ZONE 'epoch' + Unix timestamp) * INTERVAL '1 second';&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;先 import time 然后 time.gmtime(Unix timestamp)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;Time.at(Unix timestamp)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Server&lt;/td&gt;
&lt;td&gt;DATEADD(s, Unix timestamp, '1970-01-01 00:00:00')&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VBScript / ASP&lt;/td&gt;
&lt;td&gt;DateAdd(&quot;s&quot;, Unix timestamp, &quot;01/01/1970 00:00:00&quot;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;其他操作系统
(如果Perl被安装在系统中)&lt;/td&gt;
&lt;td&gt;命令行状态：perl -e &quot;print scalar(localtime(Unix timestamp))&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;如何在不同编程语言中实现普通时间 → Unix时间戳(Unix timestamp)？&lt;/h3&gt;


&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;200&quot;&gt;Java&lt;/td&gt;
&lt;td&gt;long epoch = new java.text.SimpleDateFormat(&quot;dd/MM/yyyy HH:mm:ss&quot;).parse(&quot;01/01/1970 01:00:00&quot;);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JavaScript&lt;/td&gt;
&lt;td&gt;var commonTime = new Date(Date.UTC(year, month - 1, day, hour, minute, second))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;SELECT unix_timestamp(time)
时间格式: YYYY-MM-DD HH:MM:SS 或 YYMMDD 或 YYYYMMDD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Perl&lt;/td&gt;
&lt;td&gt;先 use Time::Local 然后 my $time = timelocal($sec, $min, $hour, $day, $month, $year);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PHP&lt;/td&gt;
&lt;td&gt;mktime(hour, minute, second, day, month, year)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PostgreSQL&lt;/td&gt;
&lt;td&gt;SELECT extract(epoch FROM date('YYYY-MM-DD HH:MM:SS'));&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;先 import time 然后 int(time.mktime(time.strptime('YYYY-MM-DD HH:MM:SS', '%Y-%m-%d %H:%M:%S')))&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;Time.local(year, month, day, hour, minute, second)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SQL Server&lt;/td&gt;
&lt;td&gt;SELECT DATEDIFF(s, '1970-01-01 00:00:00', time)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Unix / Linux&lt;/td&gt;
&lt;td&gt;date +%s -d&quot;Jan 1, 1970 00:00:01&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VBScript / ASP&lt;/td&gt;
&lt;td&gt;DateDiff(&quot;s&quot;, &quot;01/01/1970 00:00:00&quot;, time)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>2006年Google面试题：确定临界楼层</title>
   <link href="http://dreambt.github.com/Other/2011/04/06/2006-google-interview-determine-critical-floor"/>
   <updated>2011-04-06T22:31:03+08:00</updated>
   <id>http://dreambt.github.com/Other/2011/04/06/2006-google-interview-determine-critical-floor</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;有一个100层高的大厦，你手中有两个相同的玻璃围棋子。从这个大厦的某一层扔下围棋子就会碎，用你手中的这两个玻璃围棋子，找出一个最优的策略，来得知那个临界层面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来自焦萌的分析&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;为了得到两个棋子的最优策略，我们先简化问题，看看一个棋子的情况。如果手中只有一个棋子，为了得知临界层面，你只有一种选择：从2楼开始，一层一层地试，直到棋子被打碎，此时你站的楼层就是所求的临界层面。在最差的情况下，我们需要投掷99-2+1=98次，你可能奇怪为什么不是100-2+1=99次，那是因为题目已经告诉我们“从这个大厦的某一层扔下围棋子就会碎”，所以在99层扔下来还没碎的话就不用去100层了——从那里扔它一定会碎。&lt;/p&gt;

&lt;p&gt;从一个棋子的策略我们可以看出，一个棋子就足以解答这个问题了。现在又多了一个棋子，该如何利用它呢？很自然地，我们希望能通过这个棋子缩小这种一层一层查找的范围。为了缩小范围，我们将整个大厦的层数分成x段，在这x段中查找那个临界段，然后在临界段中再一层一层地找临界层。比如可以将大楼分成4段，我们分别在25层、50层、75层投掷棋子，以确定临界段；如果临界段在25层到50层，我们再从26层开始一层一层查找临界层。&lt;/p&gt;

&lt;p&gt;分析到这里，问题就转化成了如何确定分段数x使棋子投掷的次数最少的问题。在最差的情况下，要确定临界段，我们需要投掷100/x-1次；确定了临界段之后要确定临界层，我们需要再投掷x-1次。因此，问题就成了求函数f(x)=(100/x-1)+(x-1)的最小值问题。先对f(x)求导，f’(x)=1-100/x2，令f’(x)=0求出驻点x=10(x=-10舍去)。由于f(x)存在最小值且只有一个驻点，所以当x=10时f(x)取得最小值，最小值为18。这样就解答了这个问题。&lt;/p&gt;

&lt;p&gt;其实10这个结果也很容易直接看出来。在只有一个棋子时，我们相当于把整个大厦分成了一段，这一段有100层。在有两个棋子时，我们有很多分法，但无论怎么分，如果分成k1段，每段有k2层，那么就有k1k2=100。在最坏的情况下，我们需要投掷(k1-1)+(k2-1)次。因此问题也可以表述成在k1k2=100的条件约束下，如何让函数f(k1,k2)= k1+k2最小。在初等数学中，我们知道在矩形面积一定的情况下，正方形的周长最小。利用这个结论，我们可以直接得出结论k1=k2=10。&lt;/p&gt;

&lt;p&gt;现在问题已经完满解决，但我还想把这个问题扩展一下，把它变成“m层楼n个棋子”的情况。首先来看这样一个问题，给定m层楼，多少个棋子就“足够”了，也就是说，再多的棋子也不能加快查找的过程。在我所能想到的方法里，二分法应该是最优的，如果按二分法来查找，则需要ceiling(log2m)个棋子（ceiling是向上取整函数），超过这个数再多的棋子也无益。&lt;/p&gt;

&lt;p&gt;如果n&amp;gt;=ceiling(log2m)，那就采用二分法，现在考虑n&amp;lt; ceiling(log2m)的情况。前面已经看到，当n=2时，问题可以表述成在k1k2=100的条件约束下，求函数f(k1,k2)= k1+k2的最小值。类似地，在n个棋子的情况下，问题可以表述成在k1k2…kn=m的条件约束下，求函数f(k1,k2,…,kn)=k1+k2+…+kn的最小值。利用拉格朗日乘数法，我们可以很容易地求出：当k1=k2=…=kn=n√m时，这个多元函数取得最值。n√m有可能不是整数，因此这只是一个理论上的结果。&lt;/p&gt;

&lt;p&gt;我们换一个思路考虑，m层楼n个棋子的问题其实就是如何将m分解成n个因子相乘，从而让各个因子之和最小。如何分解m使得策略最优就成了问题的关键。前面得出的结论提示我们尽量让各个因子相等或者相差较小，它们相加的结果才会较小。比如，100层楼3个棋子的情况，5，5，4应该是一个最优的选择。&lt;/p&gt;

&lt;p&gt;考虑到这里，又有一个问题出现了：是不是将m分解的越多越好呢？比如，将100分解成10，10好呢，还是2，5，10好？这个问题其实就是在问，两个大于1的整数，它们的和大呢还是积大。很明显，当然是积大，因此将m分解的越多越好。&lt;/p&gt;

&lt;p&gt;数论告诉我们，质数是整数的基础，所有整数都可以分解成若干个质数的乘积。因此，如果将上面的方法发挥到极致，那就要求我们把m分解成质数的乘积。当然，如果棋子足够多，这并不是最优的方法，对质数层楼的段，你仍然可以采用二分法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来自kingkingxy的分析&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;最多14次。 从14层开始扔第一次，如果碎了，那么从第2层开始扔，一层层加，直到13层。一共14次。
如果没有碎。27层再扔一次。依次推理，从15层到26层一共12次。加上前面的14层，27层2次所以说也是14次。
依次这样扔
14
14+13=27
27+12=39
39+11=50
50+10=60
60+9=69
69+8=77
77+7=84
84+6=90
90+5=95
96
97
98
99&lt;/p&gt;

&lt;p&gt;最多14次&lt;/p&gt;

&lt;p&gt;1+2+3=6       （6+1）=7   如果是扔3次，最多能扔到7楼
1+2+3+4=10（10+1）=11     如果是扔4次，最多能扔到11楼
...
1+2+3+4+..+14=105   （105+1）=106       如果扔14次最多能扔到   106   楼。&lt;/p&gt;

&lt;p&gt;如果200楼的话，按照这种方法。应该需要扔20次&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;来自阿丹的分析&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;假设n为棋子数，i为可以扔的次数，F（n，i）表示可以确保能得到临界点的最大楼层数。&lt;/p&gt;

&lt;p&gt;要求n个棋子，楼层为f的情况下的最优解，首先找到i使得F（n，i-1） &amp;lt;f并且F（n，i）&amp;gt; =f。
i即至少需要扔i次才能确保找到临界点。第一次扔的楼层为F（n-1，i-1）+1，以此类推根据第一次扔的结果确定第二次扔的楼层。&lt;/p&gt;

&lt;p&gt;对于google的这道题，首先要找到i使得F（2，i-1） &amp;lt;100并且F（2，i）&amp;gt; =100。
F（2，2）=   3
F（2，3）=   3+2+1   =6
F（2，4）=   6+3+1   =10
F（2，5）=   10+4+1   =15
可以发现F（2，n）正好等于1到n的和。
F（2，13）=   91
F（2，14）=   105
得到i   =   14，至少需要14次可以确定临界点。
至于要得到所有情况下扔的次数最少的最优解，应该不止一种。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;补充两句&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;把问题还原一下吧。&lt;/p&gt;

&lt;p&gt;Google是做搜索引擎的，对海量数据的检索实时性要求很高，因此如果设计一个算法是2层嵌套的话，外层嵌套应该为内层循环做出牺牲。但是这个牺牲不是不计代价的，应该做到总体利益的最大化。其次，外层循环应该为内层循环扫除障碍，缩小内层循环的压力。&lt;/p&gt;

&lt;p&gt;n等分查找法，内外层分担的风险都是1/n，外层循环壮烈的时机对内层循环没有实质的影响。但是有种可能，第一个球n次下来都没有坏掉，但是内层循环的压力却一直保持1/n。&lt;/p&gt;

&lt;p&gt;递减查找法，内层循环作为外层循环的接班人，外层一旦壮烈内层马上上阵。同样存在外层一直不死的情况，但是内层的压力确是一直在减小的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;讨论地址&lt;/strong&gt;：&lt;a href=&quot;http://topic.csdn.net/t/20061206/10/5209914.html&quot;&gt;http://topic.csdn.net/t/20061206/10/5209914.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java数据类型转化，特别是Double转Long</title>
   <link href="http://dreambt.github.com/Java/2011/04/02/java-data-type-double-long"/>
   <updated>2011-04-02T13:13:33+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/04/02/java-data-type-double-long</id>
   <content type="html">&lt;p&gt;简单来说，Java的数据类型转化还是很简单的，基本上分为自动类型转化和强制类型转化。然而今天却越到了戏剧性的一幕。&lt;/p&gt;

&lt;p&gt;最近在研究一个小系统的设计，其中就用到了Double类型向Long类型的转化。Long类里面居然没有专门的转化方法，于是从网上搜到这么一句：&lt;/p&gt;

&lt;p&gt;[code]Long l1 = Math.round(d1);[/code]&lt;/p&gt;

&lt;p&gt;这样貌似没有任何问题，但是Math.round()方法返回的确实int型数据，因此可能导致丢失精度。所以我给出的建议还是采用如下的代码：&lt;/p&gt;

&lt;p&gt;[code]Long l1 = (Long)d1;[/code]&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;

&lt;strong&gt;&lt;span style=&quot;font-size: small;&quot;&gt;数据类型&lt;/span&gt;&lt;/strong&gt;

基本类型有以下四种：
int长度数据类型有：byte(8bits)、short(16bits)、int(32bits)、long(64bits)、
float长度数据类型有：单精度（32bits float）、双精度（64bits double）
boolean类型变量的取值有：ture、false
char数据类型有：unicode字符(16位)
对应的类类型：Integer、Float、Boolean、Character、Double、Short、Byte、Long

&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;&lt;span style=&quot;font-size: small;&quot;&gt;转换原则&lt;/span&gt;&lt;/strong&gt;从低精度向高精度转换
byte 、short、int、long、float、double、char
注：两个char型运算时，自动转换为int型；当char与别的类型运算时，也会先自动转换为int型的，再做其它类型的自动转换

基本类型向类类型转换

正向转换：通过类包装器来new出一个新的类类型的变量
Integer a= new Integer(2);
反向转换：通过类包装器来转换
int b=a.intValue();

类类型向字符串转换

正向转换：因为每个类都是object类的子类，而所有的object类都有一个toString()函数，所以通过toString()函数来转换即可
反向转换：通过类包装器new出一个新的类类型的变量
eg1: int i=Integer.valueOf(“123”).intValue()
说明：上例是将一个字符串转化成一个Integer对象，然后再调用这个对象的intValue()方法返回其对应的int数值。
eg2: float f=Float.valueOf(“123”).floatValue()
说明：上例是将一个字符串转化成一个Float对象，然后再调用这个对象的floatValue()方法返回其对应的float数值。
eg3: boolean b=Boolean.valueOf(“123”).booleanValue()
说明：上例是将一个字符串转化成一个Boolean对象，然后再调用这个对象的booleanValue()方法返回其对应的boolean数值。
eg4:double d=Double.valueOf(“123”).doubleValue()
说明：上例是将一个字符串转化成一个Double对象，然后再调用这个对象的doubleValue()方法返回其对应的double数值。
eg5: long l=Long.valueOf(“123”).longValue()
说明：上例是将一个字符串转化成一个Long对象，然后再调用这个对象的longValue()方法返回其对应的long数值。
eg6: char=Character.valueOf(“123”).charValue()
说明：上例是将一个字符串转化成一个Character对象，然后再调用这个对象的charValue()方法返回其对应的char数值。

基本类型向字符串的转换
正向转换：
如：int a=12;
String b;b=a+””;

反向转换：
通过类包装器
eg1:int i=Integer.parseInt(“123”)
说明：此方法只能适用于字符串转化成整型变量
eg2: float f=Float.valueOf(“123”).floatValue()
说明：上例是将一个字符串转化成一个Float对象，然后再调用这个对象的floatValue()方法返回其对应的float数值。
eg3: boolean b=Boolean.valueOf(“123”).booleanValue()
说明：上例是将一个字符串转化成一个Boolean对象，然后再调用这个对象的booleanValue()方法返回其对应的boolean数值。
eg4:double d=Double.valueOf(“123”).doubleValue()
说明：上例是将一个字符串转化成一个Double对象，然后再调用这个对象的doubleValue()方法返回其对应的double数值。
eg5: long l=Long.valueOf(“123”).longValue()
说明：上例是将一个字符串转化成一个Long对象，然后再调用这个对象的longValue()方法返回其对应的long数值。
eg6: char=Character.valueOf(“123”).charValue()
说明：上例是将一个字符串转化成一个Character对象，然后再调用这个对象的charValue()方法返回其对应的char数值。

&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;JAVA中常用数据类型转换函数 &lt;/strong&gt;
虽然都能在JAVA API中找到，整理一下做个备份。&lt;/div&gt;


&lt;div&gt;string-&amp;gt;byte
Byte static byte parseByte(String s)&lt;/div&gt;


&lt;div&gt;byte-&amp;gt;string
Byte static String toString(byte b)&lt;/div&gt;


&lt;div&gt;char-&amp;gt;string
Character static String toString (char c)&lt;/div&gt;


&lt;div&gt;string-&amp;gt;Short
Short static Short parseShort(String s)&lt;/div&gt;


&lt;div&gt;Short-&amp;gt;String
Short static String toString(Short s)&lt;/div&gt;


&lt;div&gt;String-&amp;gt;Integer
Integer static int parseInt(String s)&lt;/div&gt;


&lt;div&gt;Integer-&amp;gt;String
Integer static String tostring(int i)&lt;/div&gt;


&lt;div&gt;String-&amp;gt;Long
Long static long parseLong(String s)&lt;/div&gt;


&lt;div&gt;Long-&amp;gt;String
Long static String toString(Long i)&lt;/div&gt;


&lt;div&gt;String-&amp;gt;Float
Float static float parseFloat(String s)&lt;/div&gt;


&lt;div&gt;Float-&amp;gt;String
Float static String toString(float f)&lt;/div&gt;


&lt;div&gt;String-&amp;gt;Double
Double static double parseDouble(String s)&lt;/div&gt;


&lt;div&gt;Double-&amp;gt;String
Double static String toString(Double)&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>GoF设计模式之Prototype(原型模式)</title>
   <link href="http://dreambt.github.com/Design Pattern/2011/03/30/gof-prototype"/>
   <updated>2011-03-30T12:24:48+08:00</updated>
   <id>http://dreambt.github.com/Design Pattern/2011/03/30/gof-prototype</id>
   <content type="html">&lt;p&gt;名称：Prototype(原型模式)&lt;/p&gt;

&lt;p&gt;分类：创建模式&lt;/p&gt;

&lt;p&gt;意图：&lt;/p&gt;

&lt;p&gt;问题：&lt;/p&gt;

&lt;p&gt;解决方案：&lt;/p&gt;

&lt;p&gt;参与者和协作者：&lt;/p&gt;

&lt;p&gt;效果：&lt;/p&gt;

&lt;p&gt;实现：&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;原型模式定义:
用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象.&lt;/p&gt;

&lt;p&gt;Prototype模式允许一个对象再创建另外一个可定制的对象，根本无需知道任何如何创建的细节,工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建。&lt;/p&gt;

&lt;p&gt;如何使用?
因为Java中的提供clone()方法来实现对象的克隆,所以Prototype模式实现一下子变得很简单.&lt;/p&gt;

&lt;p&gt;以勺子为例：&lt;/p&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;3&quot; width=&quot;96%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;#CCCCCC&quot;&gt;public abstract class AbstractSpoon implements Cloneable
{
String spoonName;

public void setSpoonName(String spoonName) {this.spoonName = spoonName;}
public String getSpoonName() {return this.spoonName;}

public Object clone()
{
Object object = null;
try {
object = super.clone();
} catch (CloneNotSupportedException exception) {
System.err.println(&quot;AbstractSpoon is not Cloneable&quot;);
}
return object;
}
}&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;有个具体实现(ConcretePrototype):&lt;/p&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;3&quot; cellpadding=&quot;3&quot; width=&quot;92%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor=&quot;#CCCCCC&quot;&gt;public class SoupSpoon extends AbstractSpoon
{
public SoupSpoon()
{
setSpoonName(&quot;Soup Spoon&quot;);
}
}

&amp;nbsp;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;调用Prototype模式很简单:&lt;/p&gt;

&lt;p&gt;AbstractSpoon spoon = new SoupSpoon();
AbstractSpoon spoon2 = spoon.clone();&lt;/p&gt;

&lt;p&gt;当然也可以结合工厂模式来创建AbstractSpoon实例。&lt;/p&gt;

&lt;p&gt;在Java中Prototype模式变成clone()方法的使用，由于Java的纯洁的面向对象特性，使得在Java中使用设计模式变得很自然，两者已经几乎是浑然一体了。这反映在很多模式上，如Interator遍历模式。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何让现有的Apache服务器支持SVN</title>
   <link href="http://dreambt.github.com/Version Control/2011/03/28/apache-svn"/>
   <updated>2011-03-28T20:34:07+08:00</updated>
   <id>http://dreambt.github.com/Version Control/2011/03/28/apache-svn</id>
   <content type="html">&lt;p&gt;如果我们的服务器已经安装有Apache，那么如何可以改造一下使之支持SVN呢？&lt;/p&gt;

&lt;p&gt;首先下载Subversion和Apache，可以到相关的网站下载&lt;/p&gt;

&lt;p&gt;SVN: &lt;a href=&quot;http://subversion.tigris.org/&quot;&gt;http://subversion.tigris.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Apache: &lt;a href=&quot;http://httpd.apache.org/&quot;&gt;http://httpd.apache.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装Apache和SVN不是本文讲解的重点，主要关心&lt;strong&gt;两者配置问题&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先将Subversion的bin\目录下面的两个文件：mod_authz_svn.so和mod_dav_svn.so复制到Apache安装目录modules\目录下； 再将Subversion安装目录bin\下面的所有.dll文件和svnadmin.exe复制到Apache安装目录bin\目录下（注意：不要替换任何文件！！！）。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;2.配置Apache下conf目录里的httpd.conf，找到下面两行，并且去掉‘#’（注释的作用）.&lt;/p&gt;

&lt;h1&gt;LoadModule dav_module modules/mod_dav.so&lt;/h1&gt;

&lt;h1&gt;LoadModule dav_fs_module modules/mod_dav_fs.so&lt;/h1&gt;

&lt;p&gt;然后需要添加刚才拷贝的那两个文件mod_authz_svn.so和mod_dav_svn.so。方法如下：&lt;/p&gt;

&lt;p&gt;在所有LoadModule语句的最后添加两行：
LoadModule dav_svn_module modules/mod_dav_svn.so
LoadModule authz_svn_module modules/mod_authz_svn.so&lt;/p&gt;

&lt;p&gt;此时，SVN基本上已经添加到Apache。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SVN的配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.配置SVN，首先需要创建一个文件夹来保存文件，如d:\SVN_Repository.&lt;/p&gt;

&lt;p&gt;打开cmd到c:\Program Files\Apache2.2\bin&amp;gt;svnadmin create d:\SVN_Repository\Porject (Porjcet文件夹就是用来保存文件的目录)&lt;/p&gt;

&lt;p&gt;2.创建保存用户密码的文件，svn_auth_passwd。&lt;/p&gt;

&lt;p&gt;打开cmd到c:\Program Files\Apache2.2\bin&amp;gt;htpasswd -c d:\SVN_Repository\Porject\svn_auth_passwd XXX&lt;/p&gt;

&lt;p&gt;这时会提示你输入新的密码，按照指示做就会生成svn_auth_passwd文件在d:\SVN_Repository\Porject\目录下。&lt;/p&gt;

&lt;p&gt;创建密码文件的时候需要用-c，但是如果要追加用户需要用-m，其余命令可以看help。&lt;/p&gt;

&lt;p&gt;例如要追加用户XXX1，则c:\Program Files\Apache2.2\bin&amp;gt;htpasswd -m d:\SVN_Repository\Porject\svn_auth_passwd XXX1.&lt;/p&gt;

&lt;p&gt;创建完密码之后还需要在httpd.conf配置认证信息，配置完之后，访问SVN才会有让你输入密码的提示。&lt;/p&gt;

&lt;p&gt;3.在httpd.conf文件里配置文件的存放路径，SVNParentPath指令来指定存放所有项目的路径。
&amp;lt;Location /svn&amp;gt;
DAV svn
SVNParentPath d:/Svn_Repository
AuthType Basic#认证类型
AuthName &quot;Subversion repositories&quot;
AuthUserFile &quot;d:/Svn_Repository/svn_auth_passwd&quot;#存储用户登录的信息。
Require valid-user
&amp;lt;/Location&amp;gt;&lt;/p&gt;

&lt;p&gt;这样配置完之后运行Apache，就可以访问SVN了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>全面认识UML-类图元素</title>
   <link href="http://dreambt.github.com/UML/2011/03/27/uml-class-diagram-elements"/>
   <updated>2011-03-27T16:19:27+08:00</updated>
   <id>http://dreambt.github.com/UML/2011/03/27/uml-class-diagram-elements</id>
   <content type="html">&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;开发Java应用程序时，开发者要想有效地利用统一建模语言（UML），必须全面理解UML元素以及这些元素如何映射到Java。本文重点讨论UML类图中的元素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;类图是最常用的UML图，它用于描述系统的结构化设计。其中包括类关系以及与每个类关联的属性及行为。类图能出色地表示继承与合成关系。为了将类图作为一种高效的沟通工具使用，开发者必须理解如何将类图上出现的元素转换到Java中。下面来进一步探索这一转换过程。&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;元素
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;在后面的小节中，分别讲解了类图的各个元素及其在Java中相应的表示。我会列出元素名，后续简短的代码片断和一幅图来表示元素在类图上的样子。每一节的最后简要总结了该元素。&lt;/span&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;类（Class）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;类（&lt;strong&gt;图A&lt;/strong&gt;）是对象的蓝图，其中包含3个组成部分。第一个是Java中定义的类名。第二个是属性（attributes）。第三个是该类提供的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;属性和操作之前可附加一个可见性修饰符。加号（+）表示具有公共可见性。减号（-）表示私有可见性。#号表示受保护的可见性。省略这些修饰符表示具有package（包）级别的可见性。如果属性或操作具有下划线，表明它是静态的。在操作中，可同时列出它接受的参数，以及返回类型，如图A的“Java”区域所示。&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;图A&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReN1YN/medium.jpg&quot; alt=&quot;image001|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;包（Package）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;包（图&lt;strong&gt;B&lt;/strong&gt;）是一种常规用途的组合机制。UML中的一个包直接对应于Java中的一个包。在Java中，一个包可能含有其他包、类或者同时含有这两者。进行建模时，你通常拥有逻辑性的包，它主要用于对你的模型进行组织。你还会拥有物理性的包，它直接转换成系统中的Java包。每个包的名称对这个包进行了惟一性的标识。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图B&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReN40M/medium.jpg&quot; alt=&quot;image002|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt; 接口（Interface）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;接口（&lt;strong&gt;图C&lt;/strong&gt;）是一系列操作的集合，它指定了一个类所提供的服务。它直接对应于Java中的一个接口类型。接口既可用图C的那个图标来表示，也可由附加了&amp;lt;&amp;lt;interface&amp;gt;&amp;gt;的一个标准类来表示。通常，根据接口在类图上的样子，就能知道与其他类的关系。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图C&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNcMM/medium.jpg&quot; alt=&quot;image003|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;关系
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;后面的例子将针对某个具体目的来独立地展示各种关系。虽然语法无误，但这些例子可进一步精炼，在它们的有效范围内包括更多的语义。&lt;/span&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;依赖（Dependency）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;实体之间一个“使用”关系暗示一个实体的规范发生变化后，可能影响依赖于它的其他实例（&lt;strong&gt;图D&lt;/strong&gt;）。更具体地说，它可转换为对不在实例作用域内的一个类或对象的任何类型的引用。其中包括一个局部变量，对通过方法调用而获得的一个对象的引用（如下例所示），或者对一个类的静态方法的引用（同时不存在那个类的一个实例）。也可利用“依赖”来表示包和包之间的关系。由于包中含有类，所以你可根据那些包中的各个类之间的关系，表示出包和包的关系。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图D&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNlzx/medium.jpg&quot; alt=&quot;image004|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt; 关联（Association）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;实体之间的一个结构化关系表明对象是相互连接的。箭头是可选的，它用于指定导航能力。如果没有箭头，暗示是一种双向的导航能力。在Java中，关联（&lt;strong&gt;图E&lt;/strong&gt;）转换为一个实例作用域的变量，就像图E的“Java”区域所展示的代码那样。可为一个关联附加其他修饰符。多重性（Multiplicity）修饰符暗示着实例之间的关系。在示范代码中，Employee可以有0个或更多的TimeCard对象。但是，每个TimeCard只从属于单独一个Employee。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图E&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNsrQ/medium.jpg&quot; alt=&quot;image005|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;聚合（Aggregation）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;聚合（&lt;strong&gt;图F&lt;/strong&gt;）是关联的一种形式，代表两个类之间的整体/局部关系。聚合暗示着整体在概念上处于比局部更高的一个级别，而关联暗示两个类在概念上位于相同的级别。聚合也转换成Java中的一个实例作用域变量。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;关联和聚合的区别纯粹是概念上的，而且严格反映在语义上。聚合还暗示着实例图中不存在回路。换言之，只能是一种单向关系。&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图F&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNxb1/medium.jpg&quot; alt=&quot;image007|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;合成（Composition）&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;合成 （&lt;strong&gt;图G&lt;/strong&gt;）是聚合的一种特殊形式，暗示“局部”在“整体”内部的生存期职责。合成也是非共享的。所以，虽然局部不一定要随整体的销毁而被销毁，但整体要么负责保持局部的存活状态，要么负责将其销毁。局部不可与其他整体共享。但是，整体可将所有权转交给另一个对象，后者随即将承担生存期职责。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;Employee和TimeCard的关系或许更适合表示成“合成”，而不是表示成“关联”。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图G&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNG33/medium.jpg&quot; alt=&quot;image008|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt;泛化（Generalization）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;泛化（&lt;strong&gt;图H&lt;/strong&gt;）表示一个更泛化的元素和一个更具体的元素之间的关系。泛化是用于对继承进行建模的UML元素。在Java中，用&lt;em&gt;extends&lt;/em&gt;关键字来直接表示这种关系。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图H&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNHE7/medium.jpg&quot; alt=&quot;image009|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt; 实现（Realization）
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;实例（&lt;strong&gt;图I&lt;/strong&gt;）关系指定两个实体之间的一个合同。换言之，一个实体定义一个合同，而另一个实体保证履行该合同。对Java应用程序进行建模时，实现关系可直接用&lt;em&gt;implements&lt;/em&gt;关键字来表示。&lt;/span&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;span style=&quot;color: #000000;&quot;&gt;图I&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;img class=&quot;aligncenter&quot; src=&quot;http://pic.yupoo.com/dreambt/AWReNKDJ/medium.jpg&quot; alt=&quot;image006|yupoo.com&quot; /&gt;&lt;/p&gt;

&lt;h5&gt;&lt;span style=&quot;color: #000000;&quot;&gt; 精确映射
&lt;/span&gt;&lt;/h5&gt;


&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;如本文所述，UML类图上的元素能精确映射到Java编程语言。开发团队的成员可利用这种精确性来加强沟通，取得对系统结构化设计的共识。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #000000;&quot;&gt;转载：&lt;a href=&quot;http://www.cnblogs.com/kenjie/archive/2009/03/24/1420203.html&quot;&gt;http://www.cnblogs.com/kenjie/archive/2009/03/24/1420203.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu环境下配置JDK</title>
   <link href="http://dreambt.github.com/Linux/2011/03/21/ubuntu-jdk"/>
   <updated>2011-03-21T16:30:54+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/03/21/ubuntu-jdk</id>
   <content type="html">&lt;p&gt;首先，从&lt;a href=&quot;http://www.oracle.com/technetwork/java/javaee/downloads/index.html&quot;&gt;http://www.oracle.com/technetwork/java/javaee/downloads/index.html&lt;/a&gt;中下载jdk,我的版本是jdk1.6.0_24，我将下载的jdk1.6.0_24.bin文件置于/opt中.然后，在shell中执行：&lt;/p&gt;

&lt;pre&gt;sudo chmod u+x /opt/jdk1.6.0_24.bin&lt;/pre&gt;


&lt;p&gt;修改bin文件权限，使其可执行.然后，执行&lt;/p&gt;

&lt;pre&gt;sudo /opt/jdk1.6.0_24.bin&lt;/pre&gt;


&lt;p&gt;将会出现字幕，持续按回车键，将会把jdk解压到文件夹，得到jdk1.6.0_24目录。
此时，jdk已安装完毕，下面进行配置，执行gedit /etc/environmen&lt;/p&gt;

&lt;pre&gt;JAVA_HOME=&quot;/opt/jdk1.6.0_24&quot;
CLASSPATH=&quot;.:$JAVA_HOME/lib&quot;
PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:$JAVA_HOME/bin&quot;&lt;/pre&gt;


&lt;p&gt;执行&lt;/p&gt;

&lt;pre&gt;sudo source /home/siqi/.bashrc&lt;/pre&gt;


&lt;p&gt;此时，环境变量设置成功（设置环境变量的方法很多，不一一列举）
由于ubuntu中可能会有默认的jdk，如openjdk，所以，为了使默认使用的是我们安装的jdk，还要进行如下工作。
执行&lt;/p&gt;

&lt;pre&gt;update-alternatives --install /usr/bin/java java /opt/jdk1.6.0_24/bin/java 300
update-alternatives --install /usr/bin/javac javac /opt/jdk1.6.0_24/bin/javac 300&lt;/pre&gt;


&lt;p&gt;通过这一步将我们安装的jdk加入java选单。
然后执行&lt;/p&gt;

&lt;pre&gt;update-alternatives --config java&lt;/pre&gt;


&lt;p&gt;通过这一步选择系统默认的jdk
这样，再在shell中输入&lt;/p&gt;

&lt;pre&gt;java -version&lt;/pre&gt;


&lt;p&gt;时，就会显示系统使用的java是sun的java。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MySQL的连接/联结（Join）语法</title>
   <link href="http://dreambt.github.com/Database/2011/03/19/mysql-join"/>
   <updated>2011-03-19T21:03:52+08:00</updated>
   <id>http://dreambt.github.com/Database/2011/03/19/mysql-join</id>
   <content type="html">&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;．内联结、外联结、左联结、右联结的含义及区别：&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;在讲MySQL的Join语法前还是先回顾一下联结的语法，国内关于MySQL联结查询的资料十分少，相信大家在看了本文后会对MySQL联结语法有相当清晰的了解，也不会被Oracle的外联结的（“＋”号）弄得糊涂了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;在SQL标准中规划的（Join）联结大致分为下面四种：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;1．  内联结：将两个表中存在联结关系的字段符合联结关系的那些记录形成记录集的联结。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2．  外联结：分为外左联结和外右联结。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;左联结A、B表的意思就是将表A中的全部记录和表B中联结的字段与表A的联结字段符合联结条件的那些记录形成的记录集的联结，这里注意的是最后出来的记录集会包括表A的全部记录。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;右联结A、B表的结果和左联结B、A的结果是一样的，也就是说：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Select A.name B.name From A Left Join B On A.id=B.id&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;和Select A.name B.name From B Right Join A on B.id=A.id执行后的结果是一样的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;3．全联结：将两个表中存在联结关系的字段的所有记录取出形成记录集的联结（这个不需要记忆，只要是查询中提到了的表的字段都会取出，无论是否符合联结条件，因此意义不大）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;4．无联结：不用解释了吧，就是没有使用联结功能呗，也有自联结的说法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;这里我有个比较简便的记忆方法，内外联结的区别是内联结将去除所有不符合条件的记录，而外联结则保留其中部分。外左联结与外右联结的区别在于如果用A左联结B则A中所有记录都会保留在结果中，此时B中只有符合联结条件的记录，而右联结相反，这样也就不会混淆了。其实大家回忆高等教育出版社出版的《数据库系统概论》书中讲到关系代数那章（就是将笛卡儿积和投影那章）的内容，相信不难理解这些联结功能的内涵。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;strong&gt;2． &lt;/strong&gt;&lt;strong&gt;MySQL&lt;/strong&gt;&lt;strong&gt;联结（&lt;/strong&gt;&lt;strong&gt;Join&lt;/strong&gt;&lt;strong&gt;）的语法&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;MySQL支持Select和某些Update和Delete情况下的Join语法，具体语法上的细节有：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]
table_references:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table_reference [, table_reference] …
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;table_reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table_factor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  | join_table&lt;/p&gt;

&lt;p&gt;table_factor:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tbl_name [[AS] alias]
    [{USE|IGNORE|FORCE} INDEX (key_list)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  | ( table_references )
  | { OJ table_reference LEFT OUTER JOIN table_reference&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ON conditional_expr }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;join_table:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;table_reference [INNER | CROSS] JOIN table_factor [join_condition]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  | table_reference STRAIGHT_JOIN table_factor
  | table_reference STRAIGHT_JOIN table_factor ON condition
  | table_reference LEFT [OUTER] JOIN table_reference join_condition
  | table_reference NATURAL [LEFT [OUTER]] JOIN table_factor
  | table_reference RIGHT [OUTER] JOIN table_reference join_condition
  | table_reference NATURAL [RIGHT [OUTER]] JOIN table_factor&lt;/p&gt;

&lt;p&gt;join_condition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ON conditional_expr | USING (column_list)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;上面的用法摘自权威资料，不过大家看了是否有点晕呢？呵呵，应该问题主要还在于table_reference是什么，table_factor又是什么？这里的table_reference其实就是表的引用的意思，因为在MySQL看来，联结就是一种对表的引用，因此把需要联结的表定义为table_reference，同时在SQL Standard中也是如此看待的。而table_factor则是MySQL对这个引用的功能上的增强和扩充，使得引用的表可以是括号内的一系列表，如下面例子中的JOIN后面括号：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]SELECT * FROM t1 LEFT JOIN (t2, t3, t4) ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;这个语句的执行结果和下面语句其实是一样的：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]
SELECT * FROM t1 LEFT JOIN (t2 CROSS JOIN t3 CROSS JOIN t4)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             ON (t2.a=t1.a AND t3.b=t1.b AND t4.c=t1.c)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;这两个例子不仅让我们了解了MySQL中table_factor和table_reference含义，同时能理解一点CROSS JOIN的用法，我要补充的是在MySQL现有版本中CROSS JOIN的作用和INNER JOIN是一样的（虽然在SQL Standard中是不一样的，然而在MySQL中他们的区别仅仅是INNER JOIN需要附加ON参数的语句，而CROSS JOIN不需要）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;既然说到了ON语句，那就解释一下吧，ON语句其实和WHERE语句功能大致相当，只是这里的ON语句是专门针对联结表的，ON语句后面的条件的要求和书写方式和WHERE语句的要求是一样的，大家基本上可以把ON当作WHERE用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;大家也许也看到了OJ table_reference LEFT OUTER JOIN table_reference这个句子，这不是MySQL的标准写法，只是为了和ODBC的SQL语法兼容而设定的，我很少用，Java的人更是不会用，所以也不多解释了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;那下面就具体讲讲简单的JOIN的用法了。首先我们假设有2个表A和B，他们的表结构和字段分别为：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;表A：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;ID&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Name&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tim&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;3&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;John&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tom&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;表B：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;ID&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Hobby&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;1&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Football&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Basketball&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tennis&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;4&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Soccer&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;1．  内联结：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Select A.Name B.Hobby from A, B where A.id = B.id，这是隐式的内联结，查询的结果是：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Name&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Hobby&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tim&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Football&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Basketball&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tennis&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tom&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;96&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Soccer&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;它的作用和 Select A.Name from A INNER JOIN B ON A.id = B.id是一样的。这里的INNER JOIN换成CROSS JOIN也是可以的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2．  外左联结&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Select A.Name from A Left JOIN B ON A.id = B.id，典型的外左联结，这样查询得到的结果将会是保留所有A表中联结字段的记录，若无与其相对应的B表中的字段记录则留空，结果如下：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Name&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;120&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Hobby&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tim&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;120&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Football&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;120&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Basketball，Tennis&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;John&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;120&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tom&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;120&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Soccer&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;所以从上面结果看出，因为A表中的John记录的ID没有在B表中有对应ID，因此为空，但Name栏仍有John记录。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;3．  外右联结&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;如果把上面查询改成外右联结：Select A.Name from A Right JOIN B ON A.id = B.id，则结果将会是：&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Name&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;84&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Hobby&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tim&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;84&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Football&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;84&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Basketball&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Jimmy&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;84&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tennis&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;67&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Tom&lt;/span&gt;&lt;/td&gt;
&lt;td width=&quot;84&quot; valign=&quot;top&quot;&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;Soccer&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;这样的结果都是我们可以从外左联结的结果中猜到的了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;说到这里大家是否对联结查询了解多了？这个原本看来高深的概念一下子就理解了，恍然大悟了吧（呵呵，开玩笑了）？最后给大家讲讲MySQL联结查询中的某些参数的作用：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;1．USING (column_list)：其作用是为了方便书写联结的多对应关系，大部分情况下USING语句可以用ON语句来代替，如下面例子：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;a LEFT JOIN b USING (c1,c2,c3)，其作用相当于下面语句&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;a LEFT JOIN b ON a.c1=b.c1 AND a.c2=b.c2 AND a.c3=b.c3&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;只是用ON来代替会书写比较麻烦而已。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;2．NATURAL [LEFT] JOIN：这个句子的作用相当于INNER JOIN，或者是在USING子句中包含了联结的表中所有字段的Left JOIN（左联结）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;3．STRAIGHT_JOIN：由于默认情况下MySQL在进行表的联结的时候会先读入左表，当使用了这个参数后MySQL将会先读入右表，这是个MySQL的内置优化参数，大家应该在特定情况下使用，譬如已经确认右表中的记录数量少，在筛选后能大大提高查询速度。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;最后要说的就是，在MySQL5.0以后，运算顺序得到了重视，所以对多表的联结查询可能会错误以子联结查询的方式进行。譬如你需要进行多表联结，因此你输入了下面的联结查询：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]
SELECT t1.id,t2.id,t3.id&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM t1,t2
LEFT JOIN t3 ON (t3.id=t1.id)
WHERE t1.id=t2.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;但是MySQL并不是这样执行的，其后台的真正执行方式是下面的语句：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]
SELECT t1.id,t2.id,t3.id&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM t1,(  t2 LEFT JOIN t3 ON (t3.id=t1.id)  )
WHERE t1.id=t2.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;这并不是我们想要的效果，所以我们需要这样输入：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;[code]
SELECT t1.id,t2.id,t3.id&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;FROM (t1,t2)
LEFT JOIN t3 ON (t3.id=t1.id)
WHERE t1.id=t2.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/code]&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;在这里括号是相当重要的，因此以后在写这样的查询的时候我们不要忘记了多写几个括号，至少这样能避免很多错误（因为这样的错误是很难被开发人员发现的）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: xx-small;&quot;&gt;转载：&lt;a href=&quot;http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html&quot;&gt;http://www.blogjava.net/chenpengyi/archive/2005/10/17/15747.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>古典加密技术中最基本的两种算法</title>
   <link href="http://dreambt.github.com/Security/2011/03/14/two-basic-algorithms-in-classical-encryption-technology"/>
   <updated>2011-03-14T12:28:31+08:00</updated>
   <id>http://dreambt.github.com/Security/2011/03/14/two-basic-algorithms-in-classical-encryption-technology</id>
   <content type="html">&lt;p&gt;古典加密技术中最基本的两种算法是替代算法和置换移位法。&lt;/p&gt;

&lt;p&gt;1.替代算法&lt;/p&gt;

&lt;p&gt;替代算法指的是明文的字母由其他字母或数字或符号所代替。最著名的替代算法是凯撒密码。凯撒密码的原理很简单，其实就是单字母替换。我们看一个简单的例子：&lt;/p&gt;

&lt;p&gt;明文：abcdefghijklmnopq&lt;/p&gt;

&lt;p&gt;密文：defghijklmnopqrst&lt;/p&gt;

&lt;p&gt;若明文为student，对应的密文则为vwxghqw 。在这个一一对应的算法中，恺撒密码将字母表用了一种顺序替代的方法来进行加密，此时密钥为3，即每个字母顺序推后3个。由于英文字母为26个，因此恺撒密码仅有26个可能的密钥，非常不安全。&lt;/p&gt;

&lt;p&gt;为了加强安全性，人们想出了更进一步的方法：替代时不是有规律的，而是随机生成一个对照表。&lt;/p&gt;

&lt;p&gt;明文：abcdefghijklmnopqrstuvwxyz&lt;/p&gt;

&lt;p&gt;密文：xnyahpogzqwbtsflrcvmuekjdI&lt;/p&gt;

&lt;p&gt;此时，若明文为student,对应的密文则为 vmuahsm 。这种情况下，解密函数是上面这个替代对照表的一个逆置换。&lt;/p&gt;

&lt;p&gt;不过，有更好的加密手段，就会有更好的解密手段。而且无论怎样的改变字母表中的字母顺序，密码都有可能被人破解。由于英文单词中各字母出现的频度是不一样的，通过对字母频度的统计就可以很容易的对替换密码进行破译。为了抗击字母频度分析，随后产生了以置换移位法为主要加密手段的加密方法。&lt;/p&gt;

&lt;p&gt;2.置换移位法&lt;/p&gt;

&lt;p&gt;使用置换移位法的最著名的一种密码称为维吉尼亚密码。它以置换移位为基础的周期替换密码。&lt;/p&gt;

&lt;p&gt;前面介绍的替代算法中，针对所有的明文字母，密钥要么是一个唯一的数，要么则是完全无规律可寻的。在维吉尼亚密码中，加密密钥是一个可被任意指定的字符串。加密密钥字符依次逐个作用于明文信息字符。明文信息长度往往会大于密钥字符串长度，而明文的每一个字符都需要有一个对应的密钥字符，因此密钥就需要不断循环，直至明文每一个字符都对应一个密钥字符。对密钥字符，我们规定密钥字母a，b，c，d……y，z对应的数字n为：0，1，2，3……24，25。每个明文字符首先找到对应的密钥字符，然后根据英文字母表按照密钥字符对应的数字n向后顺序推后n个字母，即可得到明文字符对应的密文字符。&lt;/p&gt;

&lt;p&gt;如果密钥字为deceptive , 明文为 wearediscoveredsaveyourself，则加密的过程为：&lt;/p&gt;

&lt;p&gt;明文： wearediscoveredsaveyourself&lt;/p&gt;

&lt;p&gt;密钥： deceptivedeceptivedeceptive&lt;/p&gt;

&lt;p&gt;密文： zicvtwqngrzgvtwavzhcqyglmgj&lt;/p&gt;

&lt;p&gt;对明文中的第一个字符w，对应的密钥字符为d，它对应需要向后推3个字母，w,x,y,z,因此其对应的密文字符为z。上面的加密过程中，可以清晰的看到，密钥deceptive被重复使用。&lt;/p&gt;

&lt;p&gt;古典密码体制将数学的方法引入到密码分析和研究中，为现代加密技术的形成和发展奠定了坚实的基础。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&quot;http://zhidao.baidu.com/question/158793154.html&quot;&gt;http://zhidao.baidu.com/question/158793154.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>深入研究java.lang.Class类</title>
   <link href="http://dreambt.github.com/Java/2011/03/12/java-lang-class"/>
   <updated>2011-03-12T21:44:24+08:00</updated>
   <id>http://dreambt.github.com/Java/2011/03/12/java-lang-class</id>
   <content type="html">&lt;p&gt;&lt;span style=&quot;color: #228b22; font-size: small;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;前言：&lt;/span&gt;&lt;/strong&gt;Java的类库日益庞大，所包含的类和接口也不计其数。但其中有一些非常重要的类和接口，是Java类库中的核心部分。常见的有String、Object、Class、Collection、ClassLoader...，熟悉这些类是学好Java的基础。而这些类一般不容易理解，需要做深入的研究和实践才能掌握。下面是我对这些类理解和使用的一些总结。欢迎你在阅读后将你宝贵的意见和读后感留下！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; Java程序在运行时，Java运行时系统一直对所有的对象进行所谓的运行时类型标识。这项信息纪录了每个对象所属的类。虚拟机通常使用运行时类型信息选准正确方法去执行，用来保存这些类型信息的类是Class类。Class类封装一个对象和接口运行时的状态，当装载类时，Class类型的对象自动创建。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; Class 没有公共构造方法。Class 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 defineClass 方法自动构造的，因此不能显式地声明一个Class对象。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; 虚拟机为每种类型管理一个独一无二的Class对象。也就是说，每个类（型）都有一个Class对象。运行程序时，Java虚拟机(JVM)首先检查是否所要加载的类对应的Class对象是否已经加载。如果没有加载，JVM就会根据类名查找.class文件，并将其Class对象载入。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; 基本的 Java 类型（boolean、byte、char、short、int、long、float 和 double）和关键字 void 也都对应一个 Class 对象。 &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; 每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: small; color: #000000;&quot;&gt; 一般某个类的Class对象被载入内存，它就用来创建这个类的所有对象。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;div&gt;

&lt;strong&gt;一、如何得到Class的对象呢？有三种方法可以的获取&lt;/strong&gt;

1、调用Object类的getClass()方法来得到Class对象，这也是最常见的产生Class对象的方法。例如：
MyObject x;
Class c1 = x.getClass();

2、使用Class类的中静态forName()方法获得与字符串对应的Class对象。例如：
Class c2=Class.forName(&quot;MyObject&quot;),Employee必须是接口或者类的名字。

3、获取Class类型对象的第三个方法非常简单。如果T是一个Java类型，那么T.class就代表了匹配的类对象。例如
Class cl1 = Manager.class;
Class cl2 = int.class;
Class cl3 = Double[].class;
注意：Class对象实际上描述的只是类型，而这类型未必是类或者接口。例如上面的int.class是一个Class类型的对象。由于历史原因，数组类型的getName方法会返回奇怪的名字。

&lt;strong&gt;二、Class类的常用方法&lt;/strong&gt;

1、getName()
一个Class对象描述了一个特定类的属性，Class类中最常用的方法getName以 String 的形式返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称。

2、newInstance()
Class还有一个有用的方法可以为类创建一个实例，这个方法叫做newInstance()。例如：
x.getClass.newInstance()，创建了一个同x一样类型的新实例。newInstance()方法调用默认构造器（无参数构造器）初始化新建对象。

3、getClassLoader()
返回该类的类加载器。

4、getComponentType()
返回表示数组组件类型的 Class。

5、getSuperclass()
返回表示此 Class 所表示的实体（类、接口、基本类型或 void）的超类的 Class。

6、isArray()
判定此 Class 对象是否表示一个数组类。

&lt;strong&gt;三、Class的一些使用技巧&lt;/strong&gt;

1、forName和newInstance结合起来使用，可以根据存储在字符串中的类名创建对象。例如
Object obj = Class.forName(s).newInstance();

2、虚拟机为每种类型管理一个独一无二的Class对象。因此可以使用==操作符来比较类对象。例如：
if(e.getClass() == Employee.class)

转自：&lt;a href=&quot;http://dbajun.javaeye.com/blog/121606&quot;&gt;http://dbajun.javaeye.com/blog/121606&lt;/a&gt;

&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SVN trunk, branches and tags</title>
   <link href="http://dreambt.github.com/Version Control/2011/03/12/svn-trunk-branches-and-tags"/>
   <updated>2011-03-12T21:20:03+08:00</updated>
   <id>http://dreambt.github.com/Version Control/2011/03/12/svn-trunk-branches-and-tags</id>
   <content type="html">&lt;p&gt;&lt;em&gt;因水平所限，如果翻译得和原文有差，敬请评论指正。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;在本篇文章中, 我将会详细说明我是如何应用SVN trunk(树干)、branches(分支)和tags(标记)。这种方法同样被称为“branch always”，两者非常接近。可能我所介绍的并不是最好的方法，但是它会给新手一些解释说明，告诉他们trunk、branches和tags是什么，并且该如何去应用它们。&lt;/p&gt;

&lt;p&gt;当然，如果本文有些要点需要澄清/确认，亦或者有一些错误的观点，还请你评论，自由发表自己的观点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;——简单的对比&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SVN的工作机制在某种程度上就像一颗正在生长的树：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;一棵有树干和许多分支的树&lt;/li&gt;
    &lt;li&gt;分支从树干生长出来，并且细的分支从相对较粗的树干中长出&lt;/li&gt;
    &lt;li&gt;一棵树可以只有树干没有分支（但是这种情况不会持续很久，随着树的成长，肯定会有分支啦，^^）&lt;/li&gt;
    &lt;li&gt;一颗没有树干但是有很多分支的树看起来更像是地板上的一捆树枝&lt;/li&gt;
    &lt;li&gt;如果树干患病了，最终分支也会受到影响，然后整棵树就会死亡&lt;/li&gt;
    &lt;li&gt;如果分支患病了，你可以剪掉它，然后其他分支还会生长出来的哦！&lt;/li&gt;
    &lt;li&gt;如果分支生长太快了，对于树干它可能会非常沉重，最后整棵树会垮塌掉&lt;/li&gt;
    &lt;li&gt;当你感觉你的树、树干或者是分支看起来很漂亮的时候，你可以给它照张相，这样就就可以记得它在那时是多么的赞。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;——Trunk&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Trunk是放置稳定代码的主要环境，就好像一个汽车工厂，负责将成品的汽车零件组装在一起。&lt;/p&gt;

&lt;p&gt;以下内容将告诉你如何使用SVN trunk：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;除非你必须处理一些容易且能迅速解决的BUG，或者你必须添加一些无关逻辑的文件（比如媒体文件：图像，视频，CSS等等），否则永远不要在trunk直接做开发&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;不要因为特殊的需求而去对先前的版本做太大的改变，如何相关的情况都意味着需要建立一个branch（如下所述）&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;不要提交一些可能破坏trunk的内容，例如从branch合并&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;如果你在某些时候偶然间破坏了trunk，bring some cake the next day (”with great responsibilities come… huge cakes”)&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;——Branches&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个branch就是从一个SVN仓库中的子树所作的一份普通拷贝。通常情况它的工作类似与UNIX系统上的符号链接，但是你一旦在一个SVN branch里修改了一些文件，并且这些被修改的文件从拷贝过来的源文件独立发展，就不能这么认为了。当一个branch完成了，并且认为它足够稳定的时候，它必须合并回它原来的拷贝的地方，也就是说：如果原来是从trunk中拷贝的，就应该回到trunk去，或者合并回它原来拷贝的父级branch。&lt;/p&gt;

&lt;p&gt;以下内容将告诉你如何使用SVN branches：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;如果你需要修改你的应用程序，或者为它开发一个新的特性，请从trunk中创建一个新的branch，然后基于这个新的分支进行开发&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;除非是因为必须从一个branch中创建一个新的子branch，否则新的branch必须从trunk创建&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;当你创建了一个新branch，你应当立即切换过去。如果你没有这么做，那你为什么要在最初的地方创建这个分支呢？&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;——Tags&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从表面上看，SVN branches和SVN tags没有什么差别，但是从概念上来说，它们有许多差别。其实一个SVN tags就是上文所述的“为这棵树照张相”：一个trunk或者一个branch修订版的命名快照。&lt;/p&gt;

&lt;p&gt;以下内容将告诉你如何使用SVN tags：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;
&lt;div&gt;作为一个开发者，永远不要切换至、取出，或者向一个SVN tag提交任何内容：一个tag好比某种“照片”，并不是实实在在的东西，tags只可读，不可写。&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;在特殊或者需要特别注意的环境中，如：生产环境（production）、？（staging）、测试环境（testing）等等，只能从一个修复过的（fixed）tag中checkout和update，永远不要commit至一个tag。&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;对于上述提及到的环境，可以创建如下的tags：“production”，“staging”，“testing”等等。你也可以根据软件版本、项目的成熟程度来命名tag：“1.0.3”，“stable”，“latest”等等。&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;当trunk已经稳定，并且可以对外发布，也要相应地重新创建tags，然后再更新相关的环境（production, staging, etc）&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;——工作流样例&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设你必须添加了一个特性至一个项目，且这个项目是受版本控制的，你差不多需要完成如下几个步骤：&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;
&lt;div&gt;使用SVN checkout或者SVN switch从这个项目的trunk获得一个新的工作拷贝（branch）&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;使用SVN切换至新的branch&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;完成新特性的开发（当然，要做足够的测试，包括在开始编码前）&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;一旦这个特性完成并且稳定（已提交），并经过你的同事们确认，切换至trunk&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;合并你的分支至你的工作拷贝（trunk），并且解决一系列的冲突&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;重新检查合并后的代码&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;如果可能的话，麻烦你的同事对你所编写、更改的代码进行一次复查（review）&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;提交合并后的工作拷贝至trunk&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;如果某些部署需要特殊的环境（生成环境等等），请更新相关的tag至你刚刚提交到trunk的修订版本&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;
&lt;div&gt;使用SVN update部署至相关环境&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;翻译者：zwws
原　文：&lt;/strong&gt;&lt;a href=&quot;http://www.jmfeurprier.com/blog/2010/02/08/svn-trunk-branches-and-tags/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;SVN trunk, branches and tags&lt;/strong&gt;&lt;/a&gt;
&lt;strong&gt;译　言：&lt;a href=&quot;http://article.yeeyan.org/view/132319/81358&quot;&gt;http://article.yeeyan.org/view/132319/81358&lt;/a&gt;&lt;/strong&gt;
&lt;strong&gt;转载请注明&lt;a href=&quot;http://www.zvv.cn/blog/show-111-1.html&quot;&gt;原链接&lt;/a&gt;，谢谢。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux(Ubuntu)挂载点介绍及桌面服务器分区方案</title>
   <link href="http://dreambt.github.com/Linux/2011/03/02/linux-ubuntu-mount-point-presentations"/>
   <updated>2011-03-02T14:11:20+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/03/02/linux-ubuntu-mount-point-presentations</id>
   <content type="html">&lt;p&gt;本文介绍Linux常用分区挂载点常识以及桌面、服务器分区挂载点的推荐配置，当然这个配置是天缘自己写的，分区大小这个话题是仁者见仁智者见智，欢迎大家一起交流这个话题，比如WEB服务、邮件服务、下载服务等，我们一起交流哪种类型服务下某挂载点应该加大就可以了，至于是否独立就看个人的了。&lt;/p&gt;

&lt;p&gt;一、Linux分区挂载点介绍&lt;/p&gt;

&lt;p&gt;Linux分区挂载点介绍，推荐容量仅供参考不是绝对，跟各系统用途以及硬盘空间配额等因素实际调整：&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;90%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;分区类型&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;介绍&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;备注&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/boot&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;启动分区&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;一般设置100M-200M，boot目录包含了操作系统的内核和在启动系统过程中所要用到的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;根分区&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;所有未指定挂载点的目录都会放到这个挂载点下。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/home&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;用户目录&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;一般每个用户100M左右，特殊用途，比如放大文件也可再加上G。分区大小取决于用户多少。对于多用户使用的电脑，建议把/home独立出来，而且还可以很好地控制普通用户权限等，比如对用户或者用户组实行磁盘配额限制、用户权限访问等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/tmp&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;临时文件&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;一般设置1-5G，方便加载ISO镜像文件使用，对于多用户系统或者网络服务器来也有独立挂载的必要。临时文件目录，也是最常出现问题的目录之一。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/usr&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;文件系统&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;一般设置要3-15G，大部分的用户安装的软件程序都在这里。就像是Windows目录和Program Files目录。很多Linux家族系统有时还会把/usr/local单独作为挂载点使用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/var&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;可变数据目录&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;包含系统运行时要改变的数据。通常这些数据所在的目录的大小是要经常变化的，系统日志记录也在/var/log下。一般多用户系统或者网络服务器要建立这个分区，设立这个分区，对系统日志的维护很有帮助。一般设置2-3G大小，也可以把硬盘余下空间全部分为var。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/srv&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;系统服务目录&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;用来存放service服务启动所需的文件资料目录，不常改变。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/opt&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;附加应用程序&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;存放可选的安装文件，个人一般把自己下载的软件资料存在里面，比如Office、QQ等等。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;swap&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;交换分区&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;一般为内存2倍，最大指定2G即可&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;以下为其它常用的分区挂载点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/bin&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;二进制可执行目录&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;存放二进制可执行程序，里面的程序可以直接通过命令行调用，而不需要进入程序所在的文件夹。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/sbin&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;系统管理员命令存放目录&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;存放标准系统管理员文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;/dev&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;存放设备文件&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;驱动文件等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;58&quot;&gt;...&lt;/td&gt;
&lt;td width=&quot;69&quot;&gt;&lt;/td&gt;
&lt;td width=&quot;451&quot;&gt;不再介绍...&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;当然上面这么多挂载点，实际上是没有比较每个目录都单独进行挂载，我们只需要根据自己的实际使用需要对个别目录进行挂载，这样系统结构看起来也会精简很多。&lt;/p&gt;

&lt;p&gt;一般来讲Linux系统最少的挂载点有两个一个是根挂载点/，另一个是swap，虽然swap也可以采用其他方式类似方式替代，但从使用角度，天缘认为没这个必要，把swap单独设置一个挂载点似乎对Linux系统的标准性更好支持。&lt;/p&gt;

&lt;p&gt;二、Linux系统桌面、服务器分区推荐方案&lt;/p&gt;

&lt;p&gt;下面以80G独立硬盘安装Ubuntu为例，列一下简单的分区方案。&lt;/p&gt;

&lt;p&gt;1、普通桌面用户推荐分区方案（示例：80G桌面用户）：&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;96&quot;&gt;/boot&lt;/td&gt;
&lt;td width=&quot;91&quot;&gt;200M&lt;/td&gt;
&lt;td width=&quot;112&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;96&quot;&gt;/&lt;/td&gt;
&lt;td width=&quot;91&quot;&gt;20G&lt;/td&gt;
&lt;td width=&quot;112&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;96&quot;&gt;/home&lt;/td&gt;
&lt;td width=&quot;91&quot;&gt;50G&lt;/td&gt;
&lt;td width=&quot;112&quot;&gt;余下空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;96&quot;&gt;swap&lt;/td&gt;
&lt;td width=&quot;91&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;112&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;2、服务器用户推荐分区方案一（示例：80GWEB服务器用户，用户程序与系统程序合用usr）：&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/boot&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;200M&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;10G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/tmp&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/var&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/usr&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;10G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;要安装一些常用软件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;/home&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;50G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;余下空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;69&quot;&gt;swap&lt;/td&gt;
&lt;td width=&quot;66&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;165&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;2、服务器用户推荐分区方案二（示例：80GWEB服务器用户，用户程序与系统程序分用opt和usr）：&lt;/p&gt;

&lt;div&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;300&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/boot&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;200M&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;10G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/tmp&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/var&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;5G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/usr&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;10G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;系统安装程序软件使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/opt&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;10G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;用户安装程序软件使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;/home&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;35G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;余下空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td width=&quot;66&quot;&gt;swap&lt;/td&gt;
&lt;td width=&quot;62&quot;&gt;2G&lt;/td&gt;
&lt;td width=&quot;172&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;分区方案关键点：&lt;/p&gt;

&lt;p&gt;——大数据库一般要加大/usr挂载点&lt;/p&gt;

&lt;p&gt;——多用户、下载类、多存储文件等要加大/home挂载点&lt;/p&gt;

&lt;p&gt;——文件小，用户多要注意/tmp和/var挂载点大小&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Windows AIK 3.0制作带ImageX的winPE3.0</title>
   <link href="http://dreambt.github.com/Windows/2011/02/15/windows-aik-3-0-imagex-winpe3-0"/>
   <updated>2011-02-15T14:46:31+08:00</updated>
   <id>http://dreambt.github.com/Windows/2011/02/15/windows-aik-3-0-imagex-winpe3-0</id>
   <content type="html">&lt;p&gt;昨晚刚下载了win7 AIK中文版，看了下里面的技术文档，以下是制作一个简单的winpe3.0的方法&lt;/p&gt;

&lt;p&gt;Win7 AIK中文版下载地址：&lt;a href=&quot;http://www.microsoft.com/downloads/zh-cn/details.aspx?FamilyID=696dd665-9f76-4177-a811-39c26d3b3b34&amp;amp;displaylang=zh-CN&quot; target=&quot;_blank&quot;&gt;http://www.microsoft.com/downloads/zh-cn/details.aspx?FamilyID=696dd665-9f76-4177-a811-39c26d3b3b34&amp;amp;displaylang=zh-CN&lt;/a&gt;&lt;/p&gt;

&lt;h1&gt;步骤 1：设置 Windows PE 构建环境&lt;/h1&gt;


&lt;div id=&quot;sectionSection1&quot;&gt;

在此步骤中，创建支持构建 Windows PE 映像的所需目录结构。
&lt;ol&gt;
    &lt;li&gt;在您的技术人员计算机上，单击&lt;strong&gt;“开始”&lt;/strong&gt;，依次指向&lt;strong&gt;“所有程序”&lt;/strong&gt;、&lt;strong&gt;“Windows OPK”&lt;/strong&gt;或&lt;strong&gt;“Windows AIK”&lt;/strong&gt;，右键单击&lt;strong&gt;“部署工具命令提示符”&lt;/strong&gt;，然后选择&lt;strong&gt;“以管理员身份运行”&lt;/strong&gt;。
菜单快捷方式将打开“命令提示符”窗口，并将环境变量自动设置为指向所有必需的工具。默认情况下，所有工具都安装在  C:\Program Files\&amp;lt;version&amp;gt;\Tools 中，其中 &lt;em&gt;&amp;lt;version&amp;gt;&lt;/em&gt; 可以是 Windows  OPK 或 Windows AIK。&lt;/li&gt;
    &lt;li&gt;在命令提示符下，运行 Copype.cmd 脚本。
该脚本需要使用两个参数：硬件体系结构和目标位置。例如，
&lt;code&gt;copype.cmd  &amp;lt;architecture&amp;gt;  &amp;lt;destination&amp;gt;&lt;/code&gt;
其中，&lt;em&gt;&amp;lt;architecture&amp;gt;&lt;/em&gt; 可以是 x86、amd64 或 ia64，&lt;em&gt;&amp;lt;destination&amp;gt;&lt;/em&gt; 是指向本地目录的路径。例如，
&lt;code&gt;copype.cmd x86  c:\winpe_x86&lt;/code&gt;
此脚本会创建以下目录结构并复制该体系结构的所有必要文件。例如，
&lt;code&gt;\winpe_x86&lt;/code&gt;
&lt;code&gt;\winpe_x86\ISO&lt;/code&gt;
&lt;code&gt;\winpe_x86\mount&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;将基本映像 (Winpe.wim) 复制到 \Winpe_x86\ISO\sources 文件夹，然后将该文件重命名为 Boot.wim。
&lt;div&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;pre&gt;copy c:\winpe_x86\winpe.wim c:\winpe_x86\ISO\sources\boot.wim&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;h1&gt;步骤 2：（可选）添加其他自定义&lt;/h1&gt;


&lt;div id=&quot;sectionSection2&quot;&gt;

此步骤为可选步骤，但是建议执行此步骤。

在 Windows PE 中工作时，使用 ImageX，可以将应用程序和脚本添加到可能需要的 Windows PE 映像中。ImageX  是一个在实现部署方案期间捕获和应用映像的工具。例如，在命令提示符下键入：

&lt;code&gt;copy &quot;C:\program  files\&amp;lt;version&amp;gt;\Tools\&amp;lt;architecture&amp;gt;\imagex.exe&quot;  C:\winpe_x86\iso\&lt;/code&gt;

其中，&lt;em&gt;&amp;lt;version&amp;gt;&lt;/em&gt; 可以是 Windows OPK 或  Windows AIK，&lt;em&gt;&amp;lt;architecture&amp;gt;&lt;/em&gt; 可以是 x86、amd64 或 a64。在上两例中，Windows PE RAM  引导过程中不会将工具加载到内存。访问这些工具时，介质必须可用。

&lt;/div&gt;


&lt;h1&gt;步骤 3：创建可引导 CD-ROM。&lt;/h1&gt;


&lt;div id=&quot;sectionSection3&quot;&gt;

此步骤讲述如何将 Windows PE RAM 盘放到 CD-ROM 上。此选项要求您使用 Oscdimg 工具创建 .iso  文件。
&lt;ol&gt;
    &lt;li&gt;在技术人员计算机上，使用 Oscdimg 创建 .iso 文件。在命令提示符下，键入：
&lt;div&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;pre&gt;oscdimg -n -bC:\winpe_x86\etfsboot.com C:\winpe_x86\ISO C:\winpe_x86\winpe_x86.iso&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;img alt=&quot;&quot; /&gt;注意：&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;若要在引导期间删除“按任意键从 CD 启动”提示，请在您装载的映像中的 \boot 文件夹下删除 bootfix.bin 文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
对于基于 EFI 的系统或基于 Itanium 的体系结构，请使用 Efisys.bin 替换 Etfsboot.com。在运行  Windows Server 2003 的基于 Itanium 的计算机上不支持 Oscdimg 工具。
若要构建 AMD64 EFI .iso  文件，请使用以下命令：
&lt;div&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; width=&quot;100%&quot;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;pre&gt;oscdimg.exe -bC:\winpe_x64efi\efisys.bin -u2 -udfver102 C:\winpe_x64efi\ISO C:\winpe_x64efi \winpex64efi.iso&lt;/pre&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;&lt;/li&gt;
    &lt;li&gt;将映像 (.iso) 刻录到 CD-ROM 或 DVD-ROM 上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>SVN提交更新的一些准则</title>
   <link href="http://dreambt.github.com/Version Control/2011/02/14/svn-guidelines-to-submit-updated"/>
   <updated>2011-02-14T08:46:44+08:00</updated>
   <id>http://dreambt.github.com/Version Control/2011/02/14/svn-guidelines-to-submit-updated</id>
   <content type="html">&lt;h3&gt;&lt;strong&gt;①提交之前先更新，负责而谨慎地提交自己的代码&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;1.SVN更新的原则是要及时更新，及时提交。当完成了一个小功能，能够通过编译并且并且自己测试之后，尽量早的提交，这样也保存了历史版本，必要时候可以回滚；在开始一天的工作之前，先update一下项目。&lt;/p&gt;

&lt;p&gt;2.如果在修改的期间别人也更改了svn的对应文件，那么commit就可能会失败。如果别人和自己更改的是同一个文件，那么update时会自动进行合并，如果修改的是同一行，那么合并时会产生冲突，这种情况就需要同之前的开发人员联系，两个人一起协商解决冲突，解决冲突之后，需要两人一起测试保证解决冲突之后，程序不会影响其他功能。&lt;/p&gt;

&lt;p&gt;3.在更新时注意所更新文件的列表，如果提交过程中产生了更新，则也是需要重新编译并且完成自己的一些必要测试，再进行提交。这样既能了解别人修改了哪些文件，同时也能避免SVN合并错误导致代码有错。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;②保持原子提交(不要不经意间修改并提交了别人的文件)&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;每次提交的间歇尽可能地短，以几个小时的开发工作为宜。例如在更改UI界面的时候，可以每完成一个UI界面的修改或者设计，就提交一次。在开发功能模块的时候，可以每完成一个小细节功能的测试，就提交一次，在修改bug的时候，每修改掉一个bug并且确认修改了这个bug，也就提交一次。我们提倡多提交，也就能多为代码添加上保险。当完成一个功能或文件后没有提交，后来又做了更改，结果代码出现bug，可能无法恢复到正常时的代码。&lt;/p&gt;

&lt;p&gt;仅提交你修改的部分，最好不要一下子将整个项目提交。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;③不要提交自动生成的文件&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;Visual Studio等开发工具在生成过程中会产生很多自动文件，如.suo等配置文件，Debug,Release,Obj等编译文件，以及其他的一些自动生成，同编译代码无关的文件，这些文件在提交的时候不应该签入，如果不小心签入了，需要从仓库中删除。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;④不要提交不能通过编译的代码&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;代码在提交之前，首先要确认自己能够在本地编译。最好是代码在提交前已经通过自己的测试。如果在代码中使用了第三方类库，要考虑到项目组成员中有些成员可能没有安装相应的第三方类库。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;⑤不要提交自己不明白的代码&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;代码在提交入SVN之后，你的代码将被项目成员所分享。如果提交了你不明白的代码，你看不懂，别人也看不懂，如果在以后出现了问题将会成为项目质量的隐患。因此在引入任何第三方代码之前，确保你对这个代码有一个很清晰的了解。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;⑥提前宣布自己的工作计划(多人协作同一个模块的时候)&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;在自己准备开始进行某项功能的修改之前，先给工作小组的成员谈谈自己的修改计划，让大家都能了解你的思想，了解你即将对软件作出的修改，这样能尽可能的减少在开发过程中可能出现的冲突，提高开发效率。同时你也能够在和成员的交流中发现自己之前设计的不足，完善你的设计。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;⑦对提交的信息采用明晰的标注(类似在代码里写的注释)&lt;/strong&gt;&lt;/h3&gt;


&lt;p&gt;在一个项目组中使用SVN，如果提交空的标注或者不确切的标注将会让项目组中其他的成员感到很无奈，项目经理无法很清晰的掌握工作进度，无法清晰的把握此次提交的概要信息。在发现错误后也无法准确的定位引起错误的文件。所以，在提交工作时，要填写明晰的标注，能够概要的描述所提交文件的信息，让项目组其他成员在看到标注后不用详细看代码就能了解你所做的修改。&lt;/p&gt;

&lt;p&gt;例如可以采用下面的标注格式：&lt;/p&gt;

&lt;p&gt;+) 表示增加了功能
*) 表示对某些功能进行了更改
-) 表示删除了文件，或者对某些功能进行了裁剪，删除，屏蔽。
b) 表示修正了具体的某个bug&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>VirtualBox虚拟硬盘VDI扩展容量(resize/expand capacity)</title>
   <link href="http://dreambt.github.com/Cloud/2011/01/19/virtualbox-vdi-resizeexpand-capacity"/>
   <updated>2011-01-19T09:14:30+08:00</updated>
   <id>http://dreambt.github.com/Cloud/2011/01/19/virtualbox-vdi-resizeexpand-capacity</id>
   <content type="html">&lt;p&gt;虽然VirtualBox支持虚拟硬盘的动态扩展,也就是VDI文件的大小随着guest使用的容量而增大，但是动态扩展的上限就是你最初指定的虚拟硬盘的大小值。&lt;/p&gt;

&lt;p&gt;现在VirtualBox还没有提供改变虚拟硬盘大小上限的功能。&lt;/p&gt;

&lt;p&gt;&lt;img class=&quot;aligncenter size-full wp-image-847&quot; title=&quot;gparted-300x206&quot; src=&quot;http://www.im47.net/wp-content/uploads/2011/01/gparted-300x206.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;206&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最简单的办法也许就是给guest增加一块虚拟硬盘吧，这样最省时省力了。但是我真的不想再搞出一块硬盘来，虚拟机还是越简单越好。&lt;/p&gt;

&lt;p&gt;那怎么办呢？答案就是用一块更大容量的虚拟硬盘来替换原来的虚拟硬盘，把原来的内容完整的clone到新的虚拟硬盘上来。下面就说一说具体的步骤:&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;为你的guest新增一块大容量的虚拟硬盘，并在guest的HDD设置里面把它挂在IDE的primary slave接口上，原来的硬盘一般应该在primary master上面，当然你也可以随便挂，但会影响到后面的硬盘编号。&lt;/li&gt;
    &lt;li&gt;从&lt;a href=&quot;http://gparted.sourceforge.net/&quot;&gt;http://gparted.sourceforge.net/&lt;/a&gt;下载GParted LiveCD,将下载的ISO文件挂载到guest的光驱上面，并且从光驱启动。简单的回车默认启动就可以了。&lt;/li&gt;
    &lt;li&gt;因为新硬盘是空的，必须将旧硬盘的MBR拷贝过来，这样才能正常启动。从虚拟机桌面上点击terminal启动X终端模拟器,可以输入fdisk -l来查看一下你的硬盘设备号，按上面的设置，旧硬盘应该是hda,而新硬盘是hdb。
dd if=/dev/hda of=/dev/hdb bs=512 count=1
切记不要搞反了，否则旧硬盘的MBR就成空白了。dd是dataset definition的缩写,此命令来源于古老的IBM JCL(作业控制语言)，是一个底层I/O facility。MBR里面包含有分区表信息，这样拷贝以后新硬盘里面也有了一个和旧硬盘一般大小的分区，这是我们不需要的，删除掉先。
fdisk /dev/hdb,然后输入fdisk命令d也就是在Command (m for help):后面输入d就可以删除掉这个分区，然后输入fdisk命令w把改变写回硬盘，然后q退出。&lt;/li&gt;
    &lt;li&gt;启动GParted程序。GParted会扫描到这两个硬盘。在旧硬盘hda的分区(我的是主分区hda1)上面右击选择copy,然后选择新硬盘hdb,在其上右击选择paste,并把目的分区拖到最大，在新硬盘的主分区hdb1上右击选择”manage flags”,为此分区添加boot标志，以便从该分区启动。&lt;/li&gt;
    &lt;li&gt;从虚拟机设置里面为guest去掉cd rom，去掉旧的虚拟硬盘，把新虚拟硬盘挂载到IDE的Primary master上面，启动guest。第一次用新硬盘启动可能会遇到磁盘检查。&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;到此应该就OK了,以后新建guest的时候一定要把虚拟硬盘搞大一点，省的这么麻烦。&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>开机显示grub secure的ubuntu启动项修复</title>
   <link href="http://dreambt.github.com/Linux/2011/01/16/grub-secure-ubuntu-restroe"/>
   <updated>2011-01-16T14:15:20+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/01/16/grub-secure-ubuntu-restroe</id>
   <content type="html">&lt;p&gt;昨晚下午给Ubuntu系统增加了160GB的存储空间，但是调整完系统分区之后，Ubuntu无法正常启动了。无光驱，LiveCD没法用，在同学笔记本上刻的U盘启动不起来。只好自己摸索，问题在2个小时之后成功解决。&lt;/p&gt;

&lt;p&gt;症状：&lt;/p&gt;

&lt;p&gt;开机显示grub secure&amp;gt;&lt;/p&gt;

&lt;p&gt;描述：&lt;/p&gt;

&lt;p&gt;grub secure是grub修复命令行，支持简单的命令。&lt;/p&gt;

&lt;p&gt;修复过程：&lt;/p&gt;

&lt;p&gt;[code]
grub secure&amp;gt; ls #查看所有的分区情况，比如我的linux分区是(hd0,msdos7)，下面你可以写(hd0,msdos7)如果你不嫌麻烦，你也可以写(hd0,7)
grub secure&amp;gt; set root=(hd0,7) #Ubuntu挂载根目录
grub secure&amp;gt; set prefix=(hd0,7)/boot/grub #指定grub.cfg所在目录
grub secure&amp;gt; set #查看root和prefix是否设置成功
grub secure&amp;gt; insmod normal
grub secure&amp;gt; normal
系统会自动重新启动，并显示启动菜单，选择Ubuntu系统。
进入系统后，打开Terninal终端。
siqi@siqi-laptop:~$ sudo update-grub2 #更新grub.cfg文件
siqi@siqi-laptop:~$ sudo grub-install /dev/sdb #写入MBR
siqi@siqi-laptop:~$ sudo reboot #重启[/code]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Ubuntu重新挂载 /home （有关mount和fstab）</title>
   <link href="http://dreambt.github.com/Linux/2011/01/15/ubuntu-remount-home-mount-fstab"/>
   <updated>2011-01-15T14:32:51+08:00</updated>
   <id>http://dreambt.github.com/Linux/2011/01/15/ubuntu-remount-home-mount-fstab</id>
   <content type="html">&lt;ol title=&quot;Double click to hide line number.&quot;&gt;
    &lt;li&gt;ls -all /dev/disk/by-uuid&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;对 Linux 毫无概念的用户安装 Ubuntu 时多半仅仅挂载主目录和交换区（/swap）。&lt;/p&gt;

&lt;p&gt;然而，这种挂载方式在长久应用中是不可取的，/home 目录包含了几乎所有的用户文档（类似 Windows 系统中的“我的文档”等），/usr 包含了用户所安装应用程序，这些不适于与系统文件混杂一处。&lt;/p&gt;

&lt;p&gt;欲图重设 /home 等挂载点，可先为其划分新的分区之后修改与挂载点相关的系统设置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;新建分区&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果你有一块空白的磁盘或者已经从 Windows 系统中划分出新的分区，那么可以跳过了。如果你需要在 Ubuntu 系统磁盘中（即原有的 / 所挂载的分区），那么可以由 Ubuntu Live CD 启动并使用 GPart 磁盘管理工具来处理。&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;准备 Ubuntu Live CD 或籍此创建的可启动 U 盘；&lt;/li&gt;
    &lt;li&gt;设定 BIOS 由以上设备启动计算机；&lt;/li&gt;
    &lt;li&gt;成功进入 Ubuntu Live 模式桌面；&lt;/li&gt;
    &lt;li&gt;主菜单－System－Administration-Partition Editor；&lt;/li&gt;
    &lt;li&gt;选定 / 所在的磁盘设备，并选定 / 所在分区；&lt;/li&gt;
    &lt;li&gt;在以上分区图示上执行右键命令 Resize，解脱出 /home 所在分区所需空间；&lt;/li&gt;
    &lt;li&gt;使用获取的为划分空间创建新的分区，分区格式 ext4、ext3、ntfs 均可；&lt;/li&gt;
    &lt;li&gt;执行以上方案；&lt;/li&gt;
    &lt;li&gt;经历漫长的过程之后，完成磁盘编辑；50G 分区耗费 1 小时，300G 分区耗费 4 小时&lt;/li&gt;
    &lt;li&gt;重启计算机，进入硬盘中的 Ubuntu 系统；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;转移用户文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;该过程目的是将现有 /home 目录中的所有文件备份到新建的分区中。&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;挂载新分区于 /media/home&lt;/li&gt;
    &lt;li&gt;拷贝 /home/ 及其所有下级文件至 /media/home/，注意拷贝隐藏文件与目录（多为程序配置）；&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;&lt;strong&gt;编辑挂载设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此过程通过修改 fstab 信息来重设 /home 挂载点位置，这里我们需要知道 Linux 下的磁盘与分区标识规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看磁盘与分区的标识信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[code]ls -all /dev/disk/by-uuid[/code]&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;p&gt;drwxr-xr-x 2 root root 180 2009-04-29 23:13 .
drwxr-xr-x 6 root root 120 2009-04-29 23:13 ..
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 12FEDB1DFEDAF845 -&amp;gt; ../../sdd1
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 ab0d0ae1-da1f-49ce-91cc-42ffa03114d0 -&amp;gt; ../../sda7
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 BC8290BF82907F96 -&amp;gt; ../../sda1
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 C128A5C97B468FC6 -&amp;gt; ../../sda5
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 c80627f3-419d-405d-a987-dafbf1ed86c2 -&amp;gt; ../../sda8
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 D4CCB757CCB7331A -&amp;gt; ../../sdb2
lrwxrwxrwx 1 root root 10 2009-04-29 23:13 D648CC1148CBEE75 -&amp;gt; ../../sdc1
12FEDB1DFEDAF845 等字符串称为 UUID&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编辑 fstab 信息&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[code]sudo gedit /etc/fstab[/code]&lt;/p&gt;

&lt;p&gt;示例如下：&lt;/p&gt;

&lt;h1&gt;/etc/fstab: static file system information.&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;Use 'vol_id --uuid' to print the universally unique identifier for a&lt;/h1&gt;

&lt;h1&gt;device; this may be used with UUID= as a more robust way to name devices&lt;/h1&gt;

&lt;h1&gt;that works even if disks are added and removed. See fstab(5).&lt;/h1&gt;

&lt;p&gt;#
#
proc /proc proc defaults 0 0&lt;/p&gt;

&lt;h1&gt;/ was on /dev/sda7 during installation&lt;/h1&gt;

&lt;p&gt;UUID=ab0d0ae1-da1f-49ce-91cc-42ffa03114d0 / ext4 relatime,errors=remount-ro 0 1
/dev/sda6 none swap sw 0 0
UUID=c80627f3-419d-405d-a987-dafbf1ed86c2 /home ext4 defaults 0 2
UUID=12FEDB1DFEDAF845 /media/Media ntfs-3g defaults 0 0
UUID=C128A5C97B468FC6 /media/Documents ntfs-3g defaults 0 0
UUID=D648CC1148CBEE75 /media/DataI ntfs-3g defaults 0 0
UUID=D4CCB757CCB7331A /media/DataII ntfs-3g defaults 0 0
UUID=BC8290BF82907F96 /media/Vista ntfs-3g defaults 0 0&lt;/p&gt;

&lt;p&gt;我们看到，主要信息分为六列：&lt;/p&gt;

&lt;p&gt;file system - 挂载设备，我们可以用 UUID 来标识
mount point - 挂载点，如我们所需的 /home
type - 分区文件系统，如 ext4、ext3、ntfs-3g、vfat 等
options - 使用该分区的方式
dump - dump 备份工具
pass - 系统扫描检测&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;添加 /home 挂载点设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;例如：UUID=c80627f3-419d-405d-a987-dafbf1ed86c2 /home ext4 defaults 0 2&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 重启计算机。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>64位系统连接M9等Android手机的USB驱动修改方法</title>
   <link href="http://dreambt.github.com/Android/2011/01/08/64bit-m9-android-mobile-usb-driver"/>
   <updated>2011-01-08T15:34:46+08:00</updated>
   <id>http://dreambt.github.com/Android/2011/01/08/64bit-m9-android-mobile-usb-driver</id>
   <content type="html">&lt;p&gt;&lt;img class=&quot;alignleft&quot; title=&quot;Android&quot; src=&quot;http://pic.yupoo.com/dreambt/ALJrHejc/HRnBP.jpg&quot; alt=&quot;&quot; width=&quot;150&quot; height=&quot;328&quot; /&gt;&lt;/p&gt;

&lt;p&gt;64位系统连接M9等Android手机时，会提示无法识别手机。那么下面就来介绍一下如何修改USB驱动：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;em&gt;驱动提取过程&lt;/em&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;__&lt;/p&gt;

&lt;p&gt;1.安装最新的32位JDK（只能装32位，因为Android SDK只认32位）
下载地址：&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index.html&quot; target=&quot;_blank&quot;&gt;http://www.oracle.com/technetwork/java/javase/downloads/index.html&lt;/a&gt;
2.安装Android SDK
下载地址：&lt;a href=&quot;http://developer.android.com/sdk/&quot; target=&quot;_blank&quot;&gt;http://developer.android.com/sdk/&lt;/a&gt;或者&lt;a href=&quot;http://dl.google.com/android/installer_r08-windows.exe&quot; target=&quot;_blank&quot;&gt;http://dl.google.com/android/installer_r08-windows.exe&lt;/a&gt;
3.打开“SDK Manager”，依次展开“Available packages”-&amp;gt;“Third party Add-ons”-&amp;gt;“Google Inc. add-ons(dl-ssl.google.com)”
4.勾上“Google Usb Driver package,revision 4”，然后点右下角“Install Selected”
5.根据屏幕提示完成下载和安装。
6.在安装路径下（64位系统默认C:\Program Files (x86)\Android\android-sdk-windows\google-usb_driver）找到驱动。
7.编辑android_winusb.inf文件，分别在32位和64位部分加入M9的标记：&lt;/p&gt;

&lt;p&gt;[code]
[Google.NTx86]
;M9
%SingleAdbInterface%        = USB_Install, USB\VID_18D1&amp;amp;PID_0005
%CompositeAdbInterface%     = USB_Install, USB\VID_18D1&amp;amp;PID_0005&amp;amp;MI_01
[Google.NTamd64]
;M9
%SingleAdbInterface%        = USB_Install, USB\VID_18D1&amp;amp;PID_0005
%CompositeAdbInterface%     = USB_Install, USB\VID_18D1&amp;amp;PID_0005&amp;amp;MI_01
[/code]&lt;/p&gt;

&lt;p&gt;8、最后将google-usb_driver整目录拷出来即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Jonathan Danylko的20条编程经验</title>
   <link href="http://dreambt.github.com/Other/2010/11/13/jonathan-danylko-20-programming-experience"/>
   <updated>2010-11-13T12:47:06+08:00</updated>
   <id>http://dreambt.github.com/Other/2010/11/13/jonathan-danylko-20-programming-experience</id>
   <content type="html">&lt;p&gt;原文作者乔纳森·丹尼可（Jonathan Danylko）是一位自由职业的web架构师和程序员，编程经验已超过20年，涉足领域有电子商务、生物技术、房地产、医疗、保险和公用事业。正如乔纳 森在文中所言，本文适合刚毕业的大学生和刚入门的程序员。如果你已是高级开发人员，或许你在本文中看到自己的身影。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIprHtLw/medium.jpg&quot; alt=&quot;1102260779095972&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从11岁时，我就一直在编程，并且一直都很喜欢技术和编程。这些年来，我积累了一些艰难又容易的经验。作为一名程序员，你或许还没这些经验，但我会把它们献给那些想从中学到更多的朋友。&lt;/p&gt;

&lt;p&gt;我会持续更新这些经验，我可能还会有更多的感想，但就我这20年来看，我想下面这个列表中基本不需要增添额外的东西了。下面就是我至今最难忘的经验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 估算解决问题所需要的时间。&lt;/strong&gt;不要怕，承认吧！我曾见过一些程序员为了解决一个特殊问题而坐在显示器前面8小时。为自己定一个时间限制吧，1小时、30分钟或甚至15分钟。如果在这期间你不能解决问题，那就去寻求帮助，或到网上找答案，而不是尝试去做“超级堆码员”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 编程语言是一种语言，只是一种语言。&lt;/strong&gt;随着时光推移，只要你理解了一种语言的原理，你会发现各种语言之间的相似之处 。你所选择的语言，你应该觉得“舒服”，并且能够写出有效（而且简洁）的代码。最重要的，让语言去适应项目，反之亦然。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 不要过于注重程序的“设计模式”。&lt;/strong&gt; 有时候，写一个简单的算法，要比引入某种模式更容易。在多数情况下，程序代码应是简单易懂，甚至清洁工也能看懂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 经常备份代码。&lt;/strong&gt;在我年轻时，我就有过因硬盘故障而丢了大量代码的经历，这经历很恐怖的。只要你一次没有备份，就应当像有着严格的期限，客户明天就需要。此时就该源码/版本控制软件大显身手了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 承认自己并不是最顶尖的程序员 - 知不足。&lt;/strong&gt;我常想，我对编程了解已足够多，但是总有其他人比你优秀。正所谓，“一山总比一山高”。所以，向他们看齐吧！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、学习再学习。&lt;/strong&gt;正如第5点所说，我经常会在手里拿一本计算机或编程相关的杂志或书（不信，可以问我的朋友）。诚然，总有很多你不知道的技术，你可以从中学习以保持不落后。如果你有一种灵巧的方式来获取你需要的新技术，那你每天都应该坚持学习。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 永恒的&lt;/strong&gt;&lt;strong&gt;变化&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;你 对待技术/编程知识，就应像你对待股票一样：多样化。不要在某一特定技 术上自我感觉良好。如果那种技术或语言已经没有足够支持，那你还不如现在就开始更新你的简历，并启动培训新计划。我能保持前行的主要原则是什么呢？至少了 解两到三种语言，所以，如果某种语言过时了，你在学习新技术的时候还可以依靠另一种语言。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. 提携新人。&lt;/strong&gt;协助并且培养初级/入门的开发人员学习优秀的编程方法和技巧。也许你还不知道，在帮助他们向更高一层前进时，你自己也在向更高一层提升，你会更加自信。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. 简化算法。&lt;/strong&gt;代码如恶魔，在你完成编码后，应回头并且优化它。从长远来看，这里或那里一些的改进，会让后来的支持人员更加轻松。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 编写文档。&lt;/strong&gt;无 论是Web服务的API，还是一个简单的类，你尽量编写相应文档。我曾经引以为豪的代码注释，因过度 注释而有人指责。给三行代码加一行注释，只需要你几秒时间。如果那是一个比较难以理解的技术，千万别担心过多注释。如果你能很好做好自己的工作，大多数架 构师、后备程序员、支持组都会感激你。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;11. 测试、测试再测试。&lt;/strong&gt;我是一名黑盒测试粉丝。当你完成编码后，你“被认可”的时候就开始了。如果你们公司有QA部门，如果你的代码中有错误，那你得到的评论，会比项目经理还多。如果你不彻底测试自己的代码，那恐怕你开发的就不只是代码，可能还会声名狼藉。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;12. 庆祝每一次成功。&lt;/strong&gt;我见过很多程序员在解决编程技术难题后，会和同伴握手、击掌或甚至手舞足蹈。每个人在生命中都会碰到“顿悟”。如果一个程序员高兴地跑来叫你去看他的非凡代码，也许你已经看过这样的代码100遍了，但你也应该为了这个家伙而庆祝第101次。（编者注：《&lt;a href=&quot;http://www.jobbole.com/entry.php/323&quot;&gt;庆祝成功的九种方式&lt;/a&gt;》。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;13. 经常检查代码。 &lt;/strong&gt;在公司，你的代码要经常检查（包括自查和其他同事检查）。不要把别人的检查，看成是对代码风格的苛求。应该把它们看作是有建设性的批评。对个人来说，经常检查你的代码并且自问，“我怎样才能写得更好呢？” 这会让你加速你的成长，让你成为一个更优秀的程序员。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;14. 回顾你的代码。&lt;/strong&gt;在 看到自己以前的代码时，通常会有两种方式：“难以至信，这代码是我写的”和“难以至信，这代码是 我写的”。第一种往往是厌恶的语气，并在想如何改进它。你也许会惊叹，旧代码也能复活成为一种更好的程序，甚至是一个完整的产品。第二种通常带着惊奇和成 就感。开发人员应该一到两个自己完成的项目成果，能让众人不禁而立并注目而观的项目。同样，基于你优越的编程能力，你可以把过去的程序或项目拿出来，把它 们更新为更加优秀的产品或想法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;15. 幽默是不可缺的。&lt;/strong&gt;在我20年的开发生涯中，我还没有碰到哪位程序员是没有幽默感的。实际上，干我们这行，幽默是一项必备品。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;16. 谨防那些无所不知的程序员，不愿分享的程序员，还有经验不足的程序员。&lt;/strong&gt;当你遇到这几种程序员时，你自己要谦虚。无所不知的程序员，更想当一个英雄而不是团队成员；保守的程序员则是在编写着他们独享的代码；而经验不足的程序员则会每十分钟就来问你一下，当代码完成后，代码已经是你的，而不是他们。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;17. 任何项目都不会那么简单。&lt;/strong&gt;朋 友、家人和同事曾请求我仓促做一些事情，仓促做一个程序或者网站。对于这样的事，应该 从双方做计划，才能做出令两方都会满意的东西。如果某人起初只是需要一个使用Microsoft Access的、只有有3个页面的网站，但来就很可能变成一个有15个页面的网站，并使用SQL Server，有一个论坛，还有一个定制的CMS（内容管理系统）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;18. 任何时候不要想当然。&lt;/strong&gt;假如你承接一个简单的项目，你可能会认为某个部分可以轻松完成。千万别这样想！除非你有一个类、组件、或者一段已经写好的代码，并且在现有的项目已经测试通过。不要认为这将是很容易的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;19. 没有已经完成的软件。&lt;/strong&gt;曾经有一位程序员告诉我，没有软件是已经完成的，它只是“暂时完成了”。这是明智的忠告。如果客户还在使用你写的程序，并经受了时间的考验。如果有机会，你仍在更新它，这并不是什么坏事，这让你不断地前行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;20. 耐心是一种美德。&lt;/strong&gt;当 客户、朋友或家庭成员用电脑的时候，他们也许会受挫，进而想砸电脑，或气冲冲地离开。我一直在 告诉他们，“是你掌控电脑，不是电脑掌控你。”对于用作编程的电脑，你要有一定的耐心。一旦程序员知道问题所在后，他们就会站在电脑的角度看问题，并且说 “哦，这就是为什么它是这样做。”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编者后话&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对本文深有感触！虽然本文没有华丽的辞藻，其中朴实的道理，其实并非只适用程序员，同样可以扩展到其他行业。记得以前练字时，总感觉当时写得很好，但后来回头再看时，也会想“这居然是我写的字！”&lt;/p&gt;

&lt;p&gt;在阅读本文的朋友，不知你是否也有看到了自己的身影呢？欢迎你在微博或评论中和大家一起分享感触。&lt;/p&gt;

&lt;p&gt;本文出处：&lt;a href=&quot;http://www.jobbole.com/&quot;&gt;伯乐&lt;/a&gt;在线 - &lt;a href=&quot;http://www.jobbole.com/blog.php&quot;&gt;职场&lt;/a&gt;博客
本文链接：&lt;a href=&quot;http://www.jobbole.com/entry.php/322&quot;&gt;http://www.jobbole.com/entry.php/322&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>每位开发人员都应铭记的10句编程谚语</title>
   <link href="http://dreambt.github.com/Other/2010/11/06/10-programming-experience"/>
   <updated>2010-11-06T20:35:31+08:00</updated>
   <id>http://dreambt.github.com/Other/2010/11/06/10-programming-experience</id>
   <content type="html">&lt;p&gt;所谓谚语，就是用言简意赅、通俗易懂的方式传达人生箴言和普遍真理的话，它们能很好地帮助你处理生活和工作上的事情。也正因如此，我才整理了10句编程谚语，每位开发人员都应该铭记他们，武装自己。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 无风不起浪&lt;/strong&gt;&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpsZmH8/medium.jpg&quot; alt=&quot;1632410159857198&quot;/&gt;&lt;/p&gt;


&lt;p&gt;代码设计是否糟糕，从某些地方就可以看出来。比如：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;超大类或超大函数&lt;/li&gt;
    &lt;li&gt;大片被注释的代码&lt;/li&gt;
    &lt;li&gt;逻辑重复&lt;/li&gt;
    &lt;li&gt;If/else嵌套过深&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;程序员们通常称它们作代码异味(Code Smell)，但是就我个人认为“代码警报”这个名字更为合适一些，因为它有更高的紧迫感的含义。根本问题处理不当，终将引火烧身。&lt;/p&gt;

&lt;p&gt;译注：Code Smell中文译名一般为“代码异味”，或“代码味道”，它是提示代码中某个地方存在错误的一个暗示，开发人员可以通过这种smell（异味）在代码中追捕到问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 预防为主，治疗为辅&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_756&quot; align=&quot;aligncenter&quot; width=&quot;300&quot; caption=&quot;好吧，我相信了！&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpt040O/medium.jpg&quot; alt=&quot;16324111013064713-300x233&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;20世纪80年代，丰田公司的流水作业线因为它在缺陷预防方法上的革新变得出了名的高效。每个发现自己的部门有问题的成员都有权暂停生产。这个方法意在宁可发现问题后马上暂定生产、解决问题，也不能由其继续生产而导致更棘手且更高代价的修复/更换/召回后的问题。&lt;/p&gt;

&lt;p&gt;程序员总会做出生产率就等同于快速编码的错误臆断。许多程序员都会不假思索地直接着手代码设计。可惜，这种Leeroy Jenkins式鲁莽的做法多会导致软件的开发过程变得很邋遢，拙劣的代码需要不断的监测和修改——也可能会被彻底地替换。最终，生产率所涉及到的因素就不仅仅是写代码所消耗的时间了，还要有调试的时间。稍不留神就会“捡了芝麻丢了西瓜”。（因小失大。）&lt;/p&gt;

&lt;p&gt;译注：Leeroy Jenkins 行为：WOW游戏中一位玩家不顾大家独身一人迎敌，导致灭团。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 不要孤注一掷 （过度依赖某人）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一个软件开发团队的公共要素（bus factor）是指那些会影响整个项目进程的核心开发人员的总数。比如某人被车撞了或某人生孩子或某人跳槽了，项目可能就会无序，甚至会搁置。&lt;/p&gt;

&lt;p&gt;译注： bus factor 即指公共要素，比喻了开发过程中的一些共同因素。如果挤上 bus 的 factor 越多，bus 就越不稳定，所以要控制好 bus factor ，以免问题发生。&lt;/p&gt;

&lt;p&gt;换句话说，如果你的团队突然失去了一个主力成员，你会怎么办？生意依旧进行还是戛然而止？&lt;/p&gt;

&lt;p&gt;很不幸，大多数软件团队都陷入了后一种情况。这些团队把他们的开发员培养成了只会处理他们自己专业领域的“领域专家”。起初，这看起来是一个比较合理 的方法。它 对汽车制造装配生产线很适用，但是为什么对软件开发团队就不行呢？毕竟，想让每个成员都掌握所编程序的细微差别也不太可能，对吧？&lt;/p&gt;

&lt;p&gt;问题是开发人员不容易轻易替换掉。虽然当每位成员都可用时，“抽屉方法”很有效，但如果当“领域专家”突然因人事变动、疾病或突发事故而无法工作时， 抽屉方法立马土崩瓦解。（所以）软件团队有一些看似多余实则重要的后备力量是至关重要。代码复查、结对编程和共有代码可用成功营造一个环境，在这个环境中， 每位开发人员至少表面上是熟悉自己非擅长领域之外的系统部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 种瓜得瓜，种豆得豆&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpt0cxV/medium.jpg&quot; alt=&quot;16324221450276358&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;《注重实效的程序员》一书中有这样一段话解释“破窗理论”：不要留着“破窗户”（低劣的设计、错误的决策或者糟糕的代码）不修。发现一个就修一个。如 果没有足够的时间进行适当的修理，就先把它保留起来。或许你可以把出问题的代码放到注释中，或是显示“未实现”消息，或用虚拟数据加以替代。采取一些措施，防止进一步的恶化。这表明局势尚在掌控之中。&lt;/p&gt;

&lt;p&gt;我们见过整洁良好的系统在出现“破窗”之后立马崩溃。虽然促使软件崩溃的原因还有其他因素（我们将在其他地方接触到），但（对“破窗”）置之不理，肯定会更快地加速系统崩溃。&lt;/p&gt;

&lt;p&gt;简而言之，好的代码会促生好的代码，糟糕的代码也会促生糟糕的代码。别低估了惯性的力量。没人想去整理糟糕的代码，同样没人想把完美的代码弄得一团糟。写好你的代码，它才更可能经得住时间的考验。&lt;/p&gt;

&lt;p&gt;译注：《注重实效的程序员》，作者Andrew Hunt / David Thomas。该书直击编程陈地，穿过了软件开发中日益增长的规范和技术藩篱，对核心过程进行了审视――即根据需求，创建用户乐于接受的、可工作和易维护 的 代码。本书包含的内容从个人责任到职业发展，直至保持代码灵活和易于改编重用的架构技术。从本书中将学到防止软件变质、消除复制知识的陷阱、编写灵活、动 态和易适应的代码、避免出现相同的设计、用契约、断言和异常对代码进行防护等内容。&lt;/p&gt;

&lt;p&gt;译注：破窗理论（Broken Window theory）：是关于环境对人们心理造成暗示性或诱导性影响的一种认识。“破窗效应”理论是指：如果有人打坏了一幢建筑物的窗户玻璃，而这扇窗户又得不到及时的维修，别人就可能受到某些暗示性的纵容去打烂更多的窗户。发现问题就要及时矫正和补救。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 欲速则不达&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经理、客户和程序员正日益变得急躁。一切都需要做的事，都需要马上就做好。正因如此，快速修复问题变得非常急迫。&lt;/p&gt;

&lt;p&gt;没时间对一个新功能进行适当的单元测试？好吧，你可以先完成一次测试运行，然后你就可以随时回来继续测试它。&lt;/p&gt;

&lt;p&gt;当访问Y属性时，会不会碰到奇怪的对象引用错误？无论怎样，把代码放到try/catch语句块中。我们要钓到大鱼啦！&lt;/p&gt;

&lt;p&gt;是不是似曾相识呢？这是因为我们在以前已经都做到了。并且在某些情况下、它是无可非议的。毕竟，我们有最后期限，还得满足客户和经理。但不要过于频繁 操 作，否则你会发现你的代码不稳定，有很多热修复、逻辑重复、未测试的方案和错误处理。最后，你要么是把事情草草做完，要么是把事情好好做完。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. 三思而后行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“敏捷开发”这个词最近被频繁滥用，经常被程序员用来掩饰他们在软件开发过程中的糟糕规划/设计阶段。我们是设计者，看到产品朝正当方向有实质进展， 我们理应高兴。但意外的是，UML图和用例分析似乎并不能满足我们的愿望。所以，在不知自己做什么的情况下或者不知自己身处何处时，我们开发人员经常就稀里糊涂地写代码了。&lt;/p&gt;

&lt;p&gt;这就好比你要去吃饭，但你根本没有想好去哪里吃。因为你太饿了，所以你迫不及待地找个餐馆，定个桌位。然后你上车开车后沿途在想（找地方吃饭）。只是，这样会耗费更多的时间，因为你要过较多的U型弯道，还在餐馆前停车，也许最后因等待时间过长而不吃了。确切地说，你最后应该能找到地方吃饭，但你可能吃的饭并不是你想吃的，并且这样花费的时间，可能比你直接在想去的餐馆订餐所花的时间更长。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7. 如果你惟一的工具是一把锤子，你往往会把一切问题看成钉子&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpsZwn6/medium.jpg&quot; alt=&quot;1632423777530850&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看见了吧？我早就说过动态记录在这个项目中很有效&lt;/p&gt;

&lt;p&gt;程序员有一种倾向，当一谈到他们工具时，其视野就变狭窄了。一旦某种方法在我们的一个项目上“行得通”，我们就会在接下来所有的项目上都用到它。学习新东西仿佛是一种煎熬，有时候甚至会心神不定。从始至终都在想“如果我用之前的方法做、这个就不会这么麻烦了”。一定要摒弃这种想法，按我们所知道的去做，即使那不是最完美的解决方法。&lt;/p&gt;

&lt;p&gt;坚持自己所知很简单，不过从长远的角度讲，选择一个适合这项工作的工具要容易得多。否则，就会与你的职业生涯格格不入。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8. 沉默即赞同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_753&quot; align=&quot;aligncenter&quot; width=&quot;180&quot; caption=&quot;我什么都没看见！没看见！&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpt0m64/medium.jpg&quot; alt=&quot;16324241325858844&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;&quot;破窗理论&quot;与&quot;变成惯性理论&quot;有着宏观的联系。&lt;/p&gt;

&lt;p&gt;编程社区就好像一个现实社区。每个作品都是一个开发者的缩影。糟糕的代码发布的越多，就越容易反映现状。如果你不去努力编写优秀、整洁和稳定的代码，那你每天都将和糟糕的代码相伴了。&lt;/p&gt;

&lt;p&gt;同样地，如果你看到别人写出了糟糕的代码，你就要跟这个人提出来。注意，这时候机智就应该用上场了。一般情况下，程序员都愿意承认他们在软件开发中还是有不懂的地方，并且会感谢你的好意。互相帮助对大家都有利，而对问题视而不见，只会使问题一直存在。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9. 双鸟在林，不如一鸟在手&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果可以讨论系统架构和重构，那么就差找个时间把事情做完。为了使正常运作的东西更加简洁而做改动，权衡改动的利弊很重要。&lt;/p&gt;

&lt;p&gt;当然了，简洁是一个理想目标， 但总会有可以通过重构改进的代码。&lt;/p&gt;

&lt;p&gt;在编程世界中，为了代码不过时，会频繁简单改动代码。&lt;/p&gt;

&lt;p&gt;但有时候你又必须保证代码对客户有价值。&lt;/p&gt;

&lt;p&gt;那么，你面临一个简单窘 境：你不能一石二鸟。&lt;/p&gt;

&lt;p&gt;你在重构旧代码上所发时间越多，你编写新代码的时间就越少。&lt;/p&gt;

&lt;p&gt;在及时改进代码和维护程序之间，也需要找到平衡点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;10. 能力越大，责任越大&lt;/strong&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpsZJCC/medium.jpg&quot; alt=&quot;1632425960417973&quot;/&gt;
毫无疑问，软件已成为我们生活中一个既基本又重要的一部分。&lt;/p&gt;

&lt;p&gt;正因如此，开发优秀软件格外重要。&lt;/p&gt;

&lt;p&gt;乒乓球游戏中的Bug是一回事，航天飞机导向系统或者航 空交通管制系统中的Bug是另外一回事。&lt;/p&gt;

&lt;p&gt;Slashdot曾发表一文，讲述了单单Google News的一个小失误使一家公司股票蒸发11.4亿美元。&lt;/p&gt;

&lt;p&gt;其他例子参见《&lt;a href=&quot;http://www.jobbole.com/entry.php/97&quot; target=&quot;_blank&quot;&gt;软件Bug引发的十次严重后果&lt;/a&gt;》。这些例子便说明了我们正行使着多大的权利。&lt;/p&gt;

&lt;p&gt;你今天写的代码，无论你是否有意，说不定有朝一日在重要的应用程序中派上用场，这想想都令人害怕。&lt;/p&gt;

&lt;p&gt;编写正确合格的代码吧！&lt;/p&gt;

&lt;p&gt;译注：Slashdot是一个资讯科技网站。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>是什么成就了一名“高级”程序员？</title>
   <link href="http://dreambt.github.com/Other/2010/10/29/how-to-achievement-of-a-senior-programmer"/>
   <updated>2010-10-29T11:03:28+08:00</updated>
   <id>http://dreambt.github.com/Other/2010/10/29/how-to-achievement-of-a-senior-programmer</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;除多年编程经验之外，还有什么能区分一个程序员是“老手”还是“新手”？编程技巧当然是一部分，但它绝非是全部。&lt;/strong&gt;聪明的程序员可能比他们的同行拥有更出众的编程技巧，但那不足以说明他们就是“老手”。同样，仅仅因为拥有10年编程经验也并不意味着他们就是高手。在工作岗位上，拥有多年编程经验也不能说明问题。即便没被炒鱿鱼，那也不能提升你的价值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpw0X9S/medium.jpg&quot; alt=&quot;gjcxy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;下面列举的事情是大多数高级程序员都会做的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1．至少掌握一门编程语言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我相信有些优秀的程序员只懂（并精通）一门编程语言，但在某种程度上而言，这其实会限制一个人的思维。就像当你手拿一把锤子时，任何东西看起来都像钉 子。我认为，知道并成功使用至少一门编程语言，这是程序员从新手走向老手的重要一步。我要说的是，像JavaScript和SQL这样的辅助编程语言，只 有当你确实已经开发了完整的应用程序，并在其中使用这些编程语言时，它们才有价值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2．工作之余也经常编程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我抱怨过把开源作为招贤的一项要求，但那仅仅因为许多充满激情的程序员把时间花在别的地方。除了对开源有所贡献，你还可以做兼职顾问，兼职创业，开发自己的产品或者创办自己的微型软件公司。当然，你也可以尝试从外部接些兼职项目，可参考伯乐在线的这篇《&lt;a href=&quot;http://www.jobbole.com/entry.php/239&quot;&gt;成功接项目需要注意的几个要点&lt;/a&gt;》。&lt;/p&gt;

&lt;p&gt;注：mISV即MicroISV,是一个只有一名员工组成的软件公司，是一种微型公司。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3．经历完整的软件开发过程，从概念设计到产品实现，再到产品维护&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有的程序员希望不用自己动手就可以得到详细的设计说明，然后把缺陷代码交给测试/维护小组，这是平庸程序员的一个缩影。任何称职的程序员都会跟客户密切合作，去制定需求分析，然后编码实现，当然也要维护。如果你在编码实现阶段偷懒了，那你在维护阶段不得不付出代价。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4．不断创新&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;创新就是做一些你身边的人没有做过的事情，用来改善你的过程或产品。你不一定非得是世界上第一个做这件事的人，只要发现一个问题，找到解决方法然后实现它就行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5．编写的软件能解决实际问题&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有一副虚构的场景：一名黑客，仅仅是出于对技术以及自己所做事情的爱，一天到晚都在编写代码。但这几乎无助于成就一名优秀的开发者。事实上，我曾见过 有些开发人员和客户争论，来采用更好但不太有助客户的技术。这会适得其反。你可以利用自己的时间来完善。但涉及工作时，你最好还是编写能实际改进并解决问 题的代码，而不是使用那些不同寻常的算法或接口。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;编者后话&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;这些问题对于任何想成为高级开发人员的朋友来说，都合情合理。因为这些问题和拥有多少年编程经验并没有关联。如果你能做到上面4-5条，那你就是高级程序员。如果只有1-2条，那你还需要加油努力。&lt;/p&gt;

&lt;p&gt;当然，在面试中，设置一个简单的“是或不是”问题，通常是一个衡量自己的小练习。更重要的问题会是“你能给我们举例介绍一下吗？”&lt;/p&gt;

&lt;p&gt;你的高级程序员测试得分是多少？你怎么看待这些问题呢？对高级程序员来说，其中是否多余的吗？或者你认为还有其他条件可以判断他人为高级程序员？ 欢迎在评论或微博中分享你的观点。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Matlab曲线拟合工具箱Curve Fitting Toolbox</title>
   <link href="http://dreambt.github.com/Matlab/2010/10/21/matlab-curve-fitting-toolbox"/>
   <updated>2010-10-21T21:59:56+08:00</updated>
   <id>http://dreambt.github.com/Matlab/2010/10/21/matlab-curve-fitting-toolbox</id>
   <content type="html">&lt;h2&gt;&lt;img class=&quot;aligncenter size-full wp-image-687&quot; title=&quot;51092_wl_cft3_fig1_wl&quot; src=&quot;http://www.im47.net/wp-content/uploads/2010/10/51092_wl_cft3_fig1_wl.jpg&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;354&quot; /&gt;&lt;/h2&gt;


&lt;h2&gt;简介&lt;/h2&gt;


&lt;p&gt;Curve Fitting Toolbox™ 提供用于拟合曲线和曲面数据的图形工具和命令行函数。使用该工具箱可以执行探索性数据分析，预处理和后处理数据，比较候选模型，删除偏值。您可以使用随带的线性和非线性模型库进行回归分析，也可以指定您自行定义的方程式。该库提供了优化的解算参数和起始条件，以提高拟合质量。该工具箱还提供非参数建模方法，比如样条、插值和平滑。&lt;/p&gt;

&lt;p&gt;在创建一个拟合之后，您可以运用多种后处理方法进行绘图、插值和外推，估计置信区间，计算积分和导数。&lt;/p&gt;

&lt;h2&gt;主要功能&lt;/h2&gt;


&lt;ul&gt;
    &lt;li&gt;用于曲线和曲面拟合的图形工具&lt;/li&gt;
    &lt;li&gt;使用自定义方程求解线性和非线性回归&lt;/li&gt;
    &lt;li&gt;具有优化起始点和解算参数的回归模型库&lt;/li&gt;
    &lt;li&gt;插值方法，包括 B 样条、薄板样条和张量积样条&lt;/li&gt;
    &lt;li&gt;平滑方法，包括平滑样条、局部回归、Savitzky-Golay 滤波和移动平均数&lt;/li&gt;
    &lt;li&gt;预处理例程，包括偏值移除和分段、缩放和加权数据&lt;/li&gt;
    &lt;li&gt;后处理例程，包括插值、外推、置信区间、积分和导数&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;拟合类型&lt;/h3&gt;


&lt;p&gt;Custom Equations：用户自定义的函数类型
Exponential：指数逼近，有2种类型， a&lt;em&gt;exp(b&lt;/em&gt;x) 、 a&lt;em&gt;exp(b&lt;/em&gt;x) + c&lt;em&gt;exp(d&lt;/em&gt;x)
Fourier：傅立叶逼近，有7种类型，基础型是 a0 + a1&lt;em&gt;cos(x&lt;/em&gt;w) + b1&lt;em&gt;sin(x&lt;/em&gt;w)
Gaussian：高斯逼近，有8种类型，基础型是 a1&lt;em&gt;exp(-((x-b1)/c1)&lt;sup&gt;2)&lt;/sup&gt;
Interpolant：插值逼近，有4种类型，linear、nearest neighbor、cubic spline、shape-preserving
Polynomial：多形式逼近，有9种类型，linear ~、quadratic ~、cubic ~、4-9th degree ~
Power：幂逼近，有2种类型，a&lt;/em&gt;x&lt;sup&gt;b&lt;/sup&gt; 、a&lt;em&gt;x&lt;sup&gt;b&lt;/sup&gt; + c
Rational：有理数逼近，分子、分母共有的类型是linear ~、quadratic ~、cubic ~、4-5th degree ~；此外，分子还包括constant型
Smoothing Spline：平滑逼近（翻译的不大恰当，不好意思）
Sum of Sin Functions：正弦曲线逼近，有8种类型，基础型是 a1&lt;/em&gt;sin(b1&lt;em&gt;x + c1)
Weibull：只有一种，a&lt;/em&gt;b*x&lt;sup&gt;(b-1)&lt;em&gt;exp(-a&lt;/em&gt;x&lt;sup&gt;b)&lt;/sup&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;详细的介绍和使用方法请查阅：&lt;a href=&quot;http://www.mathworks.cn/products/curvefitting/&quot;&gt;http://www.mathworks.cn/products/curvefitting/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Tell Me Why – 告诉我，为什么</title>
   <link href="http://dreambt.github.com/Life/2010/10/20/tell-me-why"/>
   <updated>2010-10-20T13:26:24+08:00</updated>
   <id>http://dreambt.github.com/Life/2010/10/20/tell-me-why</id>
   <content type="html">&lt;p&gt;[dewplayer:music/upload/tell_me_why.mp3]&lt;/p&gt;

&lt;h1&gt;Tell me why《告诉我，为什么？》&lt;/h1&gt;


&lt;h2&gt;歌词&lt;/h2&gt;


&lt;p&gt;In my dream
在我的梦中&lt;/p&gt;

&lt;p&gt;children sing A song of love for everyboy and girl
孩子们总在唱着一首关于男孩和女孩的恋歌&lt;/p&gt;

&lt;p&gt;The sky is blue and fields are green
那里有蔚蓝的天空，翠绿的田野&lt;/p&gt;

&lt;p&gt;And laughter is the language of the world
笑声是这个世界上共同的语言&lt;/p&gt;

&lt;p&gt;Then I wake and all I see
然而当我醒来&lt;/p&gt;

&lt;p&gt;Is a world full of people in need
看到的却是一个满布穷苦的世界&lt;/p&gt;

&lt;p&gt;Tell me why(why)does it have to be like this?
告诉我这一切为什么会成为这样&lt;/p&gt;

&lt;p&gt;Tell me why(why)is there some thing I have missed?
告诉我，我已经失去了什么&lt;/p&gt;

&lt;p&gt;Tell me why(why)cos I don't understand
告诉我，这一切我为什么不理解&lt;/p&gt;

&lt;p&gt;When so many need somebody
We don't give a helping hand Tell me why?
为什么我们面对这么多贫穷的人却不能伸出援手&lt;/p&gt;

&lt;p&gt;Everyday I ask myself
每天我在责问自己&lt;/p&gt;

&lt;p&gt;What will I have to do to be a man?
我要做怎样一个人&lt;/p&gt;

&lt;p&gt;Do I have to stand and fight
To prove to everybody who I am?
难道必须要做靠孤立和争斗来证实自己存在的人&lt;/p&gt;

&lt;p&gt;Is that what my life is for
To was tein a world full of war?
难道我生来就为了在充满战争的世界里浪费生命&lt;/p&gt;

&lt;p&gt;(children)tell me why?
告诉我为什么&lt;/p&gt;

&lt;p&gt;(declan)tell me why?
告诉我为什么&lt;/p&gt;

&lt;p&gt;(children)tell me why?
告诉我为什么&lt;/p&gt;

&lt;p&gt;(declan)tell me why?
告诉我为什么&lt;/p&gt;

&lt;p&gt;(together)just tell me why,why,why?
请告诉我为什么，为什么，为什么&lt;/p&gt;

&lt;p&gt;Tell me why(why,why,does the tiger run)
告诉我为什么，为什么老虎消失了,&lt;/p&gt;

&lt;p&gt;Tell me why(why why do we shoot the gun)
告诉我为什么，为什么我们举起枪支，&lt;/p&gt;

&lt;p&gt;Tell me why(why,why do we never learn)
告诉我为什么，为什么我们从不汲取教训，&lt;/p&gt;

&lt;p&gt;Can some one tell us why we let the forest burn?
有谁能够告诉我们，为什么我们燃烧森林，&lt;/p&gt;

&lt;p&gt;(why,why do we say we care)
为什么，为什么还说我们关心这一切，&lt;/p&gt;

&lt;p&gt;Tell me why(why,why do we stand and stare)
告诉我为什么，为什么我们目瞪口呆的容忍这一切，&lt;/p&gt;

&lt;p&gt;Tell me why(why,why do the do lphins cry)
告诉我为什么，为什么海豚在哭泣，&lt;/p&gt;

&lt;p&gt;Can some one tell us why we let the ocean die?
有谁能够告诉我们，为什么我们让海洋干涸，&lt;/p&gt;

&lt;p&gt;(why,why if we're all the same)
为什么，为什么，如果我们是一样的人，&lt;/p&gt;

&lt;p&gt;Tell me why(why,why do we pass the blame)
告诉我为什么，为什么我们逃过了应有的谴责，&lt;/p&gt;

&lt;p&gt;Tell me why(why,why does it never end)
告诉我为什么，为什么这一切的痛苦还没结束，&lt;/p&gt;

&lt;p&gt;Can some one tell us why we can not just be friends?
有谁能够告诉我们，为什么我们不能成为亲密无间的朋友？&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;


&lt;p&gt;&lt;img class=&quot;alignright size-full wp-image-666&quot; title=&quot;td051124005&quot; src=&quot;wp-content/uploads/2010/10/td051124005.jpg&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;432&quot; /&gt;
这首歌叫Tell Me Why 是来自英国的Declan Galbraith唱的！当时，他才10岁啊！他太厉害了！他唱的这首歌，给人非常震撼的感觉，很少的值得回味的歌曲。&lt;/p&gt;

&lt;p&gt;Declan Galbraith 4岁开始展露歌唱天赋；8岁那年，他开始参加一些音乐比赛，并在14个月中曾经获得16个大奖。他获得了词作家Barry Mason（写过Last Waltz-最后的华尔兹的作者）的欣赏，从此一发不可收。我们听到的这首Walking In The Air是2001年录制的，那时候他才9岁。据传好几家唱片公司争相与他签约，最后Emi（百代）以超过百万英镑之巨，签了他3年，并承诺发行3张唱片。&lt;/p&gt;

&lt;p&gt;大家都相信这个小男孩的音乐天赋和对爱尔兰传统音乐的理解及热爱，来自他的祖父Ben。才6个星期左右，就是Ben照顾他了。Ben常常在酒吧演奏六孔笛和爱尔兰鼓，并常常带上他。Declan从小就耳濡目染；祖父96年去世，可是Declan忘不了他，他的第一张专辑（Declan）就是献给他祖父的。&lt;/p&gt;

&lt;p&gt;Declan的声音，清亮脱俗，演唱歌曲的范畴也是极广。从流行的Angels之类到Carrickfergus这样传统的爱尔兰歌曲，他都把握得不错。而这个小小童星的心愿却是有一天能够不再翻唱别人的歌曲，能有几首属于“Declan Galbraith”的歌。&lt;/p&gt;

&lt;p&gt;除了天使般的声音，Declan小小年纪，已经表现星探们热衷的所谓“明星气质”--一头松软的深色头发，浓密的睫毛，明亮清澈的蓝眼睛，充满童真颇富感染力的笑容，还有满满的自信。更重要的是，他从不怯场，每次上台都异常兴奋；应该说，也有过一次紧张，那是在圣保罗大教堂女王特赦的演出上。为Robbie Williams和Phil Collins制作MTV的John Carver十分有信心的说，“Declan注定要成为一个超级巨星的，不仅是因为他超群的声音，更重要的是他极好的个性，他非常聪明。”&lt;/p&gt;

&lt;p&gt;除了他的音乐天赋，以及身后的百万合同，Declan和12岁的其它小男孩没有什么分别。喜欢足球，电脑游戏和游泳，房间里贴满海报，足球，Robbie Williams,Westlife,还有哈里波特。他也曾为签名不够快而苦恼，直到听从父亲的建议，用“Dec”签名才算解决；他也会在采访中忍不住想要从凳子上逃走，当然会事先礼貌的问“我可以很快去踢球吗？”他喜欢的歌手包括Carole King，The Fureys，Christy Moore， Led Zeppelin，Robbie Williams 和Westlife。&lt;/p&gt;

&lt;p&gt;Declan一边上学一边参与专辑的推广。他有专门的家教，确保他不会因为缺课而影响学业；他有专门的造型设计师，帮他打点Armani的定购，带他去Toni and Guy\'s做头发，也有专门的声乐导师和经纪人，还有他的歌友会。这对于一个床头还摆着恐龙惦记着遥控车的小男孩，似乎的确有些兴师动众了。&lt;/p&gt;

&lt;p&gt;英国媒体对于过早享有声名的儿童，通常不是太客气的。当2002年Declan发行第一张专辑的时候，就有媒体预言在他16岁之前，不会吸毒就会酗酒，而父母多半等不到那时候就已经离婚了。Declan的父母，颇有信心的表示他们不会做急进的父母，他们只需要支持Declan做他喜欢做的事情。当然，他们也表示了自己的担心，这么小的一个孩子，就已经获得了经济上的保障，而不必像普通人那样为分期付款担心，的确不是太好的事。&lt;/p&gt;

&lt;p&gt;事实上，Declan已经是这个4口之家（父母和7岁的妹妹）唯一的经济来源。妈妈自小孩出生后就离职了，做电工的爸爸也已经辞工全程陪同Declan。对于很多成人歌星也羡慕的百万合同，Declan说，“其实我拿不到这么多，100万是公司承诺投入在我身上的全部资金。不过我不在意，我只是喜欢唱歌而已。”在一段自白中，Declan也说道，他最希望的是能够照顾好家人，父母再也不用去工作；如果他有了钱，会给爸爸买一辆新车；如果还有剩余，就给自己买些足球球星卡；如果还有多，就存进银行。很可爱很单纯的小孩。
家人：爸爸Alec (48) ，妈妈Siobhan (44) 妹妹 Bernardette (7)
最好的朋友：Joe（cousin)
最喜欢的足球明星：Alan Shearer
最喜欢的流行歌手：Robbie Williams
最喜欢的游戏：PS2
最喜欢的玩具：遥控车
最喜欢的运动：足球（英式）
最喜欢的歌曲：Danny Boy
最喜欢的学科：数学，科学
不大欣赏的歌手：Britney Spears
不大擅长的技能：绘画&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我们能不能不输给距离</title>
   <link href="http://dreambt.github.com/Life/2010/10/18/we-can-not-help-but-lose-to-the-distance"/>
   <updated>2010-10-18T12:50:43+08:00</updated>
   <id>http://dreambt.github.com/Life/2010/10/18/we-can-not-help-but-lose-to-the-distance</id>
   <content type="html">&lt;p&gt;1、表达障碍&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_639&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;短信听不到语气，电话看不到表情。 我说我没生气..你相信了..       我哭了..你看不见..&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMO869/medium.jpg&quot; alt=&quot;12&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;2、共同语言&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_640&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;如果两个人在一起，两个人的交往圈会融为共同的圈子，话题永远都在更新。而不在一起的两个人，对彼此身边的环境都会因陌生而逐渐失去兴趣，慢慢的，能说的话只有空洞的‘我想你’。         亲爱的、我在努力找话题呢，不要回信说‘哦、嗯、好’了好吗?&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMOYrI/medium.jpg&quot; alt=&quot;22&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;3、不安全感&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_641&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;看了10次手机了，你还是没有回信。你在哪、和谁、在干什么? 　　刚刚拒绝了别人的好意，却禁不住想，你身边的莺莺燕燕，一如我身边的花花草草吗?&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMPsEz/medium.jpg&quot; alt=&quot;32&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;4、远水不救近火&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_642&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;我这里下雨了，来送伞的是同学的弟弟;我吃饭忘带钱了，来解围的是朋友的朋友。 　　                原来你不吭声是因为你生病了，可我再担忧，也不能在你身边端一杯水呢。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMPBxC/medium.jpg&quot; alt=&quot;42&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;5、距离产生幻觉&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_643&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;其实我有些小虚荣，照片有时候修掉了痘痘才给你看;其实你有些小自负，认定了的事情就以为自己一定对。为了大老远的爱你，我拒绝接受身边一切说你不好的言论，什么都往好的方向想。你也是吧。其实我们都不是对方想象的那样好。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMPJbx/medium.jpg&quot; alt=&quot;51&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;6、距离产生误会&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_644&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;我兴冲冲地发短信给你讲刚刚的趣事，你隔了半天说‘噢’。 我不知道你在忙嘛，所以我生闷气了。 　　你给我发了八条短信两个电话我也没回，愤怒得嗷嗷直叫。   我在做头发呢，包包寄存了的嘛，哪知道手机响着响着没电了。 　　其实我们都知道对方不是故意的，但情绪来了，总需要宣泄的。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMPZaV/medium.jpg&quot; alt=&quot;61&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;7、善意的谎言&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_645&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;我碰巧和相熟的男生去看电影了，想了想，对你说和女生去的。 　　你独自去了我们约好要一起去的地方，犹豫再三，对我说你哪都没去。 不愿让对方多想，却因为偶尔的疏忽，让对方想得更多。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMQoYl/medium.jpg&quot; alt=&quot;71&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;8、寂寞&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_646&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;一个人不寂寞，想念一个人才寂寞。 　　你说，来，抱抱。于是我把自己裹在被窝里，闭上眼，恩，抱抱。 　　下班的路上，亲爱的、你会在身边留个我的位置么?&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMQHEt/medium.jpg&quot; alt=&quot;81&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;9、信念坍塌&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_647&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;我看到身边一对一对的，男生帮女生拿包包，在树荫下卿卿我我，周末还能一起爬山。 于是没忍住就对在地图对角线上的你发牢骚，其实是想听你的鼓励。 　　刚刚好你接到朋友异地恋分手倾诉的电话，那么容易就把自己带入了戏，无心的抱怨雪上加霜。 　　有时候折腾一下，只为了证明自己的重要性。哪知脆弱基础上的高楼只须多压上一根头发的重量，也许就崩溃了。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMQWcO/medium.jpg&quot; alt=&quot;91&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;10、你的真心&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_648&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;人心隔肚皮，更何况我们还隔着千山万水。 　　当我完全了解以上所有困难，依然下定决心明知不可为而为之的时候， 　　却不知上一刻还信誓旦旦的你，又是什么时候突然铁了心非要放弃呢? 　　也许只是终于亲身经历，你才觉悟了，异地真的不是几个电话和信息可以解决的的问题。&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMRbYi/medium.jpg&quot; alt=&quot;101&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_649&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;I know that you’re there，  So please don’t walk away，So should it matter?What I do or what I’ve done. As long as in my heart. You’re still the only one.Just to make it last. But I guess it’s been too long.&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMRlqn/medium.jpg&quot; alt=&quot;111&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_650&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;Easy to move on.  If you got to know me again. Maybe then -- maybe then, We could see what we should do.  But that’s all up to you……&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMRKBm/medium.jpg&quot; alt=&quot;121&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[caption id=&quot;attachment_651&quot; align=&quot;aligncenter&quot; width=&quot;520&quot; caption=&quot;很多我们以为一辈子都不会忘记的事情，就在我们念念不忘的日子里，被我们遗忘了。 那些曾经以为念念不忘的事情就在我们念念不忘的过程里，被我们遗忘了&quot;]&lt;img src=&quot;http://pic.yupoo.com/dreambt/AIpMOPza/medium.jpg&quot; alt=&quot;13&quot;/&gt;[/caption]&lt;/p&gt;

&lt;p&gt;[dewplayer:/music/upload/hskj.mp3]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何打包JAVA程序以及生成可执行文件</title>
   <link href="http://dreambt.github.com/Java/2010/10/09/how-to-package-a-java-program-as-executable-file"/>
   <updated>2010-10-09T21:19:35+08:00</updated>
   <id>http://dreambt.github.com/Java/2010/10/09/how-to-package-a-java-program-as-executable-file</id>
   <content type="html">&lt;p&gt;首先，选择好你即将发布的.class二进制文件，使用如下命令：&lt;/p&gt;

&lt;p&gt;[java]javac *.java[/java]&lt;/p&gt;

&lt;p&gt;然后，创建jar文件(这里讲解的是打jar包)。这里我用一个名字叫做test.class的文件来举例，另外注意还要编写一个确定main_class（主类）的文件manifest.mf（编写方法见后面）。在这里mainfest.mf和test.class是在同一个目录下，然后使用如下命令：&lt;/p&gt;

&lt;p&gt;[java]jar cvfm test.jar manifest.mf test[/java]&lt;/p&gt;

&lt;p&gt;这样，一个test.jar文件就生成了。但为了确保成功，我们可以再用下面的指令执行一下刚刚生成的test.jar：&lt;/p&gt;

&lt;p&gt;[java]java -jar test.jar[/java]&lt;/p&gt;

&lt;blockquote&gt;打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录，这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息，下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容：
Manifest-Version: 1.0
Created-By: Apache Ant 1.5.1
Extension-Name: Struts Framework
Specification-Title: Struts Framework
Specification-Vendor: Apache Software Foundation
Specification-Version: 1.1
Implementation-Title: Struts Framework
Implementation-Vendor: Apache Software Foundation
Implementation-Vendor-Id: org.apache
Implementation-Version: 1.1
Class-Path:  commons-beanutils.jar commons-collections.jar commons-digester.jar commons-logging.jar commons-validator.jar jakarta-oro.jar struts-legacy.jar

如果我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类：

一. 一般属性

1. Manifest-Version
用来定义manifest文件的版本，例如：Manifest-Version: 1.0

2. Created-By
声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1

3. Signature-Version
定义jar文件的签名版本

4. Class-Path
应用程序或者类装载器使用该值来构建内部的类搜索路径

二. 应用程序相关属性

1. Main-Class
定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。

三. 小程序(Applet)相关属性

1. Extendsion-List
该属性指定了小程序需要的扩展信息列表，列表中的每个名字对应以下的属性
2. &amp;lt;extension&amp;gt;-Extension-Name
3. &amp;lt;extension&amp;gt;-Specification-Version
4. &amp;lt;extension&amp;gt;-Implementation-Version
5. &amp;lt;extension&amp;gt;-Implementation-Vendor-Id
5. &amp;lt;extension&amp;gt;-Implementation-URL

四. 扩展标识属性

1. Extension-Name
该属性定义了jar文件的标识，例如Extension-Name: Struts Framework

五. 包扩展属性

1. Implementation-Title   定义了扩展实现的标题
2. Implementation-Version   定义扩展实现的版本
3. Implementation-Vendor   定义扩展实现的组织
4. Implementation-Vendor-Id   定义扩展实现的组织的标识
5. Implementation-URL :   定义该扩展包的下载地址(URL)
6. Specification-Title   定义扩展规范的标题
7. Specification-Version   定义扩展规范的版本
8. Specification-Vendor   声明了维护该规范的组织
9. Sealed   定义jar文件是否封存，值可以是true或者false (这点我还不是很理解)

六. 签名相关属性

签名方面的属性我们可以来参照JavaMail所提供的mail.jar中的一段

Name: javax/mail/Address.class
Digest-Algorithms: SHA MD5
SHA-Digest: AjR7RqnN//cdYGouxbd06mSVfI4=
MD5-Digest: ZnTIQ2aQAtSNIOWXI1pQpw==

这段内容定义类签名的类名、计算摘要的算法名以及对应的摘要内容(使用BASE64方法进行编码)

七.自定义属性

除了前面提到的一些属性外，你也可以在MANIFEST.MF中增加自己的属性以及响应的值，例如J2ME程序jar包中就可能包含着如下信息

MicroEdition-Configuration: CLDC-1.0
MIDlet-Name: J2ME_MOBBER Midlet Suite
MIDlet-Info-URL: &lt;a href=&quot;http://www.javayou.com/&quot;&gt;http://www.javayou.com/&lt;/a&gt;
MIDlet-Icon: /icon.png
MIDlet-Vendor: Midlet Suite Vendor
MIDlet-1: mobber,/icon.png,mobber
MIDlet-Version: 1.0.0
MicroEdition-Profile: MIDP-1.0
MIDlet-Description: Communicator

关键在于我们怎么来读取这些信息呢？其实很简单，JDK给我们提供了用于处理这些信息的API，详细的信息请见java.util.jar包中，我们可以通过给JarFile传递一个jar文件的路径，然后调用JarFile的getManifest方法来获取Manifest信息。
更详细关于JAR文件的规范请见
&lt;a href=&quot;http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html&quot;&gt;http://java.sun.com/j2se/1.3/docs/guide/jar/jar.html&lt;/a&gt;&lt;/blockquote&gt;


&lt;p&gt;怎么样，是不是可以很顺利的进行？如果是，那我们就可以开始进行可执行文件的创建了。&lt;/p&gt;

&lt;p&gt;下面打开exe4j，它的开始一个界面是这样的：&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-563&quot; title=&quot;2010-10-09_210226&quot; src=&quot;wp-content/uploads/2010/10/2010-10-09_210226.jpg&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;440&quot; /&gt;&lt;/p&gt;


&lt;p&gt;单击NEXT键，选择”JAR in EXE”mod按钮，单击NEXT；填写短名和文件输出的路径然后点击NEXT继续。&lt;/p&gt;

&lt;p&gt;在下面的画面中，你可以选择你要生成的可执行文件的类型，以及生成的可执行文件名称、可执行文件的图标等，我们在这里就选择GUI application，名字就根据自己的需要取一个，图标你可以自己在你的图标库里选一个你喜欢的，然后再NEXT再继续；&lt;/p&gt;

&lt;p&gt;下一个画面里填写Main class的名字，单击下面的绿色+选择所需的.jar文件,如果没有特殊要求我们就可以再继续了；&lt;/p&gt;

&lt;p&gt;接下来是选择版本的画面，填写好自己的最大最小版本然后再继续&lt;/p&gt;

&lt;p&gt;下面这个画面可以帮助你设一下你的文件执行的片头，增加其美观效果，选择自己喜欢的图片，写自己想写的文字，并可以根据需要调整文字的位置，再继续&lt;/p&gt;

&lt;p&gt;下面是一个选择语言版本的界面选好后再继续&lt;/p&gt;

&lt;p&gt;下面是一个短暂的等待，&lt;/p&gt;

&lt;p&gt;然后就大功告成了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Cannot modify header information - headers already sent by错误解决办法</title>
   <link href="http://dreambt.github.com/PHP/2010/10/07/cannot-modify-header-information-headers-already-sent-by"/>
   <updated>2010-10-07T18:10:58+08:00</updated>
   <id>http://dreambt.github.com/PHP/2010/10/07/cannot-modify-header-information-headers-already-sent-by</id>
   <content type="html">&lt;p&gt;最近在学习PHP，在页面跳转时遇到了一些小问题。出错信息如下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Cannot modify header information - headers already sent by (output started at E:...\htdocs...*.php:1) in &lt;strong&gt;E:...\htdocs...*d.php&lt;/strong&gt; on line &lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;解决方法一：&lt;/strong&gt;
在PHP里Cookie的使用是有一些限制的。&lt;/p&gt;

&lt;p&gt;1、使用setcookie必须在&amp;lt;html&amp;gt;标签之前
2、使用setcookie之前，不可以使用echo输入内容
3、直到网页被加载完后，cookie才会出现
4、setcookie必须放到任何资料输出浏览器前，才送出
.....
由于上面的限制，在使用setcookie()函数时，学会遇到 &quot;Undefined index&quot;、&quot;Cannot modify header information - headers already sent by&quot;…等问题，解决办法是在输出内容之前，产生cookie，可以在程序的最上方加入函数 ob_start();&lt;/p&gt;

&lt;p&gt;ob_start ：打开输出缓冲区
函数格式：void ob_start(void)说明：当缓冲区激活时，所有来自PHP程序的非文件头信息均不会发送，而是保存在内部缓冲区。为了输出缓冲区的内容，可以使用ob_end_flush()或flush()输出缓冲区的内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法二：
&lt;/strong&gt;打开 php.ini 然后把 output_buffering 设为 on 。重起appache，OK。看来这才是解决办法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特别注意：&lt;/strong&gt;&lt;strong&gt;
&lt;/strong&gt;如果使用utf-8编码，一定要去掉UTF-8中的BOM，这都是因为utf-8编码文件含有的bom原因，而php4,5都是不支持bom的。去掉bom，可以用Notepad++打开转换一下。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>C语言绘图-拉格朗日插值</title>
   <link href="http://dreambt.github.com/C/2010/10/05/c-language-drawin-lagrange-interpolation"/>
   <updated>2010-10-05T20:18:14+08:00</updated>
   <id>http://dreambt.github.com/C/2010/10/05/c-language-drawin-lagrange-interpolation</id>
   <content type="html">&lt;p&gt;最近帮一“好朋友”做导师布置的作业，要求用拉格朗日求点并绘图。&lt;/p&gt;

&lt;p&gt;我选用的是C语言，一则重温一下C语言，二则因为大学系主任在开学时说过的那句话，“当你能用C语言绘图的时候，你就学得很好了”。当然，我并没有学好 :oops: 。&lt;/p&gt;

&lt;p&gt;在这里我利用了&lt;a href=&quot;http://www.rupeng.com/forum/viewthread.php?tid=12260&quot; target=&quot;_blank&quot;&gt;ege图形库&lt;/a&gt;，绘图很方便。当然用MFC也很方便，MFC的我没做，我朋友做了。我一向不喜欢封装的东西，我喜欢了解底层。废话少说，看题：&lt;/p&gt;

&lt;p&gt;问题的关键还是利用拉格朗日求点，公式自己去谷歌回来。其他的都好做了，唯一需要注意的就是绘图坐标系的坐标原点在左上角，而y轴是向下的。好了，有了这些基本上就可以实现了。如果要做的好一点可以考虑绘制坐标轴和刻度，同时对数据进行修改使得图像不致于显示不开或者太小了看不见。数据是从data.txt中读取的，数据存放格式为：第一行为已知点个数n，第二行开始到第n+1行为已知点坐标以空格或Tab隔开，第n+2行为未知点横坐标。&lt;/p&gt;

&lt;p&gt;1.y=sin(x) 101个点 待求点3.14&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;wp-content/uploads/2010/10/2010-10-05_194858.jpg&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-534&quot; title=&quot;2010-10-05_194858&quot; src=&quot;wp-content/uploads/2010/10/2010-10-05_194858.jpg&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;480&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.y=cos(x)&lt;span style=&quot;line-height: 10px;&quot;&gt;1 101个点 待求点1.1212&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;wp-content/uploads/2010/10/2010-10-05_194837.jpg&quot;&gt;&lt;img class=&quot;alignnone size-full wp-image-533&quot; title=&quot;2010-10-05_194837&quot; src=&quot;wp-content/uploads/2010/10/2010-10-05_194837.jpg&quot; alt=&quot;&quot; width=&quot;642&quot; height=&quot;482&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[c]#include&amp;lt;stdio.h&amp;gt;&lt;/p&gt;

&lt;h1&gt;include&amp;lt;stdlib.h&amp;gt;&lt;/h1&gt;

&lt;h1&gt;include&amp;lt;float.h&amp;gt;&lt;/h1&gt;

&lt;h1&gt;include &amp;quot;graphics.h&amp;quot;&lt;/h1&gt;

&lt;p&gt;float laglange(float &lt;em&gt;x,float &lt;/em&gt;y,float a,int n){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i,j;
float h,b=0.0;
for(i=0;i&amp;amp;lt;=n-1;i++){
    h=1.0;
    for(j=0;j&amp;amp;lt;=n-1;j++){
        if(i!=j) h=h*(a-x[j])/(x[i]-x[j]);
    }
    b=b+y[i]*h;
}
return b;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;// x、y同时缩放，图像可能显示不全
void draw(float &lt;em&gt;x,float &lt;/em&gt;y,int n,float t,float yt,float maxX,float minX,float maxY,float minY){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i;
float tx,ty,zoom,floatX;
float width=640,height=480;

zoom=min(width/(maxX-minX),height/(maxY-minY));
floatX=-minX*zoom;

// 初始化
init();

// 坐标轴
setcolor(GREEN);
line(0,height/2,640,height/2);
line(floatX,0,floatX,480);

// 绘图
setcolor(WHITE);
for(i=0;i&amp;amp;lt;n;i++){
    line(x[i]*zoom+floatX,height/2-y[i]*zoom,x[i+1]*zoom+floatX,height/2-y[i+1]*zoom);
}

// 待求点(t,yt)
tx=t*zoom+floatX;
ty=height/2-yt*zoom;
outtextxy(tx+5,ty-15, &amp;amp;quot;待求点&amp;amp;quot;);
setcolor(RED);
putpixel(tx,ty,RED);
circle(tx,ty,1);
circle(tx,ty,2);
circle(tx,ty,3);

getch();
closegraph();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;// x、y单独缩放,部分图像可能变形
void draw2(float &lt;em&gt;x,float &lt;/em&gt;y,int n,float t,float yt,float maxX,float minX,float maxY,float minY){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int i;
float tx,ty,zoomX,zoomY,floatX;
float width=640,height=480;

zoomX=width/(maxX-minX);
zoomY=height/(maxY-minY)/2.0;
floatX=-minX*zoomX;

// 初始化
int g = DETECT, m = 0;
initgraph(&amp;amp;amp;g, &amp;amp;amp;m, &amp;amp;quot;拉格朗日计算&amp;amp;quot;);

// 坐标轴
setcolor(GREEN);
line(0,height/2,640,height/2);
line(floatX,0,floatX,480);

// 绘图
setcolor(WHITE);
for(i=0;i&amp;amp;lt;n;i++){
    line(x[i]*zoomX+floatX,height/2-y[i]*zoomY,x[i+1]*zoomX+floatX,height/2-y[i+1]*zoomY);
}

// 待求点(t,yt)
tx=t*zoomX+floatX;
ty=height/2-yt*zoomY;
outtextxy(tx+5,ty-15, &amp;amp;quot;待求点&amp;amp;quot;);
setcolor(RED);
putpixel(tx,ty,RED);
circle(tx,ty,1);
circle(tx,ty,2);
circle(tx,ty,3);

getch();
closegraph();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;void main(){&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;float x[300],y[300],t,yt;
int i,n;
float maxX=FLT_MIN,minX=FLT_MAX,maxY=FLT_MIN,minY=FLT_MAX;
FILE *fp;

if((fp=fopen(&amp;amp;quot;data.txt&amp;amp;quot;,&amp;amp;quot;r&amp;amp;quot;))==NULL){
    printf(&amp;amp;quot;File cannot be opened!\n&amp;amp;quot;);
    exit(1);
}
else{
    // 读取点集合的大小、数据和待求数据
    fscanf(fp,&amp;amp;quot;%d&amp;amp;quot;,&amp;amp;amp;n);
    for(i=0;i&amp;amp;lt;n;i++){
        fscanf(fp,&amp;amp;quot;%f %f&amp;amp;quot;,&amp;amp;amp;x[i],&amp;amp;amp;y[i]);
        maxX=max(maxX,x[i]);
        minX=min(minX,x[i]);
        maxY=max(maxY,y[i]);
        minY=min(minY,y[i]);
    }
    fscanf(fp,&amp;amp;quot;%f&amp;amp;quot;,&amp;amp;amp;t);

    // 输出
    for(i=0;i&amp;amp;lt;n;i++){
        printf(&amp;amp;quot;%f %f&amp;amp;quot;,x[i],y[i]);
    }

    // 计算拉格朗日
    yt=laglange(x,y,t,n-1);
    printf(&amp;amp;quot;Result: %f&amp;amp;quot;,yt);

    // 绘图
    draw2(x,y,n-1,t,yt,maxX,minX,maxY,minY);
}

if(fclose(fp)!=0){
    printf(&amp;amp;quot;File cannot be closed!\n&amp;amp;quot;);
    exit(1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}[/c]&lt;/p&gt;

&lt;p&gt;下面是她用MFC做的，这个实现的是利用已知点通过拉格朗日插值求出其他点然后连接各点，与我做的题目有些区别：&lt;/p&gt;

&lt;p style=&quot;text-align: center;&quot;&gt;&lt;a href=&quot;wp-content/uploads/2010/10/lg1.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-578&quot; title=&quot;lg1&quot; src=&quot;wp-content/uploads/2010/10/lg1.jpg&quot; alt=&quot;&quot; width=&quot;640&quot; height=&quot;422&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;wp-content/uploads/2010/10/lg2.jpg&quot;&gt;&lt;img class=&quot;aligncenter size-full wp-image-579&quot; title=&quot;lg2&quot; src=&quot;wp-content/uploads/2010/10/lg2.jpg&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;444&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java和C#的语法对照表(Java (J2SE 5.0) and C# Comparison)</title>
   <link href="http://dreambt.github.com/Java/2010/07/27/java-j2se-and-c-comparison"/>
   <updated>2010-07-27T12:46:52+08:00</updated>
   <id>http://dreambt.github.com/Java/2010/07/27/java-j2se-and-c-comparison</id>
   <content type="html">&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Program Structure&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;package hello;public class HelloWorld {
public static void &lt;strong&gt;main&lt;/strong&gt;(String[] args) {
String name = &quot;Java&quot;;

// See if an argument was passed from the command line
if (args.length == 1)
name = args[0];

System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;);
}
}&lt;/td&gt;
&lt;td&gt;using System;namespace Hello {
public class HelloWorld {
public static void &lt;strong&gt;Main&lt;/strong&gt;(string[] args) {
string name = &quot;C#&quot;;

// See if an argument was passed from the command line
if (args.Length == 1)
name = args[0];

Console.WriteLine(&quot;Hello, &quot; + name + &quot;!&quot;);
}
}
}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table2&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Comments&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;// Single line
/* Multiple
line  */
/** Javadoc documentation comments */&lt;/td&gt;
&lt;td&gt;// Single line
/* Multiple
line  */
/// XML comments on a single line
/** XML comments on multiple lines */&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table3&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Data Types&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td&gt;Primitive Types
boolean
byte
char
short, int, long
float, double
Reference Types
Object   (superclass of all other classes)
String
&lt;em&gt;arrays, classes, interfaces&lt;/em&gt;Conversions

// int to String
int x = 123;
String y = Integer.toString(x);  // y is &quot;123&quot;

// String to int
y = &quot;456&quot;;
x = Integer.parseInt(y);   // x is 456

// double to int
double z = 3.5;
x = &lt;strong&gt;(int)&lt;/strong&gt; z;   // x is 3  (truncates decimal)&lt;/td&gt;
&lt;td&gt;Value Types
bool
byte, sbyte
char
short, ushort, int, uint, long, ulong
float, double, decimal
&lt;em&gt;structures, enumerations&lt;/em&gt;Reference Types
object    (superclass of all other classes)
string
&lt;em&gt;arrays, classes, interfaces, delegates&lt;/em&gt;

Convertions

// int to string
int x = 123;
String y = x.ToString();  // y is &quot;123&quot;

// string to int
y = &quot;456&quot;;
x = int.Parse(y);   // or x = Convert.ToInt32(y);

// double to int
double z = 3.5;
x = &lt;strong&gt;(int)&lt;/strong&gt; z;   // x is 3  (truncates decimal)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table4&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Constants&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td&gt;// May be initialized in a constructor
&lt;strong&gt;final&lt;/strong&gt; double PI = 3.14;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;const&lt;/strong&gt; double PI = 3.14;// Can be set to a const or a variable. May be initialized in a constructor.
&lt;strong&gt;readonly&lt;/strong&gt; int MAX_HEIGHT = 9;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table20&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Enumerations&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td&gt;&lt;strong&gt;enum&lt;/strong&gt;Action {Start, Stop, Rewind, Forward};// Special type of class
&lt;strong&gt;enum&lt;/strong&gt; Status {
Flunk(50), Pass(70), Excel(90);
private final int value;
Status(int value) { this.value = value; }
public int value() { return value; }
};

Action a = Action.Stop;
if (a != Action.Start)
System.out.println(a);               // Prints &quot;Stop&quot;

Status s = Status.Pass;
System.out.println(s.value());      // Prints &quot;70&quot;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;enum&lt;/strong&gt;Action {Start, Stop, Rewind, Forward};&lt;strong&gt;enum&lt;/strong&gt; Status {Flunk = 50, Pass = 70, Excel = 90};

No equivalent.

Action a = Action.Stop;
if (a != Action.Start)
Console.WriteLine(a);             // Prints &quot;Stop&quot;

Status s = Status.Pass;
Console.WriteLine((int) s);       // Prints &quot;70&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table5&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Operators&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;16&quot;&gt;Comparison
==  &amp;lt;  &amp;gt;  &amp;lt;=  &amp;gt;=  !=Arithmetic
+  -  *  /
%  (mod)
/   (integer division if both operands are ints)
Math.Pow(x, y)

Assignment
=  +=  -=  *=  /=   %=   &amp;amp;=  |=  ^=  &amp;lt;&amp;lt;=  &amp;gt;&amp;gt;=  &amp;gt;&amp;gt;&amp;gt;=  ++  --

Bitwise
&amp;amp;  |  ^   ~  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;  &amp;gt;&amp;gt;&amp;gt;

Logical
&amp;amp;&amp;amp;  ||  &amp;amp;  |   ^   !

&lt;strong&gt;Note:&lt;/strong&gt; &amp;amp;&amp;amp; and || perform short-circuit logical evaluations

String Concatenation
+&lt;/td&gt;
&lt;td height=&quot;16&quot;&gt;Comparison
==  &amp;lt;  &amp;gt;  &amp;lt;=  &amp;gt;=  !=Arithmetic
+  -  *  /
%  (mod)
/   (integer division if both operands are ints)
Math.Pow(x, y)

Assignment
=  +=  -=  *=  /=   %=  &amp;amp;=  |=  ^=  &amp;lt;&amp;lt;=  &amp;gt;&amp;gt;=  ++  --

Bitwise
&amp;amp;  |  ^   ~  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;

Logical
&amp;amp;&amp;amp;  ||  &amp;amp;  |   ^   !

&lt;strong&gt;Note:&lt;/strong&gt; &amp;amp;&amp;amp; and || perform short-circuit logical evaluations

String Concatenation
+&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table6&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Choices&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;163&quot;&gt;greeting = age &amp;lt; 20 &lt;strong&gt;?&lt;/strong&gt; &quot;What's up?&quot; &lt;strong&gt;:&lt;/strong&gt;&quot;Hello&quot;;&lt;strong&gt;if &lt;/strong&gt;(x &amp;lt; y)
System.out.println(&quot;greater&quot;);

&lt;strong&gt;if &lt;/strong&gt;(x != 100) {
x *= 5;
y *= 2;
}
&lt;strong&gt;else&lt;/strong&gt;
z *= 6;

int selection = 2;
&lt;strong&gt;switch&lt;/strong&gt; (selection) {     &lt;em&gt;// Must be byte, short, int, char, or enum&lt;/em&gt;
&lt;strong&gt;case&lt;/strong&gt; 1: x++;            &lt;em&gt;// Falls through to next case if no break&lt;/em&gt;
&lt;strong&gt;case&lt;/strong&gt; 2: y++;   &lt;strong&gt;break;&lt;/strong&gt;
&lt;strong&gt;case&lt;/strong&gt; 3: z++;   &lt;strong&gt;break;&lt;/strong&gt;
&lt;strong&gt;default:&lt;/strong&gt; other++;
}&lt;/td&gt;
&lt;td height=&quot;163&quot;&gt;greeting = age &amp;lt; 20 &lt;strong&gt;?&lt;/strong&gt; &quot;What's up?&quot; &lt;strong&gt;:&lt;/strong&gt;&quot;Hello&quot;;&lt;strong&gt;if &lt;/strong&gt;(x &amp;lt; y)
Console.WriteLine(&quot;greater&quot;);

&lt;strong&gt;if &lt;/strong&gt;(x != 100) {
x *= 5;
y *= 2;
}
&lt;strong&gt;else&lt;/strong&gt;
z *= 6;

string color = &quot;red&quot;;
&lt;strong&gt;switch&lt;/strong&gt; (color) {                          &lt;em&gt;// Can be any predefined type&lt;/em&gt;
&lt;strong&gt;case&lt;/strong&gt; &quot;red&quot;:    r++;    &lt;strong&gt;break;&lt;/strong&gt; &lt;em&gt;// break is mandatory; no fall-through&lt;/em&gt;
&lt;strong&gt;case&lt;/strong&gt; &quot;blue&quot;:   b++;   &lt;strong&gt;break;&lt;/strong&gt;
&lt;strong&gt;case&lt;/strong&gt; &quot;green&quot;: g++;   &lt;strong&gt;break;&lt;/strong&gt;
&lt;strong&gt;default:&lt;/strong&gt; other++;     &lt;strong&gt;break;&lt;/strong&gt; &lt;em&gt;// break necessary on default&lt;/em&gt;
}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table7&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Loops&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;259&quot;&gt;&lt;strong&gt;while&lt;/strong&gt; (i &amp;lt; 10)
i++;&lt;strong&gt;for&lt;/strong&gt; (i = 2; i &amp;lt;= 10; i += 2)
System.out.println(i);

&lt;strong&gt;do&lt;/strong&gt;
i++;
&lt;strong&gt;while&lt;/strong&gt; (i &amp;lt; 10);

&lt;strong&gt;for&lt;/strong&gt; (int i &lt;strong&gt;:&lt;/strong&gt; numArray)  // foreach construct
sum += i;

// for loop can be used to iterate through any Collection
import java.util.ArrayList;
ArrayList&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();
list.add(10);    // boxing converts to instance of Integer
list.add(&quot;Bisons&quot;);
list.add(2.3);    // boxing converts to instance of Double

&lt;strong&gt;for&lt;/strong&gt; (Object o &lt;strong&gt;:&lt;/strong&gt; list)
System.out.println(o);&lt;/td&gt;
&lt;td valign=&quot;top&quot; height=&quot;259&quot;&gt;&lt;strong&gt;while&lt;/strong&gt; (i &amp;lt; 10)
i++;&lt;strong&gt;for&lt;/strong&gt; (i = 2; i &amp;lt;= 10; i += 2)
Console.WriteLine(i);

&lt;strong&gt;do&lt;/strong&gt;
i++;
&lt;strong&gt;while&lt;/strong&gt; (i &amp;lt; 10);

&lt;strong&gt;foreach&lt;/strong&gt; (int i &lt;strong&gt;in&lt;/strong&gt; numArray)
sum += i;

&lt;em&gt;// foreach can be used to iterate through any collection&lt;/em&gt;
using System.Collections;
ArrayList list = new ArrayList();
list.Add(10);
list.Add(&quot;Bisons&quot;);
list.Add(2.3);

&lt;strong&gt;foreach&lt;/strong&gt; (Object o &lt;strong&gt;in&lt;/strong&gt; list)
Console.WriteLine(o);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table8&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Arrays&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;144&quot;&gt;int nums&lt;strong&gt;[]&lt;/strong&gt; = {1, 2, 3};   &lt;em&gt;or&lt;/em&gt; int&lt;strong&gt;[]&lt;/strong&gt; nums = {1, 2, 3};
for (int i = 0; i &amp;lt; nums.length; i++)
System.out.println(nums[i]);String names[] = new String[5];
names[0] = &quot;David&quot;;

float twoD&lt;strong&gt;[][]&lt;/strong&gt; = new float[rows][cols];
twoD[2][0] = 4.5;int&lt;strong&gt;[][]&lt;/strong&gt; jagged = new int[5][];
jagged[0] = new int[5];
jagged[1] = new int[2];
jagged[2] = new int[3];
jagged[0][4] = 5;&lt;/td&gt;
&lt;td height=&quot;144&quot;&gt;int&lt;strong&gt;[]&lt;/strong&gt; nums = {1, 2, 3};
for (int i = 0; i &amp;lt; nums.Length; i++)
Console.WriteLine(nums[i]);string[] names = new string[5];
names[0] = &quot;David&quot;;

float&lt;strong&gt;[,]&lt;/strong&gt; twoD = new float[rows, cols];
twoD[2,0] = 4.5f;int&lt;strong&gt;[][]&lt;/strong&gt; jagged = new int[3][] {
new int[5], new int[2], new int[3] };
jagged[0][4] = 5;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table9&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Functions&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot;&gt;
&lt;table width=&quot;100%&quot; border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot;&gt;// Return single value
&lt;strong&gt;int&lt;/strong&gt; Add(int x, int y) {
&lt;strong&gt;return&lt;/strong&gt; x + y;
}int sum = Add(2, 3);&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;// Return no value
&lt;strong&gt;void&lt;/strong&gt; PrintSum(int x, int y) {
System.out.println(x + y);
}PrintSum(2, 3);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
// Primitive types and references are always passed by value
void TestFunc(int x, Point p) {
x++;
p.x++;       // Modifying property of the object
p = null;    // Remove local reference to object
}

class Point {
public int x, y;
}

Point p = new Point();
p.x = 2;
int a = 1;
TestFunc(a, p);
System.out.println(a + &quot; &quot; + p.x + &quot; &quot; + (p == null) );  // 1 3 false

// Accept variable number of arguments
int Sum(int &lt;strong&gt;...&lt;/strong&gt; nums) {
int sum = 0;
for (int i : nums)
sum += i;
return sum;
}

int total = Sum(4, 3, 2, 1);   // returns 10&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;
&lt;table id=&quot;Table1&quot; width=&quot;100%&quot; border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot;&gt;// Return single value
&lt;strong&gt;int&lt;/strong&gt; Add(int x, int y) {
&lt;strong&gt;return&lt;/strong&gt; x + y;
}int sum = Add(2, 3);&lt;/td&gt;
&lt;td width=&quot;50%&quot;&gt;// Return no value
&lt;strong&gt;void&lt;/strong&gt; PrintSum(int x, int y) {
Console.WriteLine(x + y);
}PrintSum(2, 3);&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
// Pass by value (default), in/out-reference (ref), and out-reference (out)
void TestFunc(int x, &lt;strong&gt;ref&lt;/strong&gt; int y, &lt;strong&gt;out&lt;/strong&gt; int z, Point p1, &lt;strong&gt;ref&lt;/strong&gt; Point p2) {
x++;  y++;  z = 5;
p1.x++;       // Modifying property of the object
p1 = null;    // Remove local reference to object
p2 = null;   // Free the object
}

class Point {
public int x, y;
}

Point p1 = new Point();
Point p2 = new Point();
p1.x = 2;
int a = 1, b = 1, c;   // Output param doesn't need initializing
TestFunc(a, &lt;strong&gt;ref&lt;/strong&gt; b, &lt;strong&gt;out&lt;/strong&gt; c, p1, &lt;strong&gt;ref&lt;/strong&gt; p2);
Console.WriteLine(&quot;{0} {1} {2} {3} {4}&quot;,
a, b, c, p1.x, p2 == null);   // 1 2 5 3 True

// Accept variable number of arguments
int Sum(&lt;strong&gt;params&lt;/strong&gt; int[] nums) {
int sum = 0;
foreach (int i in nums)
sum += i;
return sum;
}

int total = Sum(4, 3, 2, 1);   &lt;em&gt;// returns 10&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table10&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Strings&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td&gt;// String concatenation
&lt;strong&gt;String&lt;/strong&gt; school = &quot;Harding &quot;;
school = school + &quot;University&quot;;   // school is &quot;Harding University&quot;// String comparison
String mascot = &quot;Bisons&quot;;
if (mascot == &quot;Bisons&quot;)    // Not the correct way to do string comparisons
if (mascot.&lt;strong&gt;equals&lt;/strong&gt;(&quot;Bisons&quot;))   // true
if (mascot.&lt;strong&gt;equalsIgnoreCase&lt;/strong&gt;(&quot;BISONS&quot;))   // true
if (mascot.&lt;strong&gt;compareTo&lt;/strong&gt;(&quot;Bisons&quot;) == 0)   // true

System.out.println(mascot.&lt;strong&gt;substring&lt;/strong&gt;(2, 5));   // Prints &quot;son&quot;

// My birthday: Oct 12, 1973
java.util.Calendar c = new java.util.GregorianCalendar(1973, 10, 12);
String s = String.format(&quot;My birthday: %1$tb %1$te, %1$tY&quot;, c);

// Mutable string
&lt;strong&gt;StringBuffer&lt;/strong&gt; buffer = new &lt;strong&gt;StringBuffer&lt;/strong&gt;(&quot;two &quot;);
buffer.&lt;strong&gt;append&lt;/strong&gt;(&quot;three &quot;);
buffer.&lt;strong&gt;insert&lt;/strong&gt;(0, &quot;one &quot;);
buffer.&lt;strong&gt;replace&lt;/strong&gt;(4, 7, &quot;TWO&quot;);
System.out.println(buffer);     // Prints &quot;one TWO three&quot;&lt;/td&gt;
&lt;td&gt;// String concatenation
&lt;strong&gt;string&lt;/strong&gt; school = &quot;Harding &quot;;
school = school + &quot;University&quot;;   // school is &quot;Harding University&quot;// String comparison
string mascot = &quot;Bisons&quot;;
if (mascot == &quot;Bisons&quot;)    // true
if (mascot.&lt;strong&gt;Equals&lt;/strong&gt;(&quot;Bisons&quot;))   // true
if (mascot.&lt;strong&gt;ToUpper&lt;/strong&gt;().&lt;strong&gt;Equals&lt;/strong&gt;(&quot;BISONS&quot;))   // true
if (mascot.&lt;strong&gt;CompareTo&lt;/strong&gt;(&quot;Bisons&quot;) == 0)    // true

Console.WriteLine(mascot.&lt;strong&gt;Substring&lt;/strong&gt;(2, 3));    // Prints &quot;son&quot;

// My birthday: Oct 12, 1973
DateTime dt = new DateTime(1973, 10, 12);
string s = &quot;My birthday: &quot; + dt.ToString(&quot;MMM dd, yyyy&quot;);

// Mutable string
System.Text.&lt;strong&gt;StringBuilder&lt;/strong&gt; buffer = new System.Text.&lt;strong&gt;StringBuilder&lt;/strong&gt;(&quot;two &quot;);
buffer.&lt;strong&gt;Append&lt;/strong&gt;(&quot;three &quot;);
buffer.&lt;strong&gt;Insert&lt;/strong&gt;(0, &quot;one &quot;);
buffer.&lt;strong&gt;Replace&lt;/strong&gt;(&quot;two&quot;, &quot;TWO&quot;);
Console.WriteLine(buffer);     // Prints &quot;one TWO three&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table11&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Exception Handling&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;96&quot;&gt;// Must be in a method that is declared to throw this exception
Exception ex = new Exception(&quot;Something is really wrong.&quot;);
&lt;strong&gt;throw&lt;/strong&gt;ex;&lt;strong&gt;try&lt;/strong&gt; {
y = 0;
x = 10 / y;
} &lt;strong&gt;catch&lt;/strong&gt; (Exception ex) {
System.out.println(ex.getMessage());
} &lt;strong&gt;finally&lt;/strong&gt; {
// Code that always gets executed
}&lt;/td&gt;
&lt;td&gt;Exception up = new Exception(&quot;Something is really wrong.&quot;);
&lt;strong&gt;throw&lt;/strong&gt;up;  // ha ha&lt;strong&gt;
try&lt;/strong&gt; {
y = 0;
x = 10 / y;
} &lt;strong&gt;catch&lt;/strong&gt; (Exception ex) {      // Variable &quot;ex&quot; is optional
Console.WriteLine(ex.Message);
} &lt;strong&gt;finally&lt;/strong&gt; {
// Code that always gets executed
}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table12&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Namespaces&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;163&quot;&gt;&lt;strong&gt;package&lt;/strong&gt;harding.compsci.graphics;&amp;nbsp;

&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;import&lt;/strong&gt; harding.compsci.graphics.Rectangle;  // Import single class

&lt;strong&gt;import&lt;/strong&gt; harding.compsci.graphics.*;   // Import all classes&lt;/td&gt;
&lt;td height=&quot;163&quot;&gt;&lt;strong&gt;namespace&lt;/strong&gt; Harding.Compsci.Graphics {
...
}or

&lt;strong&gt;namespace&lt;/strong&gt; Harding {
&lt;strong&gt;namespace&lt;/strong&gt; Compsci {
&lt;strong&gt;namespace&lt;/strong&gt; Graphics {
...
}
}
}

// Import all class. Can't import single class.
&lt;strong&gt;using&lt;/strong&gt; Harding.Compsci.Graphics;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table13&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Classes / Interfaces&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td&gt;Accessibility keywords
public
private
protected
static// Inheritance
&lt;strong&gt;class&lt;/strong&gt; FootballGame &lt;strong&gt;extends&lt;/strong&gt; Competition {
...
}

// Interface definition
&lt;strong&gt;interface&lt;/strong&gt; IAlarmClock {
...
}

// Extending an interface
&lt;strong&gt;interface&lt;/strong&gt; IAlarmClock &lt;strong&gt;extends&lt;/strong&gt; IClock {
...
}

// Interface implementation
&lt;strong&gt;class&lt;/strong&gt; WristWatch &lt;strong&gt;implements&lt;/strong&gt; IAlarmClock, ITimer {
...
}&lt;/td&gt;
&lt;td&gt;Accessibility keywords
public
private
internal
protected
protected internal
static// Inheritance
&lt;strong&gt;class&lt;/strong&gt; FootballGame &lt;strong&gt;:&lt;/strong&gt; Competition {
...
}

// Interface definition
&lt;strong&gt;interface&lt;/strong&gt; IAlarmClock {
...
}

// Extending an interface
&lt;strong&gt;interface&lt;/strong&gt; IAlarmClock : IClock {
...
}

// Interface implementation
&lt;strong&gt;class&lt;/strong&gt; WristWatch &lt;strong&gt;:&lt;/strong&gt; IAlarmClock, ITimer {
...
}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table14&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Constructors / Destructors&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;176&quot;&gt;class SuperHero {
private int mPowerLevel;public SuperHero() {
mPowerLevel = 0;
}

public SuperHero(int powerLevel) {
this.mPowerLevel= powerLevel;
}

// No destructors, just override the finalize method
protected void &lt;strong&gt;finalize&lt;/strong&gt;() throws Throwable {
super.finalize();   // Always call parent's finalizer
}
}&lt;/td&gt;
&lt;td height=&quot;176&quot;&gt;class SuperHero {
private int mPowerLevel;public SuperHero() {
mPowerLevel = 0;
}

public SuperHero(int powerLevel) {
this.mPowerLevel= powerLevel;
}

&lt;strong&gt;~&lt;/strong&gt;SuperHero() {
// Destructor code to free unmanaged resources.
// Implicitly creates a Finalize method.
}
}&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table15&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Objects&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;163&quot;&gt;SuperHero hero = new SuperHero();hero.setName(&quot;SpamMan&quot;);
hero.setPowerLevel(3);

hero.Defend(&quot;Laura Jones&quot;);
SuperHero.Rest();  // Calling static method

SuperHero hero2 = hero;   // Both refer to same object
hero2.setName(&quot;WormWoman&quot;);
System.out.println(hero.getName());  // Prints WormWoman

hero = &lt;strong&gt;null&lt;/strong&gt;;   // Free the object

if (hero == &lt;strong&gt;null&lt;/strong&gt;)
hero = new SuperHero();

Object obj = new SuperHero();
System.out.println(&quot;object's type: &quot; + obj.&lt;strong&gt;getClass()&lt;/strong&gt;.toString());
if (obj &lt;strong&gt;instanceof&lt;/strong&gt; SuperHero)
System.out.println(&quot;Is a SuperHero object.&quot;);&lt;/td&gt;
&lt;td height=&quot;163&quot;&gt;SuperHero hero = new SuperHero();hero.Name = &quot;SpamMan&quot;;
hero.PowerLevel = 3;

hero.Defend(&quot;Laura Jones&quot;);
SuperHero.Rest();   // Calling static method

SuperHero hero2 = hero;   // Both refer to same object
hero2.Name = &quot;WormWoman&quot;;
Console.WriteLine(hero.Name);   // Prints WormWoman

hero = &lt;strong&gt;null&lt;/strong&gt; ;   // Free the object

if (hero == &lt;strong&gt;null&lt;/strong&gt;)
hero = new SuperHero();

Object obj = new SuperHero();
Console.WriteLine(&quot;object's type: &quot; + obj.&lt;strong&gt;GetType()&lt;/strong&gt;.ToString());
if (obj &lt;strong&gt;is&lt;/strong&gt; SuperHero)
Console.WriteLine(&quot;Is a SuperHero object.&quot;);&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table16&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Properties&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot; height=&quot;134&quot;&gt;private int mSize;public int &lt;strong&gt;getSize&lt;/strong&gt;() { return mSize; }
public void &lt;strong&gt;setSize&lt;/strong&gt;(int value) {
if (value &amp;lt; 0)
mSize = 0;
else
mSize = value;
}
int s = shoe.getSize();
shoe.setSize(s+1);&lt;/td&gt;
&lt;td width=&quot;50%&quot; height=&quot;134&quot;&gt;private int mSize;public int Size {
&lt;strong&gt;get&lt;/strong&gt; { return mSize; }
&lt;strong&gt;set&lt;/strong&gt; {
if (value &amp;lt; 0)
mSize = 0;
else
mSize = value;
}
}

shoe.Size++;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table17&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Structs&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td height=&quot;256&quot;&gt;&amp;nbsp;

&lt;em&gt;No structs in Java.&lt;/em&gt;&lt;/td&gt;
&lt;td height=&quot;256&quot;&gt;&lt;strong&gt;struct&lt;/strong&gt; StudentRecord {
public string name;
public float gpa;public StudentRecord(string name, float gpa) {
this.name = name;
this.gpa = gpa;
}
}

StudentRecord stu = new StudentRecord(&quot;Bob&quot;, 3.5f);
StudentRecord stu2 = stu;

stu2.name = &quot;Sue&quot;;
Console.WriteLine(stu.name);    // Prints &quot;Bob&quot;
Console.WriteLine(stu2.name);   // Prints &quot;Sue&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table18&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;Console I/O&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot; height=&quot;163&quot;&gt;java.io.DataInput in = new java.io.DataInputStream(System.in);
System.out.print(&quot;What is your name? &quot;);
String name = in.readLine();
System.out.print(&quot;How old are you? &quot;);
int age = Integer.parseInt(in.readLine());
System.out.println(name + &quot; is &quot; + age + &quot; years old.&quot;);
int c = System.in.read();   // Read single char
System.out.println(c);      // Prints 65 if user enters &quot;A&quot;// The studio costs $499.00 for 3 months.
System.out.printf(&quot;The %s costs $%.2f for %d months.%n&quot;, &quot;studio&quot;, 499.0, 3);

// Today is 06/25/04
System.out.printf(&quot;Today is %tD\n&quot;, new java.util.Date());&lt;/td&gt;
&lt;td width=&quot;50%&quot; height=&quot;163&quot;&gt;Console.Write(&quot;What's your name? &quot;);
string name = Console.ReadLine();
Console.Write(&quot;How old are you? &quot;);
int age = Convert.ToInt32(Console.ReadLine());
Console.WriteLine(&quot;{0} is {1} years old.&quot;, name, age);
// or
Console.WriteLine(name + &quot; is &quot; + age + &quot; years old.&quot;);int c = Console.Read();  // Read single char
Console.WriteLine(c);    // Prints 65 if user enters &quot;A&quot;// The studio costs $499.00 for 3 months.
Console.WriteLine(&quot;The {0} costs {1:C} for {2} months.\n&quot;, &quot;studio&quot;, 499.0, 3);

// Today is 06/25/2004
Console.WriteLine(&quot;Today is &quot; + DateTime.Now.ToShortDateString());&lt;/td&gt;
&lt;/tr&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;table id=&quot;Table19&quot; width=&quot;100%&quot; border=&quot;0&quot;&gt;
&lt;tbody&gt;
&lt;tr align=&quot;middle&quot;&gt;
&lt;td width=&quot;20%&quot;&gt;Java&lt;/td&gt;
&lt;td width=&quot;60%&quot;&gt;File I/O&lt;/td&gt;
&lt;td width=&quot;20%&quot;&gt;C#&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr valign=&quot;top&quot;&gt;
&lt;td width=&quot;50%&quot; height=&quot;163&quot;&gt;import java.io.*;// Character stream writing
&lt;strong&gt;FileWriter&lt;/strong&gt; writer = new FileWriter(&quot;c:\\myfile.txt&quot;);
writer.write(&quot;Out to file.\n&quot;);
writer.close();

// Character stream reading
&lt;strong&gt;FileReader&lt;/strong&gt; reader = new FileReader(&quot;c:\\myfile.txt&quot;);
&lt;strong&gt;BufferedReader&lt;/strong&gt; br = new BufferedReader(reader);
String line = br.readLine();
while (line != null) {
System.out.println(line);
line = br.readLine();
}
reader.close();

// Binary stream writing
&lt;strong&gt;FileOutputStream&lt;/strong&gt; out = new FileOutputStream(&quot;c:\\myfile.dat&quot;);
out.write(&quot;Text data&quot;.getBytes());
out.write(123);
out.close();

// Binary stream reading
&lt;strong&gt;FileInputStream&lt;/strong&gt; in = new FileInputStream(&quot;c:\\myfile.dat&quot;);
byte buff[] = new byte[9];
in.read(buff, 0, 9);   // Read first 9 bytes into buff
String s = new String(buff);
int num = in.read();   // Next is 123
in.close();&lt;/td&gt;
&lt;td width=&quot;50%&quot; height=&quot;163&quot;&gt;using System.IO;// Character stream writing
&lt;strong&gt;StreamWriter&lt;/strong&gt; writer = File.CreateText(&quot;c:\\myfile.txt&quot;);
writer.WriteLine(&quot;Out to file.&quot;);
writer.Close();

// Character stream reading
&lt;strong&gt;StreamReader&lt;/strong&gt; reader = File.OpenText(&quot;c:\\myfile.txt&quot;);
string line = reader.ReadLine();
while (line != null) {
Console.WriteLine(line);
line = reader.ReadLine();
}
reader.Close();
// Binary stream writing
&lt;strong&gt;BinaryWriter&lt;/strong&gt; out = new BinaryWriter(File.OpenWrite(&quot;c:\\myfile.dat&quot;));
out.Write(&quot;Text data&quot;);
out.Write(123);
out.Close();

// Binary stream reading
&lt;strong&gt;BinaryReader&lt;/strong&gt; in = new BinaryReader(File.OpenRead(&quot;c:\\myfile.dat&quot;));
string s = in.ReadString();
int num = in.ReadInt32();
in.Close();&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

</content>
 </entry>
 
 <entry>
   <title>5大开源许可协议详解</title>
   <link href="http://dreambt.github.com/Linux/2010/04/02/5-open-source-license-agreement"/>
   <updated>2010-04-02T12:24:39+08:00</updated>
   <id>http://dreambt.github.com/Linux/2010/04/02/5-open-source-license-agreement</id>
   <content type="html">&lt;p&gt;笔者是个不折不扣的开源爱好者，不过大部分时候都是拿来主义。基本都是在使用，而使用过程中总会遇到各种各样的许可协议，例如GNU LGPL ,GNU GPL等等。很多开源软件发布过程中使用的许可协议都不相同，而且很多开源软件在您修改源码的同时需要将你现有的代码也以相同的许可方法发布，不知道您是否留意过这些呢？今天笔者带来一篇“&lt;strong&gt;5大开源许可协议详解&lt;/strong&gt;”希望对大家使用开源产品时有一些帮助&lt;/p&gt;

&lt;p style=&quot;line-height: 19px;&quot;&gt;越来越多的开发者与设计者希望将自己的产品开源，以便其他人可以在他们的代码基础上做更多事，开源社区也因此充满生机。在我们所能想到的应用领域， 都有开 源软件存在（象 WordPress，Drupal 这些开源CMS）。然而很多人对开源许可并不了解，本文介绍开源领域常用的几种许可协议以及它们之间的区别。&lt;/p&gt;




&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;首先说说什么是许可协议？&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;什么是许可，当你为你的产品签发许可，你是在出让自己的权利，不过，你仍然拥有版权和专利（如果申请了的话），许可的目的是，向使用你产品的人提供一定的 权限。&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;不管产品是免费向公众分发，还是出售，制定一份许可协议非常有用，否则，对于前者，你相当于放弃了自己所有的权利，任何人都没有义务表明你的原始作者身 份，对于后者，你将不得不花费比开发更多的精力用来逐个处理用户的授权问题。&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;而开源许可协议使这 些事情变得简单，开发者很容易向一个项目贡献自己的代码，它还可以保护你原始作者的身份，使你至少获得认可，开源许可协议还可以阻止其它人将某个产品据为 己有。以下是开源界的 5 大许可协议。&lt;/p&gt;




&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;GNU GPL&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;GNU General Public Licence (GPL) 有可能是开源界最常用的许可模式。GPL 保证了所有开发者的权利，同时为使用者提供了足够的复制，分发，修改的权利：&lt;/p&gt;




&lt;ol style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;&lt;strong&gt;可自由复制&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;你可以将软件复制到你的电脑，你客户的电脑，或者任何地方。复制份数没有任何限制。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;可自由分发&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;在你的网站提供下载，拷贝到U盘送人，或者将源代码打印出来从窗户扔出去（环保起见，请别这样做）。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;可以用来盈利&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;你可以在分发软件的时候收费，但你必须在收费前向你的客户提供该软件的 GNU GPL 许可协议，以便让他们知道，他们可以从别的渠道免费得到这份软件，以及你收费的理由。&lt;/li&gt;
    &lt;li&gt;&lt;strong&gt;可自由修改&lt;/strong&gt;&lt;/li&gt;
    &lt;li&gt;如果你想添加或删除某个功能，没问题，如果你想在别的项目中使用部分代码，也没问题，唯一的要求是，使用了这段代码的项目也必须使用 GPL 协议。&lt;/li&gt;
&lt;/ol&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;需要注意的是，分发的时候，需要明确提供源代码和二进制文件，另外，用于某些程序的某些协议有一些问题和限制，你可以看一下 @PierreJoye 写的 Practical Guide to GPL Compliance 一文。使用 GPL 协议，你必须在源代码代码中包含相应信息，以及协议本身。&lt;/p&gt;




&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;GNU LGPL&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;GNU 还有另外一种协议，叫做 LGPL （Lesser General Public Licence），它对产品所保留的权利比 GPL 少，总的来说，LGPL 适合那些用于非 GPL 或非开源产品的开源类库或框架。因为 GPL 要求，使用了 GPL 代码的产品必须也使用 GPL 协议，开发者不允许将 GPL 代码用于商业产品。LGPL 绕过了这一限制。&lt;/p&gt;




&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;BSD&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;BSD 在软件分发方面的限制比别的开源协议（如 GNU GPL）要少。该协议有多种版本，最主要的版本有两个，新 BSD 协议与简单 BSD 协议，这两种协议经过修正，都和 GPL 兼容，并为开源组织所认可。&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;新 BSD 协议（3条款协议）在软件分发方面，除需要包含一份版权提示和免责声明之外，没有任何限制。另外，该协议还禁止拿开发者的名义为衍生产品背书，但简单 BSD 协议删除了这一条款。&lt;/p&gt;




&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;MIT&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;MIT 协议可 能是几大开源协议中最宽松的一个，核心条款是：&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;该软件及其相关文档对所有人免费，可以任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版权和许 可提示。&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;这意味着使用MIT您可以：&lt;/p&gt;




&lt;ol style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;你可以自由使用，复制，修改，可以用于自己的项目。&lt;/li&gt;
    &lt;li&gt;可以免费分发或用来盈利。&lt;/li&gt;
    &lt;li&gt;唯一的限制是必须包含许可声明。&lt;/li&gt;
    &lt;li&gt;MIT 协议是所有开源许可中最宽松的一个，除了必须包含许可声明外，再无任何限制。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;Apache&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;Apache 协议 2.0 和别的开源协议相比，除了为用户提供版权许可之外，还有专利许可，对于那些涉及专利内容的开发者而言，该协议最适合（这里有一篇文章阐述这个问题）。&lt;/p&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;Apache 协议还有以下需要说明的地方:&lt;/p&gt;




&lt;ol style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;永久权利&lt;/li&gt;
    &lt;li&gt;一旦被授权，永久拥有。&lt;/li&gt;
    &lt;li&gt;全球范围的权利&lt;/li&gt;
    &lt;li&gt;在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。&lt;/li&gt;
    &lt;li&gt;授权免费，且无版税&lt;/li&gt;
    &lt;li&gt;前期，后期均无任何费用。&lt;/li&gt;
    &lt;li&gt;授权无排他性&lt;/li&gt;
    &lt;li&gt;任何人都可以获得授权&lt;/li&gt;
    &lt;li&gt;授权不可撤消&lt;/li&gt;
    &lt;li&gt;一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码。&lt;/li&gt;
    &lt;li&gt;分发代码方面包含一些要求，主要是，要在声明中对参与开发的人给予认可并包含一份许可协议原文。&lt;/li&gt;
&lt;/ol&gt;


&lt;h3 style=&quot;color: #665500; font-size: 14px;&quot;&gt;Creative Commons&lt;/h3&gt;


&lt;p style=&quot;line-height: 19px;&quot;&gt;Creative Commons (CC) 并非严格意义上的开源许可，它主要用于设计。Creative Commons 有多种协议，每种都提供了相应授权模式，CC 协议主要包含 4 种基本形式：&lt;/p&gt;




&lt;ol style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;署名权
&lt;ul style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;必须为原始作者署名，然后才可以修改，分发，复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;保持一致
&lt;ul style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;作品同样可以在 CC 协议基础上修改，分发，复制。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;非商业
&lt;ul style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;作品可以被修改，分发，复制，但不能用于商业用途。但商业的定义有些模糊，比如，有的人认为非商业用途指的是不能销售，有的认为是甚至不能放在有广告的网 站，也有人认为非商业的意思是非盈利。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;不能衍生新作品
&lt;ul style=&quot;line-height: 19px;&quot;&gt;
    &lt;li&gt;你可以复制，分发，但不能修改，也不能以此为基础创作自己的作品。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;这些许可形式可以结合起来用，其中最严厉的组合是“署名，非商用，不能衍生新作品”，意味着，你可以分享作品，但不能改动或以此盈利，而且必须为原作者署 名。在这种许可模式下，原始作者对作品还拥有完全的控制权，而最宽松的组合是“署名”，意味着，只要为原始作者署名了，就可以自由处置。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;[code]&lt;/p&gt;

&lt;p&gt;以下就是一些版权声明的样例。&lt;/p&gt;

&lt;p&gt;Apache:
/&lt;em&gt;
* Copyright (c) 2002-$today.year, jetmaven.net All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
&lt;/em&gt;/
GPL:
/&lt;em&gt;
*
* Copyright (c) 2002-$today.year, jetmaven.net All Rights Reserved.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 2 of
* the License, or (at your option) any later version.
* This program is distributed in the hope that it will be
* useful, but WITHOUT ANY WARRANTY; without even the implied
* warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
* PURPOSE. See the GNU General Public License for more details.
* You should have received a copy of the GNU General Public
* License along with this program.if not, write to the Free
* Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
* USA.
&lt;/em&gt;/&lt;/p&gt;

&lt;p&gt;BSD:
/&lt;em&gt;*
* Copyright (c) 2002-$today.year, planetes.de All rights reserved.
*
* Redistribution and use in source and binary forms, with
* or without modification, are permitted provided that the
* following conditions are met:
*
* * Redistributions of source code must retain the a
* bove copyright notice, this list of conditions and the
* following disclaimer.
* * Redistributions in binary form must reproduce the
* above copyright notice, this list of conditions and
* the following disclaimer in the documentation and/
* or other materials provided with the distribution.
* * Neither the name of the planetes.de, centaurus nor the
* names of its contributors may be used to endorse
* or promote products derived from this software
* without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT
* HOLDERS AND CONTRIBUTORS &amp;quot;AS IS&amp;quot; AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR P
* URPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
* ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
* IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
* OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
* THE POSSIBILITY OF SUCH DAMAGE.
&lt;/em&gt;/&lt;/p&gt;

&lt;p&gt;Mozilla:
/&lt;em&gt;*
* Copyright (c) 2002-$today.year, jetmaven.net All Rights Reserved.
*
* The contents of this file are subject to the Mozilla Public
* License Version 1.1 (the &amp;quot;License&amp;quot;); you may not use this file
* except in compliance with the License. You may obtain a copy of
* the License at http://www.mozilla.org/MPL/
*
* Software distributed under the License is distributed on an &amp;quot;AS
* IS&amp;quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or
* implied. See the License for the specific language governing
* rights and limitations under the License.
&lt;/em&gt;/&lt;/p&gt;

&lt;p&gt;[/code]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redhat下使用ADSL拨号上网</title>
   <link href="http://dreambt.github.com/Linux/2009/10/02/linux-redhat-adsl"/>
   <updated>2009-10-02T21:18:18+08:00</updated>
   <id>http://dreambt.github.com/Linux/2009/10/02/linux-redhat-adsl</id>
   <content type="html">&lt;p&gt;本文以RedHat 5.4为实验平台，其它平台的Linux安装办法可以参照下面从源代码进行安装的步骤。&lt;/p&gt;

&lt;p&gt;一、安装的前提条件&lt;/p&gt;

&lt;p&gt;1.确保安装了网卡并工作正常&lt;/p&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;h1&gt;ifconfig eth0&lt;/h1&gt;

&lt;p&gt;查看网卡状态&lt;/p&gt;

&lt;p&gt;2.在系统中不要设置默认路由(网关),让ADSL拨号后自动获得&lt;/p&gt;

&lt;p&gt;如果已经设置了默认路由,使用以下方法删除:
在文件 /etc/sysconfig/network 中删除 GATEWAY= 这一行,然后以root执行:&lt;/p&gt;

&lt;h1&gt;/etc/rc.d/init.d/network restart&lt;/h1&gt;

&lt;p&gt;3.已经安装了pppd软件包&lt;/p&gt;

&lt;p&gt;如果存在文件 /usr/sbin/pppd,则说明已经安装了pppd;
如果未安装,从RedHatLinux 6.2安装光盘上安装ppp-2.3.11-4.i386.rpm这个软件包&lt;/p&gt;

&lt;p&gt;二、安装PPPOE客户端软件&lt;/p&gt;

&lt;p&gt;Linux下的PPPOE客户端软件比较多,而且大多使用GNU License,我们推荐使用rp-pppoe 这个软件包。从http://www.roaringpenguin.com/pppoe/这个网站上，不仅可以下载  RedHat 62平台下的rp-pppoe的二进制软件包，而且可以下栽源代码软件包。&lt;/p&gt;

&lt;p&gt;1.二进制软件包的安装：&lt;/p&gt;

&lt;p&gt;A.下载二进制软件包&lt;/p&gt;

&lt;p&gt;http://www.roaringpenguin.com/pppoe/rp-pppoe-3.2-1.i386.rpm&lt;/p&gt;

&lt;p&gt;B.进行安装&lt;/p&gt;

&lt;h1&gt;rpm -Uvh rp-pppoe-3.2-1.i386.rpm&lt;/h1&gt;

&lt;p&gt;2.从源代码进行安装：&lt;/p&gt;

&lt;p&gt;从源代码进行安装同样适用于其它平台的Linux,但必须在Linux系统中安装gcc编译器。&lt;/p&gt;

&lt;p&gt;A.下栽源代码软件包&lt;/p&gt;

&lt;p&gt;http://www.roaringpenguin.com/pppoe/rp-pppoe-3.2.tar.gz&lt;/p&gt;

&lt;p&gt;B.解压缩&lt;/p&gt;

&lt;h1&gt;tar xvfz rp-pppoe-3.2.tar.gz&lt;/h1&gt;

&lt;h1&gt;cd rp-pppoe-3.2&lt;/h1&gt;

&lt;p&gt;C.进行编译和安装&lt;/p&gt;

&lt;p&gt;运行脚本&lt;/p&gt;

&lt;h1&gt;./go&lt;/h1&gt;

&lt;p&gt;将自动进行编译和安装，最后，调用/usr/sbin/adsl-setup进行配置，具体解释见三。&lt;/p&gt;

&lt;p&gt;三、配置PPPOE客户端软件&lt;/p&gt;

&lt;p&gt;安装完软件包后，必须配置pppoe的配置文件/etc/ppp/pppoe.conf，从而让ADSL拨号时使用配置文件中的用户名、密码等参数。我们不必手工改动这个文件，可以使用
adsl-setup这个工具进行配置：&lt;/p&gt;

&lt;h1&gt;/usr/sbin/adsl-setup&lt;/h1&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Enter your PPPoE user name :
输入ADSL帐号的用户名&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Enter the Ethernet interface connected to the ADSL modem
For Solaris, this is likely to be something like /dev/hme0.
For Linux, it will be ethn, where 'n' is a number.
(default eth0):
输入 eth0 ,这是ADSL相连的网卡的名字&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Enter the demand value (default no):
输入 no&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Enter the DNS information here:
输入 server ,这表示使用ADSL拨号自动获得的DNS服务器IP地址&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Please enter your PPPoE password:
输入ADSL帐号的密码&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Choose a type of firewall (0-2):
输入 0 ，不使用防火墙&lt;/p&gt;

&lt;p&gt;当出现
&amp;gt;&amp;gt;&amp;gt; Accept these settings and adjust configuration files (y/n)?
如果输入的信息正确，输入 y ,完成配置，否则，输入 n 重新输入。&lt;/p&gt;

&lt;p&gt;四、启动PPPOE客户端软件&lt;/p&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;p&gt;/usr/sbin/adsl-start 启动PPPOE客户端软件,进行连接，如果成功，将出现  Connected;
如果不成功，请检查网线、ADSL MODEM等物理设备，并查看 /var/log/messages中的信息
/usr/sbin/adsl-stop 关闭和ISP的连接
/usr/sbin/adsl-status 查看当前连接的状态&lt;/p&gt;

&lt;p&gt;如果想在Linux系统启动时自动启动ADSL连接，输入以下命令&lt;/p&gt;

&lt;h1&gt;chkconfig --add adsl&lt;/h1&gt;

&lt;p&gt;将在当前的运行级下加入ADSL的自启动脚本&lt;/p&gt;

&lt;p&gt;五、测试&lt;/p&gt;

&lt;p&gt;当连接成功后，使用命令&lt;/p&gt;

&lt;h1&gt;ifconfig -a&lt;/h1&gt;

&lt;p&gt;在输出中应该含有关于 ppp0 的一堆信息，其中还绑定了 IP 地址,说明已经从拨号中获得了IP地址。&lt;/p&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;h1&gt;netstat -nr&lt;/h1&gt;

&lt;p&gt;查看路由表信息，这时的默认路由应该是上面获得的IP地址。
如果没有默认路由，我们可以手动增加：&lt;/p&gt;

&lt;h1&gt;route add default gw 上面获得的IP地址&lt;/h1&gt;

&lt;p&gt;使用命令&lt;/p&gt;

&lt;h1&gt;nslookup www.sina.com.cn&lt;/h1&gt;

&lt;p&gt;如果解析出新浪的IP，说明已经从拨号中正确获得了DNS服务器&lt;/p&gt;

&lt;p&gt;最后，使用命令ping某个域名或IP，如果有响应，表示你已经大功告成了。&lt;/p&gt;

&lt;p&gt;六、其它说明&lt;/p&gt;

&lt;p&gt;RedHat 5.4 默认安装了 rp-pppoe这个软件包，可以直接进行三后面的步骤。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux下用gdb调试c程序的总结</title>
   <link href="http://dreambt.github.com/Linux/2009/08/10/linux-gdb-debug-c"/>
   <updated>2009-08-10T22:33:00+08:00</updated>
   <id>http://dreambt.github.com/Linux/2009/08/10/linux-gdb-debug-c</id>
   <content type="html">&lt;p&gt;目录&lt;/p&gt;

&lt;ol&gt;
    &lt;li&gt;单步执行和跟踪函数调用&lt;/li&gt;
    &lt;li&gt;断点&lt;/li&gt;
    &lt;li&gt;观察点&lt;/li&gt;
    &lt;li&gt;段错误&lt;/li&gt;
&lt;/ol&gt;


&lt;ol&gt;
&lt;li&gt;单步执行和跟踪函数调用&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;看下面的程序:&lt;/p&gt;

&lt;h1&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;int add_range(int low, int high)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int i, sum;&lt;/p&gt;

&lt;p&gt;for (i = low; i &amp;lt;= high; i++)&lt;/p&gt;

&lt;p&gt;sum = sum + i;&lt;/p&gt;

&lt;p&gt;return sum;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;int main(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int result[100];&lt;/p&gt;

&lt;p&gt;result[0] = add_range(1, 10);&lt;/p&gt;

&lt;p&gt;result[1] = add_range(1, 100);&lt;/p&gt;

&lt;p&gt;printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);&lt;/p&gt;

&lt;p&gt;return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;$ gcc -g main.c -o main&lt;/p&gt;

&lt;p&gt;$ gdb main&lt;/p&gt;

&lt;p&gt;-g的作用是在目标文件中加入源代码的信息,比如目标文件中第几条机器指令对应源代码的第几行,但并不是把整个源文件嵌入到目标文件中,所以在调试时目标文件时必须保证gdb也能找到源文件。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;list(或l) 行号 列出从第几行开始的源代码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;list(或l) 函数名 列出某个函数的源代码&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;start命令  开始执行程序&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;run(简写为r)  从头开始连续而非单步执行程序&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;next命令(简写为n) 控制这些语句一条一条地执行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;step命令(简写为s) 进入函数中去执行&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;continue命令(简写为c)连续运行而非单步运行,程序到达断点会自动停下来&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;finish命令  执行到当前函数返回,然后停下来等待命令&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;backtrace命令(简写为bt)可以查看函数调用的栈帧（查看各级函数调用及参数）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;frame命令(简写为f) 选择栈帧&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;info命令(简写为i) i breakpoints 查看已经设置的断点&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;i 变量名        查看局部变量的值&lt;/p&gt;

&lt;p&gt;i locals  查看当前栈帧局部变量的值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;print命令(简写为p) 打出变量的值&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;例如：&lt;/p&gt;

&lt;p&gt;(gdb) bt  //查看函数调用的栈帧&lt;/p&gt;

&lt;h1&gt;0  add_range (low=1, high=10) at gdb1.c:6&lt;/h1&gt;

&lt;h1&gt;1  0x0000000000400516 in main () at gdb1.c:13&lt;/h1&gt;

&lt;p&gt;(gdb) f 1  //选择1号栈帧然后查看局部变量&lt;/p&gt;

&lt;h1&gt;1  0x0000000000400516 in main () at gdb1.c:13&lt;/h1&gt;

&lt;p&gt;13  result[0] = add_range(1, 10);&lt;/p&gt;

&lt;p&gt;(gdb) i locals //查看局部变量&lt;/p&gt;

&lt;p&gt;result = {-7984, 32767, 291519488, 62, 0, 0, -134231144, 0}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;set命令  修改变量的值&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;print命令  也可修改变量的值,因为print命令后面跟的是表达式,而我们知道赋值和函数调用也都是表达式,所以还可以用print来修改变量的值,或者调用函数。例如：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;(gdb) p result[2]=33&lt;/p&gt;

&lt;p&gt;$5 = 33&lt;/p&gt;

&lt;p&gt;(gdb) p printf(&quot;result[2]=%d\n&quot;, result[2])&lt;/p&gt;

&lt;p&gt;result[2]=33&lt;/p&gt;

&lt;p&gt;$6 = 13  //printf的返回值表示实际打印的字符数,所以$6的结果是13。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;断点&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;断点调试实例：输入123回车，输入123456回车，观察结果&lt;/p&gt;

&lt;h1&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;int main(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int sum = 0, i = 0;&lt;/p&gt;

&lt;p&gt;char input[5];&lt;/p&gt;

&lt;p&gt;while (1) {&lt;/p&gt;

&lt;p&gt;scanf(&quot;%s&quot;, input);&lt;/p&gt;

&lt;p&gt;for (i = 0; input[i] != '\0'; i++)&lt;/p&gt;

&lt;p&gt;sum = sum * 10 + input[i] - '0';&lt;/p&gt;

&lt;p&gt;printf(&quot;input=%d\n&quot;, sum);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;如果变量要赋初值,start不会跳过变量定义语句。因此sum被列为重点怀疑对象,我们可以用display命令使得每次停下来的时候都显示当前sum值，undisplay可以取消对先前设置的那些变量的跟踪。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;break命令  表示在某一个函数开头设断点。参数可以使行号，也可以是函数名。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;//可以带条件 break 9 if sum != 0&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;delete breakpoints (n)命令  表示删除某个或者全部断点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;disable breakpoints (n)命令 表示禁用某个或者全部断点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;enable breakpoints (n)命令  表示启用某个或者全部断点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;display命令(简写为d) display i 使得每次停下来的时候都显示当前i值&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;undisplay  取消对先前设置的那些变量的跟踪&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;观察点&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;观察点调试实例：输入123回车，输入123456789回车，输入12345回车&lt;/p&gt;

&lt;h1&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;int main(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int sum = 0, i = 0;&lt;/p&gt;

&lt;p&gt;char input[5];&lt;/p&gt;

&lt;p&gt;while (1) {&lt;/p&gt;

&lt;p&gt;sum = 0;&lt;/p&gt;

&lt;p&gt;scanf(&quot;%s&quot;, input);&lt;/p&gt;

&lt;p&gt;for (i = 0; input[i] != '\0'; i++)&lt;/p&gt;

&lt;p&gt;sum = sum * 10 + input[i] - '0';&lt;/p&gt;

&lt;p&gt;printf(&quot;input=%d\n&quot;, sum);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;info命令(简写为i) i breakpoints 查看已经设置的断点&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;i 变量名        查看局部变量的值&lt;/p&gt;

&lt;p&gt;i locals  查看当前栈帧局部变量的值&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;watch  设置观察点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;info watchpoints 查看当前设置了哪些观察点&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;x 从某个位置开始打印存储器的一段内容,全部当成字节来看,而不区分哪些字节属于哪些变量&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;x/7b input    //7b是打印格式,b表示每个字节一组,7表示打印7组&lt;/p&gt;

&lt;p&gt;删除原来设的断点,从头执行程序,重复上次的输入,用watch命令设置观察点&lt;/p&gt;

&lt;p&gt;(gdb) delete breakpoints&lt;/p&gt;

&lt;p&gt;Delete all breakpoints? (y or n) y&lt;/p&gt;

&lt;p&gt;(gdb) start&lt;/p&gt;

&lt;p&gt;Breakpoint 1 at 0x80483b5: file main.c, line 5.&lt;/p&gt;

&lt;p&gt;Starting program: /home/akaedu/main&lt;/p&gt;

&lt;p&gt;main () at main.c:5&lt;/p&gt;

&lt;p&gt;5               int sum = 0, i = 0;&lt;/p&gt;

&lt;p&gt;(gdb) n&lt;/p&gt;

&lt;p&gt;9                       sum = 0;&lt;/p&gt;

&lt;p&gt;(gdb) (直接回车)&lt;/p&gt;

&lt;p&gt;10                      scanf(&quot;%s&quot;, input);&lt;/p&gt;

&lt;p&gt;(gdb) (直接回车)&lt;/p&gt;

&lt;p&gt;12345&lt;/p&gt;

&lt;p&gt;11                      for (i = 0; input[i] != '\0';i++)&lt;/p&gt;

&lt;p&gt;(gdb) watch input[5]&lt;/p&gt;

&lt;p&gt;Hardware watchpoint 2: input[5]&lt;/p&gt;

&lt;p&gt;(gdb) i watchpoints&lt;/p&gt;

&lt;p&gt;Num     Type           Disp Enb Address     What&lt;/p&gt;

&lt;p&gt;2       hw watchpoint keep y                input[5]&lt;/p&gt;

&lt;p&gt;(gdb) c&lt;/p&gt;

&lt;p&gt;Continuing.&lt;/p&gt;

&lt;p&gt;Hardware watchpoint 2: input[5]&lt;/p&gt;

&lt;p&gt;Old value = 0 '\0'&lt;/p&gt;

&lt;p&gt;New value = 1 '\001'&lt;/p&gt;

&lt;p&gt;0x0804840c in main () at main.c:11&lt;/p&gt;

&lt;p&gt;11                      for (i = 0; input[i] != '\0';i++)&lt;/p&gt;

&lt;p&gt;(gdb) c&lt;/p&gt;

&lt;p&gt;Continuing.&lt;/p&gt;

&lt;p&gt;Hardware watchpoint 2: input[5]&lt;/p&gt;

&lt;p&gt;Old value = 1 '\001'&lt;/p&gt;

&lt;p&gt;New value = 2 '\002'&lt;/p&gt;

&lt;p&gt;0x0804840c in main () at main.c:11&lt;/p&gt;

&lt;p&gt;11                      for (i = 0; input[i] != '\0';i++)&lt;/p&gt;

&lt;p&gt;(gdb) c&lt;/p&gt;

&lt;p&gt;Continuing.&lt;/p&gt;

&lt;p&gt;Hardware watchpoint 2: input[5]&lt;/p&gt;

&lt;p&gt;Old value = 2 '\002'&lt;/p&gt;

&lt;p&gt;New value = 3 '\003'&lt;/p&gt;

&lt;p&gt;0x0804840c in main () at main.c:11&lt;/p&gt;

&lt;p&gt;11                      for (i = 0; input[i] != '\0';i++)&lt;/p&gt;

&lt;p&gt;如果输入的不是数字而是字母或别的符号也能算出结果来,这显然是不对的,可以在循环中加上判断条件:&lt;/p&gt;

&lt;p&gt;while (1) {&lt;/p&gt;

&lt;p&gt;sum = 0;&lt;/p&gt;

&lt;p&gt;scanf(&quot;%s&quot;, input);&lt;/p&gt;

&lt;p&gt;for (i = 0; input[i] != '\0'; i++) {&lt;/p&gt;

&lt;p&gt;if (input[i] &amp;lt; '0' || input[i] &amp;gt; '9') {&lt;/p&gt;

&lt;p&gt;printf(&quot;Invalid input!\n&quot;);&lt;/p&gt;

&lt;p&gt;sum = -1;&lt;/p&gt;

&lt;p&gt;break;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;sum = sum*10 + input[i] - '0';&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;printf(&quot;input=%d\n&quot;, sum);&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;段错误&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;段错误调试实例一&lt;/p&gt;

&lt;h1&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;int main(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int man = 0;&lt;/p&gt;

&lt;p&gt;scanf(&quot;%d&quot;, man);&lt;/p&gt;

&lt;p&gt;return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;调试过程如下:&lt;/p&gt;

&lt;p&gt;$ gdb main&lt;/p&gt;

&lt;p&gt;......&lt;/p&gt;

&lt;p&gt;(gdb) r&lt;/p&gt;

&lt;p&gt;Starting program: /home/akaedu/main&lt;/p&gt;

&lt;p&gt;123&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.&lt;/p&gt;

&lt;p&gt;0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6&lt;/p&gt;

&lt;p&gt;(gdb) bt&lt;/p&gt;

&lt;h1&gt;0 0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6&lt;/h1&gt;

&lt;h1&gt;1 0xb7e1dd2b in scanf () from /lib/tls/i686/cmov/libc.so.6&lt;/h1&gt;

&lt;h1&gt;2 0x0804839f in main () at main.c:6&lt;/h1&gt;

&lt;p&gt;在gdb中运行,遇到段错误会自动停下来,这时可以用命令查看当前执行到哪一行代码了。gdb显示段错误出现在_IO_vfscanf函数中,用bt命令可以看到这个函数是被我们的scanf函数调用的,所以是scanf这一行代码引发的段错误。仔细观察程序发现是man前面少了个&amp;amp;。&lt;/p&gt;

&lt;p&gt;上一节我们调试了一个输入字符串转整数的程序,最后提出修正Bug的方法是在循环中加上判断条件,如果不是数字就报错退出,不仅输入字母可以报错退出,输入超长的字符串也会报错退出。然而真的把两个Bug一起解决了吗?这其实是一种治标不治本的办法,因为并没有制止scanf的访问越界。我说过了,使用scanf函数是非常凶险的。表面上看这个程序无论怎么运行都不出错了,但假如我们把while (1) 循环去掉,每次执行程序只转换一个数:&lt;/p&gt;

&lt;p&gt;段错误调试实例二&lt;/p&gt;

&lt;h1&gt;include &amp;lt;stdio.h&amp;gt;&lt;/h1&gt;

&lt;p&gt;int main(void)&lt;/p&gt;

&lt;p&gt;{&lt;/p&gt;

&lt;p&gt;int sum = 0, i = 0;&lt;/p&gt;

&lt;p&gt;char input[5];&lt;/p&gt;

&lt;p&gt;scanf(&quot;%s&quot;, input);&lt;/p&gt;

&lt;p&gt;for (i = 0; input[i] != '\0'; i++) {&lt;/p&gt;

&lt;p&gt;if (input[i] &amp;lt; '0' || input[i] &amp;gt; '9') {&lt;/p&gt;

&lt;p&gt;printf(&quot;Invalid input!\n&quot;);&lt;/p&gt;

&lt;p&gt;sum = -1;&lt;/p&gt;

&lt;p&gt;break;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;sum = sum*10 + input[i] - '0';&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;printf(&quot;input=%d\n&quot;, sum);&lt;/p&gt;

&lt;p&gt;return 0;&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;然后输入一个超长的字符串,看看会发生什么:&lt;/p&gt;

&lt;p&gt;$ ./main&lt;/p&gt;

&lt;p&gt;1234567890&lt;/p&gt;

&lt;p&gt;Invalid input!&lt;/p&gt;

&lt;p&gt;input=-1&lt;/p&gt;

&lt;p&gt;看起来正常。再来一次,这次输个更长的:&lt;/p&gt;

&lt;p&gt;$ ./main&lt;/p&gt;

&lt;p&gt;1234567890abcdef&lt;/p&gt;

&lt;p&gt;Invalid input!&lt;/p&gt;

&lt;p&gt;input=-1&lt;/p&gt;

&lt;p&gt;Segmentation fault&lt;/p&gt;

&lt;p&gt;又段错误了。我们按同样的方法用gdb调试看看:&lt;/p&gt;

&lt;p&gt;$ gdb main&lt;/p&gt;

&lt;p&gt;......&lt;/p&gt;

&lt;p&gt;(gdb) r&lt;/p&gt;

&lt;p&gt;Starting program: /home/akaedu/main&lt;/p&gt;

&lt;p&gt;1234567890abcdef&lt;/p&gt;

&lt;p&gt;Invalid input!&lt;/p&gt;

&lt;p&gt;input=-1&lt;/p&gt;

&lt;p&gt;Program received signal SIGSEGV, Segmentation fault.&lt;/p&gt;

&lt;p&gt;0x0804848e in main () at main.c:19&lt;/p&gt;

&lt;p&gt;19      }&lt;/p&gt;

&lt;p&gt;(gdb) l&lt;/p&gt;

&lt;p&gt;14                     }&lt;/p&gt;

&lt;p&gt;15                     sum = sum*10 + input[i] - '0';&lt;/p&gt;

&lt;p&gt;16             }&lt;/p&gt;

&lt;p&gt;17             printf(&quot;input=%d\n&quot;, sum);&lt;/p&gt;

&lt;p&gt;18             return 0;&lt;/p&gt;

&lt;p&gt;19      }&lt;/p&gt;

&lt;p&gt;gdb指出,段错误发生在第19行。可是这一行什么都没有啊,只有表示main函数结束的}括号。这可以算是一条规律,如果某个函数中发生访问越界,很可能并不立即产生段错误,而在函数返回时却产生段错误。&lt;/p&gt;

&lt;p&gt;想要写出Bug-free的程序是非常不容易的,即使scanf读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误,有些错误现象是我们暂时没法解释的:为什么变量i的存储单元紧跟在input数组后面?为什么同样是访问越界,有时出段错误有时不出段错误?为什么访问越界的段错误在函数返回时才出现?还有最基本的问题,为什么scanf输入整型变量就必须要加&amp;amp;,否则就出段错误,而输入字符串就不要加&amp;amp;?&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>我也要救活我的哆啦A梦</title>
   <link href="http://dreambt.github.com/Life/2009/07/15/save-my-dongman"/>
   <updated>2009-07-15T19:41:23+08:00</updated>
   <id>http://dreambt.github.com/Life/2009/07/15/save-my-dongman</id>
   <content type="html">&lt;h2 style=&quot;text-align: left;&quot;&gt;故事概要&lt;/h2&gt;


&lt;p&gt;《哆啦A梦》的主角野比大雄，是住在日本东京都练马区月见台茫原（虚构的地名）的小学生（依照原作所刊载的杂志不同，年级也会有差异，在单行本里基本上是四年级（也有例外，此外日本电视台版的动画也是四年级，而大山版的动画则是设定为五年级）。身为家中唯一独子的大雄，和来自未来22世纪的猫型机器人哆啦A梦共同生活。&lt;/p&gt;

&lt;p&gt;大雄虽然是身边围绕着父母、老师、同学的普通小学生，但是对于运动和念书都很不擅长，学业成绩极差，平均每五次考试就有一次是零分（第23集，“学校转来一个差生”；第42集，“钻进去吧！蛤蜊箱”），也时常被周遭的同学欺侮。此外大雄的运气也不好，经常遇到各种灾难，连猜拳都经常会输（除了和只会出石头的哆啦A梦猜拳能赢之外）。由于大雄这样的特性，也影响到了未来子孙的生活和表现，因此为了让情况有所改善，大雄的玄孙野比世修从未来的22世纪带了哆啦A梦来帮助大雄，利用哆啦A梦许多未来世界的神秘的道具协助大雄，故事也就此展开。&lt;/p&gt;

&lt;h2&gt;人物设定&lt;/h2&gt;


&lt;p&gt;哆啦A梦：来自未来世界的蓝色猫型机器人，为改变大雄的命运而来。&lt;/p&gt;

&lt;p&gt;大雄：故事最主要角色，也是哆啦A梦中唯一一个每回都有出场的人物。功课体育不好个性懒惰，但心地善良，热爱自然。&lt;/p&gt;

&lt;p&gt;静香：大雄的女同学，用功兼性情温和，是大雄未来的妻子。&lt;/p&gt;

&lt;p&gt;小夫：家里有钱，喜好炫耀的同学。&lt;/p&gt;

&lt;p&gt;胖虎：本名刚田武。力量大，爱欺负人，但也有正义感的同学。喜欢唱歌，但歌声吓人。&lt;/p&gt;

&lt;p&gt;次要角色包括：野比家：野比野比助（大雄父）、 野比玉子（大雄母，婚前姓片冈）、野比野比郎（大雄叔父，野比助之弟）、片冈玉夫（大雄舅父，玉子之弟）&lt;/p&gt;

&lt;p&gt;源家：源义雄（静香父）、静香的母亲、佩罗（静香养的狗）、比可（静香养的鸟）&lt;/p&gt;

&lt;p&gt;骨川家：小夫的父亲、 小夫的母亲、骨川吉夫（小夫的表哥）、小吉（小夫的弟弟。在美国生活）&lt;/p&gt;

&lt;p&gt;刚田家：胖虎的父亲、胖虎的母亲、胖妹（又译阿花、小珠、技兰等，胖虎的妹妹）、酷哥（胖虎捡的杂种狗）&lt;/p&gt;

&lt;p&gt;出木杉：无缺点的天才少年，大雄嫉妒的对象。&lt;/p&gt;

&lt;p&gt;哆啦美：哆啦A梦的妹妹&lt;/p&gt;

&lt;p&gt;迷你哆啦&lt;/p&gt;

&lt;p&gt;大雄的老师&lt;/p&gt;

&lt;h2&gt;哆啦A梦的道具&lt;/h2&gt;


&lt;p&gt;哆啦A梦为了帮助大雄，经常从他的四维空间口袋里拿出来自未来世界的道具，各种道具的创意和科幻想像成为《哆啦A梦》的特色之一。截至目前为止，最权威的统计是漫画版的哆啦A梦共有1963个道具，但若含动画版出现的道具则总数超过2000个。&lt;/p&gt;

&lt;p&gt;根据设定，哆啦A梦的道具中有一开始就带入的，但大多数还是后来从未来的百货公司购买。虽然其中有的是高价优质品，但大部分都是一次性的。此外也有出租来的道具。&lt;/p&gt;

&lt;p&gt;每一百个月（即每八年四个月），哆啦A梦就要对道具进行一次检修清理。其中不能再用的会被丢弃到四维垃圾桶里，或者被埋掉。有的从未来商店买错的道具会被大雄乱用，造成骚动。&lt;/p&gt;

&lt;p&gt;未来有法律规定不能用道具来赚钱，否则会罚款。不过，有的时候哆啦A梦也打算拿道具赚钱。&lt;/p&gt;

&lt;p&gt;根据朝日电视台的统计，哆啦A梦所有道具中最广受大家欢迎的前五位分别是：&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;任意门&lt;/li&gt;
    &lt;li&gt;时光机&lt;/li&gt;
    &lt;li&gt;竹蜻蜓&lt;/li&gt;
    &lt;li&gt;时间包巾&lt;/li&gt;
    &lt;li&gt;记忆面包&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;官方非正式大结局&lt;/h2&gt;


&lt;p&gt;有以下三个，皆随连载的重新开始而转为非正式结局。&lt;/p&gt;

&lt;p&gt;《再见，哆啦A梦》版&lt;/p&gt;

&lt;p&gt;哆啦A梦有日必须回未来了。大雄靠自己打败胖虎后，哆啦A梦就回去了。在昭和49年（1974年）3月号绘制，当时因为没人气，本来藤子想因此结束。但出于哆啦A梦的热爱，他又在下一期画了《哆啦A梦归来了》 ，内容为大雄在4月1日被胖虎骗，他决定喝下哆啦A梦留给他的“谎话800”药水，因为大雄说了：“哆啦A梦不会回来”终于和哆啦A梦重逢了。后来《再见，哆啦A梦》收录于单行本第6卷、而《哆啦A梦归来了》则收录于单行本第7卷。&lt;/p&gt;

&lt;p&gt;昭和46版&lt;/p&gt;

&lt;p&gt;昭和46年（1971年）版，因为未来人去现代观光，而造成了现代人的困扰，未来政府立法禁止时光旅行，因而使哆啦A梦必须回去。&lt;/p&gt;

&lt;p&gt;昭和47版&lt;/p&gt;

&lt;p&gt;昭和47年（1972年）版，世修认为如果哆啦A梦一直在大雄身边，大雄将会因为凡事依赖别人而一事无成，所以要哆啦A梦回未来。因而哆啦A梦装病，但后来大雄很担心，哆啦A梦便向大雄说他真正要回未来的原因，大雄说他也是这么想，便让哆啦A梦回未来。从此哆啦A梦天天用时光电视看大雄努力向上的样子。日本电视台昭和48年（1973年）放映的哆啦A梦依此为脚本，放映出哆啦A梦最后一集。&lt;/p&gt;

&lt;h2&gt;网络流传大结局版&lt;/h2&gt;


&lt;p&gt;自BBS时代开始，华文地区网络上就流传着数种虚构的哆啦A梦结局，其来源多半为日本方面较早的谣传。&lt;/p&gt;

&lt;h3&gt;植物人、自闭症儿童版&lt;/h3&gt;


&lt;p&gt;虽然内容略有差异，但皆以“大雄为植物人、自闭症儿童或其他失去身心自由之人，所发生的一切皆如南柯一梦”为主要架构的灰暗版本结局，自从BBS流行之后即曾出现在各大动漫讨论版，历史悠久的假结局，其主要的版本包括：&lt;/p&gt;

&lt;p&gt;‧大雄是个自闭症儿童。而哆啦A梦及它的一切，只是大雄自己的幻想。&lt;/p&gt;

&lt;p&gt;‧大雄是个植物人，哆啦A梦的故事是他所做的梦。&lt;/p&gt;

&lt;p&gt;‧大雄因为车祸必须动手术，哆啦A梦把所有的道具卖光以换取手术费。可惜手术失败而成植物人，哆啦A梦拿出时间门让大雄选择他想去的地方。大雄最后选择：“天国。”&lt;/p&gt;

&lt;p&gt;由于不难发现相同的要素，因此上叙各类版本的结局应为同一版本的变体。&lt;/p&gt;

&lt;p&gt;来源：大雄为植物人(或自闭儿)版本的虚构结局早在藤子·F·不二雄在世时即已出现，源头为1985年开始在日本小学生之间以“藤子老师马上要画的哆啦A梦结局”的名义开始流传，而如同人面犬、裂口女、不幸的信等小学生都会传说一般，在极短时间内快速漫延，最后甚至演变成藤子‧F‧不二雄本人不得不出面加以澄清，否定该种结局之存在的地步。&lt;/p&gt;

&lt;h3&gt;《哆啦A梦没电了》版&lt;/h3&gt;


&lt;p&gt;某一天，哆啦A梦忽然没电了，大雄用时光电视向哆啦美求助，但由于时空巡逻队忽然对时间旅行进行了原因不名的严格限制，导致哆啦美无法回到20世纪为哆啦A梦充电，这导致大雄面对了痛苦的二选一─不是冒着让哆啦A梦失去与大雄共处记忆的风险将他送回未来修理(哆啦A梦在没电时储存生活记忆的内存位在被咬掉的耳朵里)，就是得静待未来研发出保存哆啦A梦记忆的机器人科技。最后，大雄选择了后者，并且决定要靠自己的能力去达成；终于，在数十年后，大雄成为一位世界知名的机器人工学博士,对自己许下的愿望创造了奇迹...&lt;/p&gt;

&lt;p&gt;与植物人版等版本不同的是，这个版本的哆啦A梦结局在网络上有完整的漫画稿流传（其他版本的非官方结局均未曾有图片流出，即使少数指称自己见过这些漫画版本的证言也极不可信），同时因故事架构完整且感人（但细心的哆啦迷可以发现本篇对大雄等人成人后世界的安排不同于原著，且有些地方不合逻辑），故曾在2005年前后被许多人误认为“哆啦A梦真正的完结篇”在网络上广为流传。&lt;/p&gt;

&lt;h2&gt;今天看到的结局版本&lt;/h2&gt;


&lt;p&gt;世界，真的不是美丽的——主角大雄突然从睡梦中惊醒，发现自己躺在病床上。原来，世界上从没有过机器猫、也没有万能口袋、也没有.....总之，主角是由于极度的自闭症被送入精神病院的病人，已经在医院住了八年，静子是主角儿时暗恋的同伴，主角所有的记忆都停留在八年前的早晨。一切都是主角的幻想......&lt;/p&gt;

&lt;p&gt;这个结局反映了日本社会的冷漠，也表达了作者对社会的极度失望...后来，由于读者极其反感其结局（同时期日本自杀率明显UP，至少有一百多人是直接受其结局影响而对生活感到决望，《机器猫》是这些自杀者唯一美好单纯的心理慰藉），所以才决定不在动画版中使用此结局。（国内当然更看不到）在小学馆的博物馆中，珍藏着藤本弘先生的最后一页作品《野比太发条都市大冒险》藤本弘先生并没有完成最后的作品就去世了，死因是积劳成疾。&lt;/p&gt;

&lt;p&gt;机器猫的结局官方最终敲定为传闻结局：&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;小叮当没电——某天，大雄如往常般，忘了做作业,在学校被老师骂;也如往常般被技安、阿福他们欺负。就连未来的太太静宜也答应要先嫁给别人。总之，对大雄来讲，生活就是一连串类似事件的反覆。今天跟昨天没什么两样。 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;唯一的变化是，叮当突然变成植物机器。无论大雄怎么踢、打和骂，叮当都没有反应。大雄不知道叮当到底发生了什么事，只伤心得哭了整晚。可是，无论大雄再伤心透了，叮当也只是闻风不动地坐在柱子前。大雄伸手到口袋内试试，但口袋也豪无任何动静。最后大雄想起抽屉里的时间飞行机，就穿著睡衣飞到22世纪去找叮当的妹妹叮铃。叮铃还没完全听完说明，就被大雄催著坐上飞行机飞回20世纪。叮铃一看哥哥动也不动，马上知道是电池用完了。正想换电池时，叮铃想起一个非常重大的事。没有备用电源……大雄不懂得其中意思，只在一旁催。叮铃只好问大雄：你愿意让哥哥跟你的回忆都消失吗？原来旧型的猫机器人的耳朵里，装有备用电源，以便充电时能保持至今为止的记忆。可是……叮当没有耳朵！（这是众所皆知的吧。）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;大雄终于里解了事情的困难。种种回忆在大雄的脑海里奔腾大雄跟叮当曾飞到过去、未来，也曾到恐龙世界，海底世界，更在宇宙打过仗……叮铃拼命解释给大雄听。若要装新电池，叮当醒来时会失去一切与大雄曾有过的回忆。若保持现状，记忆不会消失。结果，大雄选择保持现状。此时，大雄还是小学六年级。十数年后……从海外归国的大雄，已成长为英俊迷人的青年，并就职于某家尖端科技的企业。他身边的新娘，正是宜静。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;&lt;strong&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;当年，叮铃回到22世纪后，大雄只跟身边的人们说，叮当回到未来的世界去了。时日一久，也就没人再提叮当的事。不过，叮当其实一直被保管在大雄家的壁橱里。大雄为了修好叮当，拼命用功读书，然后国中、高中、大学，成绩逐年升腾。最后到国外求学。现在，大雄身在他自己的研究室中。他叫来平日严禁其出入研究室的妻子静宜。对她说：&quot;你看，我要按开关了。&quot;说完，大雄颊上情不自禁流下两串泪珠。他就是为了这一刻，苦学了十几年……为了这一刻，从一个老是忘了做作业、成绩从倒数起算比较快的笨学生，爬到今天的地位……当他开关按下后，久久一阵的静寂，静寂……终于，叮当开口了：&quot;大雄，功课已经做完了吗。&quot;仿佛一切又回到了当初，感动的泪水随之流下……&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;很感人的结局！愿时光能永远定格在最后那一幕！ ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ­&lt;/p&gt;

&lt;p&gt;看完之后很感动 之前一直看这个片子&lt;/p&gt;

&lt;p&gt;但从来未曾想过它会是怎样的结局&lt;/p&gt;

&lt;p&gt;我以为美好的故事可以这样继续着 像我们会长大的梦想&lt;/p&gt;

&lt;p&gt;我以为这样 但我没有想过  作者的生命是有限 他带着未完成的美好的梦想走了 ­&lt;/p&gt;

&lt;p&gt;那大雄 他的生命的结局 都是不可避免我们最后的幻想 ­&lt;/p&gt;

&lt;p&gt;心里很酸很感动  为这份情谊 ­&lt;/p&gt;

&lt;p&gt;看着我们小时候是小时候的大雄  我们小时候是哆啦A梦的梦想 ­&lt;/p&gt;

&lt;p&gt;最终随着时间的流逝 他们都老去    他回到了现实 努力为他的朋友 为了救小叮当 ­&lt;/p&gt;

&lt;p&gt;脑海浮现出好多好多你们在一起的日子&lt;/p&gt;

&lt;p&gt;道具 历历在目 你们陪过我童年的幻想&lt;/p&gt;

&lt;p&gt;最后的最后 哆啦A梦终于醒了的时候 ­&lt;/p&gt;

&lt;p&gt;他心里的结打开了 一辈子的心结和牵挂 ­&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;【大雄，我等你很久了】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;哆啦A梦的心声 它也在等待&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;或许每个在哆啦A梦的故事中成长起来的孩子&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;都期待着自己也能有一个属于自己的机器猫 有一个属于自己的百宝袋&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;都曾经对于竹蜻蜓与任意门编织的世界有着无尽的向往与期待&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;可是 每个孩子都一定会长大的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;时间在我们身上留下深深的烙印 ­&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;于是 我们都变了­&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;变的更加冷漠世故 更加贪婪无度 更加虚伪做作 更加自私势利­&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;曾几何时 那些对于友情的坚定执着 对于爱情的纯真炽热 对于未来的沸腾憧憬&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;在人性的苍凉中渐渐冷却下来&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;故事的结局 或许是大团圆的有些许恶俗&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;但对于孩子们来说 这个就是能够给他们希望与力量的感动 ­&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;而这样的感动 对于我们来说 已经有多久不曾拥有了 ­&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;或许 以后也都不可能再拥有了吧&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;机器猫是属于孩子的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;它太过梦幻 亦太过理想&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体; font-size: x-small;&quot;&gt;可是 对不起 我们已经不再年少&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-size: x-small;&quot;&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;不再适合梦幻和理想&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是的  回不去了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;我们的挽回 为的也只是挽回  挽回的是这份情谊 ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;而被时光改变的我们 ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;逝去的 青春最好的时光 去换这分最最珍贵的情谊 ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;而为了的却并不是回到过去&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;人生就这么一次  真正的人生就是相偎相依 无论时间流逝&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;哪怕相互依靠的时间有多么短或多么长&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;大雄和多啦A梦在一起的那段最最美好的日子&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;一切都是因为记忆和回忆&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;所以至少&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是有永远的永远 ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;为之挽回的 不是过去 ­&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;是彼此之间的[永远]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;font-family: 宋体;&quot;&gt;爱 梦想 永恒 →都是我们现实不可或缺的 重要部分。 ­&lt;/span&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>浅谈s:form标签中action属性为XX.action与XX的区别</title>
   <link href="http://dreambt.github.com/J2EE/2009/07/11/s-form-action"/>
   <updated>2009-07-11T19:05:32+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2009/07/11/s-form-action</id>
   <content type="html">&lt;p&gt;先来看一个实例struts.xml的内容：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;XML代码&lt;/div&gt;
&lt;ol class=&quot;dp-xml&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;home&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;extends&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/demo/home&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;home&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;com.demo.home.HomeAction&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;redirect-action&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/demo/login &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;actionName&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;login!init.action &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;userManage&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;redirect-action&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;namespace&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/demo/userManage &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;actionName&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;userManage!init.action &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;userManage&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;extends&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/demo/userManage&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;userManage&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;com.demo.userManage.UserManageAction&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;type&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;redirect&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/login/login.jsp &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;extends&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/demo/login&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;class&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;com.demo.login.LoginAction&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;input&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;/login/login.jsp &lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;package&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;继续看 login.jsp 的内容：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;JSP代码&lt;/div&gt;
&lt;ol class=&quot;dp-j&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span&gt;&amp;lt;s:form action=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;login.action&quot;&lt;/span&gt;&lt;span&gt; method=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span&gt; namespace=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;/demo/login&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &amp;lt;table width=&lt;span class=&quot;string&quot;&gt;&quot;100%&quot;&lt;/span&gt;&lt;span&gt; align=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;center&quot;&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;name : &amp;lt;s:textfield name=&lt;span class=&quot;string&quot;&gt;&quot;loginForm.name&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;password : &amp;lt;s:password name=&lt;span class=&quot;string&quot;&gt;&quot;loginForm.password&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&amp;lt;s:submit name=&lt;span class=&quot;string&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span&gt; value=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;submit&quot;&lt;/span&gt;&lt;span&gt; method=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;login&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt; &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &amp;lt;/table&amp;gt; &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&amp;lt;/s:form&amp;gt; &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;已知问题：&lt;/p&gt;

&lt;p&gt;从home进入login.jsp页面时，点击&quot;submit&quot;按钮，程序执行正常。
但是从userManage重定向到login.jsp页面时，点击&quot;submit&quot;按钮，出现下面的异常：
&lt;span style=&quot;color: #ff0000;&quot;&gt;javax.servlet.ServletException: java.lang.NoSuchMethodException: com.opensymphony.xwork2.ActionSupport.login()
org.apache.struts2.dispatcher.Dispatcher.serviceAction(Dispatcher.java:515)
org.apache.struts2.dispatcher.FilterDispatcher.doFilter(FilterDispatcher.java:419) &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;然后我把login.jsp的 &amp;lt;s:form action=&quot;&lt;strong&gt;login.action&lt;/strong&gt;&quot; method=&quot;post&quot; namespace=&quot;/demo/login&quot;&amp;gt;
改成 &amp;lt;s:form action=&quot;&lt;strong&gt;login&lt;/strong&gt;&quot; method=&quot;post&quot; namespace=&quot;/demo/login&quot;&amp;gt; 就能正常执行了。&lt;/p&gt;

&lt;p&gt;很多网友都在讨论 .action 到底应该又还是不应该有，那么我们先看看下面的分析吧&lt;/p&gt;

&lt;p&gt;jsp页面带 .action 时：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;XML代码&lt;/div&gt;
&lt;ol class=&quot;dp-xml&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;s:form&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;testForm&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;action&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;add.action&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/user&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;查看HTML原代码：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;HTML代码&lt;/div&gt;
&lt;ol class=&quot;dp-xml&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;form&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;testForm&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;action&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;add.action&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;method&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;jsp页面不带 .action 时：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;XML代码&lt;/div&gt;
&lt;ol class=&quot;dp-xml&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;s:form&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;testForm&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;action&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;namespace&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/user&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;查看HTML原代码：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;HTML代码&lt;/div&gt;
&lt;ol class=&quot;dp-xml&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;tag-name&quot;&gt;form&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;id&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;testForm&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;name&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;action&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;/teststruts2_1/user/add&quot;&lt;/span&gt;&lt;span class=&quot;attribute&quot;&gt;method&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span class=&quot;attribute-value&quot;&gt;&quot;post&quot;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>struts2的struts-config.xml文件</title>
   <link href="http://dreambt.github.com/J2EE/2009/07/11/struts2-struts-config-xml"/>
   <updated>2009-07-11T18:47:35+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2009/07/11/struts2-struts-config-xml</id>
   <content type="html">&lt;p&gt;弄清楚struts-config.xml中各项元素的作用，对于我们构建web项目有莫大的好处。&amp;lt;struts-config&amp;gt;是struts的根元素，它主要有8个子元素，DTD定义如下：&lt;/p&gt;

&lt;p&gt;&amp;lt;!ELEMENT struts-config
(data-sources?,form-beans?,global-exceptions?,global-forwards?,action-mappings?,controller?,message-resources&lt;em&gt;,plug-in&lt;/em&gt;)
&amp;gt;
以上8个元素，下面一一描述：
&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt;1. date-sources元素
&lt;/strong&gt;&lt;/span&gt;&lt;span style=&quot;color: #000000;&quot;&gt;&lt;strong&gt; &lt;/strong&gt;date-sources元素用来配置应用程序所需要的数据源。java语言提供了javax.sql.DateSource接口，所有数据源必须实现该接口。如下配置：
&amp;lt;data-sources&amp;gt;
&amp;lt;data-source type=&quot;org.apached.commons.dbcp.BasicDataSource&quot;&amp;gt;
………………
&amp;lt;/data-source&amp;gt;
&lt;/span&gt;&amp;lt;/data-sources&amp;gt;
在Action中访问方式如：
javax.sql.DataSource dataSource;
java.sql.Connection myConnection;
try
{
dataSource = getDataSource(request);
myConnection　＝　dataSource.getConnection();
}
…………
如果是多数据源，可用如下配置：
&amp;lt;data-sources&amp;gt;
&amp;lt;data-source key=&quot;a&quot;  type=&quot;org.apached.commons.dbcp.BasicDataSource&quot;&amp;gt;
………………
&amp;lt;/data-source&amp;gt;
&amp;lt;data-source key=&quot;b&quot;   type=&quot;org.apached.commons.dbcp.BasicDataSource&quot;&amp;gt;
………………
&amp;lt;/data-source&amp;gt;
&amp;lt;/data-sources&amp;gt;
访问方式：dataSource = getDataSource(request,&quot;a&quot;);&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; 2. form-beans元素&lt;/span&gt;&lt;/strong&gt;
该元素主要用来配置表单验证的类。它包含如下属性：
1. classname：一般用得少，指定和form-bean无素对应的配置类，默认为org.apache.struts.config.FormBeanConfig，如果自定义，则必须扩展FormBeanConfig类。可有可无。
2. name：ActionForm Bean的惟一标识。必须。
3. type：ActionForm的完整类名。必须。
如下所示：
&amp;lt;form-beans&amp;gt;
&amp;lt;form-bean
name=&quot;Loign&quot;
type=&quot;com.ha.login&quot;&amp;gt;
&amp;lt;/form-bean&amp;gt;
&amp;lt;/form-beans&amp;gt;
如果是动态Action FormBean，还必须配置form-bean元素的form-property子元素。它包含四个属性，上面三个，还有一个initial 元素：以字符串的形式设置表单字段的初始值，如果没有设置该属性，则是基本类型为0，如果是对象则为null。可有可无。如下所示：
&amp;lt;form-beans&amp;gt;
&amp;lt;form-bean
name=&quot;Loign&quot;
type=&quot;com.ha.login&quot;&amp;gt;
&amp;lt;form-property name=&quot;ok&quot;  type=&quot;java.lang.String&quot;/&amp;gt;
&amp;lt;form-property name=&quot;oks&quot;  type=&quot;java.lang.String&quot;/&amp;gt;
&amp;lt;form-property name=&quot;okss&quot;  type=&quot;java.lang.Integer&quot; initial=&quot;20&quot;/&amp;gt;
&amp;lt;/form-bean&amp;gt;
&amp;lt;/form-beans&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt; 3. global-exceptions元素&lt;/span&gt;&lt;/strong&gt;
该元素主要配置异常处理，它的exception子元素代表全局的异常配置。struts采取配置的方式来处理异常。它用来设置java异常和异常处理 类org.apache.struts.action.ExceptionHandler之间的映射。它有七个属性，如下所示：
1. className：指定和exception元素对应的配置类，默认为：org.apache.struts.config.ExceptionConfig。可有可无。
2. Handler：指定异常得理类，默认为：org.apache.struts.action.ExceptionHandler。可有可无
3. key：指定在Resource Bundle中描述该异常的消息key
4. path：指定当异常发生时的转发路径。
5. scope：指定ActionMessages实例的存放范围，可选值包括：request和session，默认为request。可有可无。
6. type：指定所需处理异常类的名字，必须。
7. bundle：指定Resource Bundle
如下所示：
&amp;lt;global-exceptions&amp;gt;
&amp;lt;exception
key=&quot;global.error.invalidlogin&quot;
path=&quot;/error.jsp&quot;
scope=&quot;request&quot;
type=&quot;com.hn.tree&quot;
/&amp;gt;
&amp;lt;/global-exceptions&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt; 4. global-forwards元素
&lt;/strong&gt;&lt;/span&gt; 该元素主要用来声明全局的转发关系，它具有以下四个属性：
1. className：和forward元素对应的配置类，默认为：org.apache.struts.action.ActionForward。可有可无。
2. contextRelative：此项为true时，表时path属性以＂/＂开头，相对于当前上下文的URL，默认为false．可有可无。
3. name：转发路径的逻辑名．必填。
4. path：转发或重定向的URL，当contextRelative=false时，URL路径相对于当前应用（application），当为ture时，表示URL路径相对于当前上下文（context）。
5.  redirect：当此项为ture时，表示执行重定向操作。当此项为false时表示转向操作。默认为false。
如下所示：
&amp;lt;global-forwards&amp;gt;
&amp;lt;forward  name=&quot;forms1&quot;  path=&quot;/a.do&quot;/&amp;gt;
&amp;lt;forward  name=&quot;forms2&quot;  path=&quot;/nb.jsp&quot;/&amp;gt;
&amp;lt;global-forwards&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt; 5. action-mappings元素&lt;/strong&gt;&lt;/span&gt;
描述从特定的请求路径到相应的Action类的映射。它具有以下几个属性：
1. attribute：设置和Action关联的ActionForm Bean在request和session范围内的key。如：Form Bean存在于request范围内，此项设为“myBenas”，则在request.getAttribute(&quot;myBenas&quot;)就可以返回该 Bean的实例。
2. classsName：和action元素对应的配置元素，默认为：org.apache.struts.action.ActionMapping.
3. forward：转发的URL路径。
4. include：指定包含的URL路径。
5. input：输入表单的URL路径，当表单验证失败时，将把请求转发到该URL。
6. name：指定和Action关联的Action FormBean的名字，该名字必须在Form-Bean定义过。
7. path：指定访问Action的路径，以“/”开头，无扩展名。
8. parameter：指定Actgion的配置参数，在Action类的execute()方法中，可以调用ActionMapping对象的getParameter()方法来读取该配置参数。
9. roles：指定允许调用该Action的安全角色，多个角色之间用，隔开，在处理请求时，RequestProcessor会根据该配置项来决定用户是否有权限调用Action权限。
10. scope：指定ActionForm Bean的存在范围，可选取为request和session，默认为session。
11. type：指定Action类的完整类名。
12. unknown：如果此项为true，表示可以处理用户发出的所有无效的Action URL，默认为false；
13. validate：指定是否要调用Action FormBean的validate方法，默认值为ture.
注：forward、include、type属性只能选中其中一项。
如下：
&amp;lt;action path=&quot;/search&quot;
type=&quot;zxj.okBean&quot;
name=&quot;a1&quot;
scope=&quot;request&quot;
validate=&quot;true&quot;
input=&quot;/b.jsp&quot;&amp;gt;
&amp;lt;forward name=&quot;tig&quot; path=&quot;/aa.jsp&quot;/&amp;gt;
&amp;lt;/action&amp;gt;
注：此中的forward是指局部的转发路径。global-forwards表示全局的转发路径。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt; 6. controller元素
&lt;/strong&gt;&lt;/span&gt; 该元素用于配置ActionServlet。它具有以下属性。
1. bufferSize：指定上载文件的输入缓冲大小，可选，默认为4096
2. className：指定和controller元素对应的配置类，默认为org.apache.struts.config.ControllerConfig
3. conentType：字符编码，如果在Action和JSP网页中设置了，则覆盖该设置。
4. locale：指定是否把Locale对象保存到当前用户的session中，默认值为false.
5. processorClass：指定负责请求的java类完整路径。
6. tempDir：指定处理文件的临时工作目录，如果此项没有设置，将采用Servlet容器为web应用分配的临时工作目录。
7. nochache：如果为true：在响应结果中将加入特定的头参数：Pragma,Cache-Control和Expise，防止页面被保存在客户端的浏览器中，默认为false
如下：
&amp;lt;controller
contentType=&quot;text/html;charset=&quot;UTF-8&quot;&quot;
locale=&quot;true&quot;
processorClass=&quot;con.ok&quot;/&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt; 7. message-resources元素&lt;/strong&gt;&lt;/span&gt;
主要配置本地化消息文本，它具有以下属性。
1. className：和message-resources元素对应的配置类，默认为org.apache.struts.config.MessageResourcesConfig。
2. factory：指定消息资源的工厂类，默认为：org.apache.struts.util.PropertyMessageResourcesFactory类
3. key：指定Resource Bundle存放的ServletContext对象中时采用的属性Key，默认由Globals.MESSAGES_KEY定义的字符串常量，只允许一个Resource Bundle采用默认的属性Key。
4. null：指定MessageSources类如何处理未知消息的key，如果为true，则返回空字符串，如果为false，则返回相关字串，默认为false
5. prameter：指定MessageSources的资源文件名，如果为：a.b.ApplicationResources，则实际对应的文件路径 为：WEB-INF/classes/a/b/ApplicationResources.properties.
如：
&amp;lt;message-resources null=&quot;false&quot; parameter=&quot;defaultResource&quot;/&amp;gt;
&amp;lt;message-resources key=&quot;num1&quot; null=&quot;false&quot; parameter=&quot;test&quot;/&amp;gt;
访问为：
&amp;lt;bean:message  key=&quot;zxj&quot;/&amp;gt;
&amp;lt;bean:message  key=&quot;zxj&quot;  bundle=&quot;num1&quot;/&amp;gt;
其中，zxj表法，messagesource资源文件中的一个字符串。&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color: #ff0000;&quot;&gt;&lt;strong&gt; 8. plugin-in元素&lt;/strong&gt;&lt;/span&gt;
配置Struts的插件，属性如下：
1. className：指定的Struts插件类，必须实现org.apache.struts.action.PlugiIn接口。如：
&amp;lt;plug-in
className=&quot;a.b.c.&quot;&amp;gt;
&amp;lt;set-property property=&quot;xxx&quot; value=&quot;/WEB-INF/aa.xml&quot;  /&amp;gt;
&amp;lt;/plug-in&amp;gt;&lt;/p&gt;

&lt;p&gt;后记，多模块的配置，可以供多个应用应用不同的struts-config.xml&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>【090711更新】SSH常见问题及解决办法</title>
   <link href="http://dreambt.github.com/J2EE/2009/07/11/ssh"/>
   <updated>2009-07-11T16:21:13+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2009/07/11/ssh</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;内容检索&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.警告: No configuration found for the specified action:&lt;span style=&quot;color: #ffffff;&quot;&gt;&lt;span style=&quot;background-color: #800000;&quot;&gt;'/myNameSpace/login.action' in namespace: ''&lt;/span&gt;&lt;/span&gt;. Form action defaulting to 'action' attribute's literal value.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.关于s标签的错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.导入struts-default.xml的错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.Cannot locate the chosen ObjectFactory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;-----------------------------------------------分割线--------------------------------------------------------&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.出错信息：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;警告: No configuration found for the specified action:&lt;span style=&quot;color: #ffffff;&quot;&gt;&lt;span style=&quot;background-color: #800000;&quot;&gt;'/myNameSpace/login.action' in namespace: ''&lt;/span&gt;&lt;/span&gt;. Form action defaulting to 'action' attribute's literal value.&lt;/p&gt;

&lt;p&gt;今天花了点时间把struts2警告事件彻底的测试了一边，终于有点眉目了。希望能给其他人带来一点帮助。
警告信息：&lt;/p&gt;

&lt;p&gt;警告: No configuration found for the specified action: '/myNameSpace/login.action' in namespace: ''. Form action defaulting to 'action' attribute's literal value.&lt;/p&gt;

&lt;p&gt;struts.xml配置信息（部分）&lt;/p&gt;

&lt;p&gt;[java]
&amp;lt;package name=&quot;packageName&quot; extends=&quot;struts-default&quot; namespace=&quot;/myNameSpace&quot;&amp;gt;
&amp;lt;action name=&quot;login&quot; class=&quot;com.jato.srvclink.test.login.LoginAction&quot; method=&quot;login&quot;&amp;gt;
[/java]&lt;/p&gt;

&lt;p&gt;jsp页面配置信息（部分）&lt;/p&gt;

&lt;p&gt;[java]
&amp;lt;s:form action=&quot;/myNameSpace/login.action&quot;&amp;gt;
[/java]&lt;/p&gt;

&lt;p&gt;思考：没有在''的namespace中发现指定的action '/myNameSpace/login.action'&lt;/p&gt;

&lt;p&gt;答疑：因为配置的struts2标签并未指定namespace属性。所以struts2会默认从根命名空间&quot;/&quot;搜索action串'/myNameSpace/login.action'，如果搜索不到将进入默认命名空间''搜索action请求串，在默认命名空间中是肯定找不到我们定义的action的，所以，struts2抛出一个警告信息。&lt;/p&gt;

&lt;p&gt;但是为什么我们没有填写namespace，我们的请求也可以正常访问呢？&lt;/p&gt;

&lt;p&gt;我们来看一下解析后的html&lt;/p&gt;

&lt;p&gt;查看源码得到的html（部分）&lt;/p&gt;

&lt;p&gt;[html]&amp;lt;form id=&quot;login&quot; onsubmit=&quot;return true;&quot; action=&quot;/srvclink/myNameSpace/login.action&quot; method=&quot;post&quot;&amp;gt;[/html]&lt;/p&gt;

&lt;p&gt;我们看到form提交的action串是准确的url请求，action串确实是/srvclin（应用根）/myNameSpace（命名空间）/login.action。&lt;/p&gt;

&lt;p&gt;命名空间中找不到action定义，并不意味着这个action真的不存在，只是我们的代码有问题而已。还有一点是我们在jsp页面的action请求中手动的加入了.action后缀。事实上struts2会自动追加.action的，因为我们并没有合法的使用struts2的标签，所以struts2这里并没有给我们追加.action，解析后的代码中存在的.action，完全是我们手动在jsp页面填写的，有疑问的网友可以不手动添加查看html。&lt;/p&gt;

&lt;p&gt;我们修改我们的程序代码&lt;/p&gt;

&lt;p&gt;jsp页面配置信息（部分）修改后加入namespace属性，修改action属性值为/login.action&lt;/p&gt;

&lt;p&gt;[java]&amp;lt;s:form action=&quot;/login.action&quot; namespace=&quot;/myNameSpace&quot;&amp;gt;[/java]&lt;/p&gt;

&lt;p&gt;请求页面后，大家很失望吧？警告依然存在。但是我们看一下警告信息。&lt;/p&gt;

&lt;p&gt;警告信息：&lt;/p&gt;

&lt;p&gt;警告: No configuration found for the specified action: '/login.action' in namespace: '/myNameSpace'. Form action defaulting to 'action' attribute's literal value.&lt;/p&gt;

&lt;p&gt;没有在'/myNameSpace'的namespace中发现指定的action '/login.action'&lt;/p&gt;

&lt;p&gt;毫无疑问，这里的警告和第一次的警告信息截然不同。我们现在存在命名空间，'/myNameSpace'能够被struts2检索到，并不是开始的''。那问题的关键在哪里呢？&lt;/p&gt;

&lt;p&gt;在namespace中没有发现指定的action '/login.action' ？？？&lt;/p&gt;

&lt;p&gt;我们来看一下struts.xml中的配置：&lt;/p&gt;

&lt;p&gt;struts.xml配置信息（部分）&lt;/p&gt;

&lt;p&gt;[java]
&amp;lt;package name=&quot;packageName&quot; extends=&quot;struts-default&quot; namespace=&quot;/myNameSpace&quot;&amp;gt;
&amp;lt;action name=&quot;login&quot; class=&quot;com.jato.srvclink.test.login.LoginAction&quot; method=&quot;login&quot;&amp;gt;
[/java]&lt;/p&gt;

&lt;p&gt;是的，我们'/myNameSpace'命名空间下，只有action名字为'login'的定义，并没有所谓的 '/login.action' 定义，所以struts2的警告并未错。如果大家对这个抱有怀疑，可以修改action的名字'login'为‘/longin.action’&lt;/p&gt;

&lt;p&gt;[java]&amp;lt;action name=&quot;/login.action&quot; class=&quot;com.jato.srvclink.test.login.LoginAction&quot; method=&quot;login&quot;&amp;gt;[/java]&lt;/p&gt;

&lt;p&gt;请求页面时你会发现不在报警告信息，原因很简单。因为在命名空间为'myNameSpace'下确实存在命名为'/login.action'的action。&lt;/p&gt;

&lt;p&gt;我们再次修改配置文件&lt;/p&gt;

&lt;p&gt;jsp页面配置信息（部分）修改后action属性值为longin&lt;/p&gt;

&lt;p&gt;[java]&amp;lt;s:form action=&quot;login&quot; namespace=&quot;/myNameSpace&quot;&amp;gt;[/java]&lt;/p&gt;

&lt;p&gt;请求页面时，我们发现不再有警告信息了。&lt;/p&gt;

&lt;p&gt;如果你有足够细心，我想你应该可以彻底的明白为什么struts2会报警了吧？你也应该明白了使用struts2标签action中添加/线后请求反而报错的原因了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.关于s标签的错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;JSP页面&lt;/p&gt;

&lt;p&gt;[html]
&amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot; %&amp;gt;
&amp;lt;%@ taglib prefix=&quot;s&quot; uri=&quot;/struts-tags&quot; %&amp;gt;
&amp;lt;s:form action=&quot;&amp;lt;%=url%&amp;gt;/login&quot; method=&quot;post&quot;&amp;gt;
&amp;lt;s:textfield name=&quot;user.username&quot; label=&quot;username&quot; /&amp;gt;
&amp;lt;s:textfield name=&quot;user.password&quot; label=&quot;password&quot; /&amp;gt;
&amp;lt;s:submit value=&quot;submit&quot; /&amp;gt;
&amp;lt;/s:form&amp;gt;
&amp;lt;/div&amp;gt;
[/html]&lt;/p&gt;

&lt;p&gt;错误信息
[java]
严重: Servlet.service() for servlet jsp threw exception
org.apache.jasper.JasperException: /index.jsp(15,23) attribute for %&amp;amp;gt;&quot; is not properly terminated
at org.apache.jasper.compiler.DefaultErrorHandler.jspError(DefaultErrorHandler.java:39)
at org.apache.jasper.compiler.ErrorDispatcher.dispatch(ErrorDispatcher.java:405)
at org.apache.jasper.compiler.ErrorDispatcher.jspError(ErrorDispatcher.java:130)
at org.apache.jasper.compiler.Parser.parseAttributeValue(Parser.java:241)
at org.apache.jasper.compiler.Parser.parseAttribute(Parser.java:205)
at org.apache.jasper.compiler.Parser.parseAttributes(Parser.java:143)
at org.apache.jasper.compiler.Parser.parseCustomTag(Parser.java:1328)
at org.apache.jasper.compiler.Parser.parseElements(Parser.java:1560)
at org.apache.jasper.compiler.Parser.parse(Parser.java:126)
at org.apache.jasper.compiler.ParserController.doParse(ParserController.java:211)
at org.apache.jasper.compiler.ParserController.parse(ParserController.java:100)
at org.apache.jasper.compiler.Compiler.generateJava(Compiler.java:146)
at org.apache.jasper.compiler.Compiler.compile(Compiler.java:286)
at org.apache.jasper.compiler.Compiler.compile(Compiler.java:267)
at org.apache.jasper.compiler.Compiler.compile(Compiler.java:255)
at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:556)
at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:296)
at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:295)
at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:245)
at javax.servlet.http.HttpServlet.service(HttpServlet.java:802)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:237)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:157)
at org.apache.struts2.dispatcher.FilterDispatcher.doFilter(FilterDispatcher.java:416)
at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:186)
at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:157)
at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:214)
at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:178)
at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:126)
at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:105)
at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:107)
at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:148)
at org.apache.coyote.http11.Http11Processor.process(Http11Processor.java:825)
at org.apache.coyote.http11.Http11Protocol$Http11ConnectionHandler.processConnection(Http11Protocol.java:731)
at org.apache.tomcat.util.net.PoolTcpEndpoint.processSocket(PoolTcpEndpoint.java:526)
at org.apache.tomcat.util.net.LeaderFollowerWorkerThread.runIt(LeaderFollowerWorkerThread.java:80)
at org.apache.tomcat.util.threads.ThreadPool$ControlRunnable.run(ThreadPool.java:684)
at java.lang.Thread.run(Thread.java:595)
[/java]&lt;/p&gt;

&lt;p&gt;s标签不支持&amp;lt;=%%&amp;gt;,所以要用下面的代码：&lt;/p&gt;

&lt;p&gt;JSP代码
[java]&amp;lt;s:form action=&quot;${url}/login&quot; method=&quot;post&quot; &amp;gt;[/java]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.导入struts-default.xml的错误&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;错误信息
[java]
严重: Exception starting filter Struts2
Caught exception while loading file struts-default.xml - [unknown location]
at com.opensymphony.xwork2.config.providers.XmlConfigurationProvider.loadConfigurationFiles(XmlConfigurationProvider.java:839)
at com.opensymphony.xwork2.config.providers.XmlConfigurationProvider.loadDocuments(XmlConfigurationProvider.java:131)
at com.opensymphony.xwork2.config.providers.XmlConfigurationProvider.init(XmlConfigurationProvider.java:100)
at com.opensymphony.xwork2.config.impl.DefaultConfiguration.reload(DefaultConfiguration.java:130)
at com.opensymphony.xwork2.config.ConfigurationManager.getConfiguration(ConfigurationManager.java:52)
at org.apache.struts2.dispatcher.Dispatcher.init_PreloadConfiguration(Dispatcher.java:395)
at org.apache.struts2.dispatcher.Dispatcher.init(Dispatcher.java:452)
at org.apache.struts2.dispatcher.FilterDispatcher.init(FilterDispatcher.java:201)
at org.apache.catalina.core.ApplicationFilterConfig.getFilter(ApplicationFilterConfig.java:275)
at org.apache.catalina.core.ApplicationFilterConfig.setFilterDef(ApplicationFilterConfig.java:397)
at org.apache.catalina.core.ApplicationFilterConfig.&amp;lt;init&amp;gt;(ApplicationFilterConfig.java:108)
at org.apache.catalina.core.StandardContext.filterStart(StandardContext.java:3696)
at org.apache.catalina.core.StandardContext.start(StandardContext.java:4343)
at org.apache.catalina.core.StandardContext.reload(StandardContext.java:3086)
at org.apache.catalina.loader.WebappLoader.backgroundProcess(WebappLoader.java:404)
at org.apache.catalina.core.ContainerBase.backgroundProcess(ContainerBase.java:1309)
at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1601)
at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)
at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.processChildren(ContainerBase.java:1610)
at org.apache.catalina.core.ContainerBase$ContainerBackgroundProcessor.run(ContainerBase.java:1590)
at java.lang.Thread.run(Thread.java:619)
Caused by: java.lang.ClassCastException: org.apache.xerces.parsers.XML11Configuration cannot be cast to org.apache.xerces.xni.parser.XMLParserConfiguration
at org.apache.xerces.parsers.DOMParser.&amp;lt;init&amp;gt;(Unknown Source)
at org.apache.xerces.parsers.DOMParser.&amp;lt;init&amp;gt;(Unknown Source)
at org.apache.xerces.jaxp.DocumentBuilderImpl.&amp;lt;init&amp;gt;(Unknown Source)
at org.apache.xerces.jaxp.DocumentBuilderFactoryImpl.newDocumentBuilder(Unknown Source)
at com.sun.org.apache.xalan.internal.xsltc.trax.SAX2DOM.&amp;lt;init&amp;gt;(SAX2DOM.java:69)
at com.sun.org.apache.xalan.internal.xsltc.runtime.output.TransletOutputHandlerFactory.getSerializationHandler(TransletOutputHandlerFactory.java:187)
at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerImpl.getOutputHandler(TransformerImpl.java:392)
at com.sun.org.apache.xalan.internal.xsltc.trax.TransformerHandlerImpl.setResult(TransformerHandlerImpl.java:137)
at com.opensymphony.xwork2.util.DomHelper$DOMBuilder.setup(DomHelper.java:213)
at com.opensymphony.xwork2.util.DomHelper$DOMBuilder.&amp;lt;init&amp;gt;(DomHelper.java:198)
at com.opensymphony.xwork2.util.DomHelper$DOMBuilder.&amp;lt;init&amp;gt;(DomHelper.java:189)
at com.opensymphony.xwork2.util.DomHelper$DOMBuilder.&amp;lt;init&amp;gt;(DomHelper.java:175)
at com.opensymphony.xwork2.util.DomHelper.parse(DomHelper.java:115)
at com.opensymphony.xwork2.config.providers.XmlConfigurationProvider.loadConfigurationFiles(XmlConfigurationProvider.java:830)
... 20 more
[/java]&lt;/p&gt;

&lt;p&gt;解决方法:
移除项目目录中的xerces.jar
there was a conflict between tomcat's internal XML parser and the xerces I was using inside my project.
参考链接:&lt;a href=&quot;http://www.nabble.com/org.apache.xerces.parsers.XML11Configuration-cannot-be-cast-to-org.apache.xerces.xni.parser.XMLParserConfiguration-td14108368.html&quot; target=&quot;_blank&quot;&gt;http://www.nabble.com/org.apache.xerces.parsers.XML11Configuration-cannot-be-cast-to-org.apache.xerces.xni.parser.XMLParserConfiguration-td14108368.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.Cannot locate the chosen ObjectFactory&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;错误信息
Cannot locate the chosen ObjectFactory implementation: spring - [unknown location]&lt;/p&gt;

&lt;p&gt;解决办法一：
添加struts2-spring-plugin-XXXX.jar&lt;/p&gt;

&lt;p&gt;解决办法二：
在struts.properties里把struts.objectFactory=spring改成struts.objectFactory=com.opensymphony.xwork2.ObjectFactory就可以了.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring的applicationContext.xml文件</title>
   <link href="http://dreambt.github.com/J2EE/2009/06/01/spring-applicationcontext-xml"/>
   <updated>2009-06-01T20:13:26+08:00</updated>
   <id>http://dreambt.github.com/J2EE/2009/06/01/spring-applicationcontext-xml</id>
   <content type="html">&lt;p&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;以下是详解Spring的applicationContext.xml文件代码：
&lt;/span&gt;&lt;span style=&quot;color: #ff00ff;&quot;&gt;&amp;lt;!-- 头文件，主要注意一下编码 --&amp;gt;&lt;/span&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE beans PUBLIC &quot;-//SPRING//DTD BEAN//EN&quot; &quot;http://www.springframework.org/dtd/spring-beans.dtd&quot;&amp;gt;
&amp;lt;beans&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 建立数据源 --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;
&lt;/span&gt; &amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 数据库驱动，我这里使用的是Mysql数据库 --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;
&lt;/span&gt; &amp;lt;property name=&quot;driverClassName&quot;&amp;gt;
&amp;lt;value&amp;gt;com.mysql.jdbc.Driver&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 数据库地址，这里也要注意一下编码，不然乱码可是很郁闷的哦！ --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #ffff00;&quot;&gt;
&lt;/span&gt; &amp;lt;property name=&quot;url&quot;&amp;gt;
&amp;lt;value&amp;gt;
jdbc:mysql://localhost:3306/tie?useUnicode=true&amp;amp;amp;characterEncoding=utf-8
&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 数据库的用户名 --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;
&lt;/span&gt; &amp;lt;property name=&quot;username&quot;&amp;gt;
&amp;lt;value&amp;gt;root&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 数据库的密码 --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;
&lt;/span&gt; &amp;lt;property name=&quot;password&quot;&amp;gt;
&amp;lt;value&amp;gt;123&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 把数据源注入给Session工厂 --&amp;gt;&lt;/span&gt;
&amp;lt;bean id=&quot;sessionFactory&quot;
class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&amp;gt;
&amp;lt;property name=&quot;dataSource&quot;&amp;gt;
&amp;lt;ref bean=&quot;dataSource&quot; /&amp;gt;
&amp;lt;/property&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 配置映射文件 --&amp;gt;&lt;/span&gt;
&amp;lt;property name=&quot;mappingResources&quot;&amp;gt;
&amp;lt;list&amp;gt;
&amp;lt;value&amp;gt;com/alonely/vo/User.hbm.xml&amp;lt;/value&amp;gt;
&amp;lt;/list&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 把Session工厂注入给hibernateTemplate --&amp;gt;
&amp;lt;!-- 解释一下hibernateTemplate：hibernateTemplate提供了很多方便的方法，在执行时自动建立 HibernateCallback 对象，例如：load()、get()、save、delete()等方法。 --&amp;gt;&lt;/span&gt;
&amp;lt;bean id=&quot;hibernateTemplate&quot;
class=&quot;org.springframework.orm.hibernate3.HibernateTemplate&quot;&amp;gt;
&amp;lt;constructor-arg&amp;gt;
&amp;lt;ref local=&quot;sessionFactory&quot; /&amp;gt;
&amp;lt;/constructor-arg&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 把DAO注入给Session工厂 --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #ffff00;&quot;&gt;
&lt;/span&gt; &amp;lt;bean id=&quot;userDAO&quot; class=&quot;com.alonely.dao.UserDAO&quot;&amp;gt;
&amp;lt;property name=&quot;sessionFactory&quot;&amp;gt;
&amp;lt;ref bean=&quot;sessionFactory&quot; /&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 把Service注入给DAO --&amp;gt;&lt;/span&gt;&lt;span style=&quot;color: #0000ff;&quot;&gt;
&lt;/span&gt; &amp;lt;bean id=&quot;userService&quot; class=&quot;com.alonely.service.UserService&quot;&amp;gt;
&amp;lt;property name=&quot;userDAO&quot;&amp;gt;
&amp;lt;ref local=&quot;userDAO&quot; /&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;span style=&quot;color: #ff00ff;&quot;&gt; &amp;lt;!-- 把Action注入给Service --&amp;gt;&lt;/span&gt;
&amp;lt;bean name=&quot;/user&quot; class=&quot;com.alonely.struts.action.UserAction&quot;&amp;gt;
&amp;lt;property name=&quot;userService&quot;&amp;gt;
&amp;lt;ref bean=&quot;userService&quot; /&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Speed Up YUM！让Linux的升级速度快如飞</title>
   <link href="http://dreambt.github.com/Linux/2009/05/16/linux-speed-up-yum"/>
   <updated>2009-05-16T06:46:01+08:00</updated>
   <id>http://dreambt.github.com/Linux/2009/05/16/linux-speed-up-yum</id>
   <content type="html">&lt;p&gt;很多人都觉得Fedora的yum很糟糕——速度慢、依赖解决得不好和容易出问题。&lt;/p&gt;

&lt;p&gt;其实只要我们稍加动手，yum的问题就能迎刃而解。&lt;/p&gt;

&lt;p&gt;yum速度慢？yum speed=yum+fastestmirror+axelget(+presto)&lt;/p&gt;

&lt;p&gt;对于许多人来说，默认的yum速度是很慢的。为什么呢？默认的时候，yum是通过连接到官方的服务器列表，并随机从中选取一个服务器使用的。鉴于中 国大陆的公网是没有Fedora的yum服务器(教育网有yum服务器，但是同步比较迟。），因此速度想提高都很难。所以只能另辟路径为yum提速。
安装yum-fastestmirror插件，从服务器列表中选取最快的服务器。这个办法通常都很有效，能够选取到最快的服务器，从而实现提速。先在终端把用户切换到root，然后输入命令：&lt;/p&gt;

&lt;blockquote&gt;yum install yum-fastestmirror&lt;/blockquote&gt;


&lt;p&gt;稍等片刻即可安装完成，或者在“Add/Remove Software”点击安装皆可。&lt;/p&gt;

&lt;p&gt;但是fastestmirror选取的服务器未必是最快的，因为fastestmirror插件是通过测定ping延时最短来计算哪个服务器最快， 实际上这种方法可能会选取到ping延时很低但是速度并不是很高的服务器。所以我们还有另外的一个办法，就是yum-axelget插件。&lt;/p&gt;

&lt;p&gt;默认的yum是单线程下载的。yum-axelget插件是调用系统中的axel下载软件，增加下载线程从而提高速度。这个方法更有效，更快捷，而 且会根据软件包的大小自动设定线程数，基本避免了因为线程数过多而导致服务器拒绝下载的问题。点击打开终端，把用户切换到root，然后输入命令：&lt;/p&gt;

&lt;blockquote&gt;rpm -ivh &lt;a href=&quot;http://rpm4fc-cn.googlecode.com/files/axel-2.3-1.fc10.i386.rpm&quot; target=&quot;_blank&quot;&gt;http://rpm4fc-cn.googlecode.com/files/axel-2.3-1.fc10.i386.rpm&lt;/a&gt; &lt;a href=&quot;http://rpm4fc-cn.googlecode.com/files/yum-axelget-1.0-0.2.20080705.fc10.noarch.rpm&quot; target=&quot;_blank&quot;&gt;http://rpm4fc-cn.googlecode.com/files/yum-axelget-1.0-0.2.20080705.fc10.noarch.rpm&lt;/a&gt;&lt;/blockquote&gt;


&lt;p style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/attachments/month_0905/p2009517132319.png&quot; border=&quot;0&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;265&quot; align=&quot;middle&quot; /&gt;&lt;/p&gt;


&lt;p&gt;稍等片刻即可，因为这不是Fedora官方的插件，所以无法在“Add/Remove Software”安装。&lt;/p&gt;

&lt;p&gt;如果是这样的速度还不能令你满足，怎么办？yum-presto插件还可以进一步提速……presto插件会大幅度提升更新安装包的速度。用户只需 要下载每一个软件的增量内容(用drpm打包而成)，在本地计算机重新生成一个完整的软件包再安装。通常增量更新只有很小的下载量，因而即使很大量的内容 要更新，所耗费的时间必然比传统方法要少很多。不过presto系统还在测试之中，而且只有一个服务器提供presto更新，速度也不怎么样。目前 presto只提供Fedora 9、Fedora 10和Fedora Rawhide三个版本的更新。建议有兴趣的朋友可以参考这里：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hosted.fedoraproject.org/presto/&quot; target=&quot;_blank&quot;&gt;https://hosted.fedoraproject.org/presto/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装yum-presto插件：&lt;/p&gt;

&lt;blockquote&gt;yum install yum-presto&lt;/blockquote&gt;


&lt;p&gt;yum的依赖问题由来已久，当然是有设计上的问题，但是也是有Packager的问题，没有及时把要更新的相关依赖移动到updates的软件库里面去(或许是Packager认为该软件包不够稳定吧！)，所以才会造成这样的问题。&lt;/p&gt;

&lt;p&gt;解决的方法有两种：&lt;/p&gt;

&lt;p&gt;一、如果不是很重大的更新，稍等几天，等Packager把全部软件包从updates-testing移动到updates里去，然后再去更新。&lt;/p&gt;

&lt;p&gt;二、在更新或者安装软件包的时候，直接启用updates-testing软件库，虽然是testing，但是软件包还是比较稳定的，所以启用了问题也不会很大。当然是关键的软件包还是要小心为上！呵呵！在终端切换到root用户，然后输入命令：&lt;/p&gt;

&lt;blockquote&gt;yum update --enablerepo=updates-testing
yum install xxx --enablerepo=updates-testing //xxx是软件包的名字&lt;/blockquote&gt;


&lt;p&gt;这样，问题就能迎刃而解了。&lt;/p&gt;

&lt;p&gt;yum更新出了问题下载不了软件包怎么办？轻按键盘的Ctrl+C一下(两下会直接取消当前运行任务)，即可跳过当前正在下载的软件包，把下面的软 件包先下载，到最后才把先前没有下载的软件包再下载。安装软件的时候被迫退出当前人物或者误关闭终端怎么办？不怕！yum是支持断点续传的，只要重复上一 条命令即可从停止处开始下载，而不是重新开始下载！&lt;/p&gt;

&lt;p&gt;结语：对于Fedora熟手来说，直接指定一个速度快的服务器用作更新和安装软件是最适合不过的。但是对于新手来说，修改yum的配置文件不是一件容易的事情。因此我仅希望通过这篇文章来帮助Fedora新手，吸引更多的人来使用Fedora和参与Fedora项目。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Linux操作系统文件系统基础知识详解</title>
   <link href="http://dreambt.github.com/Linux/2009/05/02/linux-os-file-system"/>
   <updated>2009-05-02T07:54:02+08:00</updated>
   <id>http://dreambt.github.com/Linux/2009/05/02/linux-os-file-system</id>
   <content type="html">&lt;p&gt;&lt;a name=&quot;ch1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上。
目录提供了管理文件的一个方便而有效的途径。
Linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。
/根目录
┃
┏━━━━┳━━━━━┳━━━━━┳━━━━━╋━━━━━┳━━━━━┳━━━━━┳━━━━━┓
┃       ┃          ┃         ┃          ┃         ┃         ┃          ┃         ┃
bin    home      dev       etc        lib      sbin       tmp       usr       var
┃
┏━┻━┓
┃      ┃
rc.d   cron.d
┃
┏━━━┳━━━┳━┻━┳━━━━┓
┃      ┃     ┃      ┃       ┃
init.d  rc0.d rc1.d  rc2.d    ……
┃                                                      ┃
┏━┻━┓         ┏━━┳━━┳━━┳━┻━┳━━┓
┃          ┃       ┃       ┃       ┃     ┃          ┃     ┃
rc.d    cron.d     X11R6 src    lib     local      man     bin
┃
┏━━━┳━━┳━┻━┳━━━┓
┃         ┃       ┃          ┃         ┃
init.d   rc0.d    rc1.d rc2.d …… linux bin lib src&lt;/p&gt;

&lt;p&gt;Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。微软的DOS和windows也是采用树型结构，但是在 DOS和 windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。
下面列出了linux下一些主要目录的功用。&lt;/p&gt;

&lt;p&gt;/bin        二进制可执行命令
/boot        开机设定目录，也是摆放核心 vmlinuz 的地方
/dev        设备特殊文件
/etc        系统管理和配置文件,尤其 passwd, shadow
/etc/rc.d    启动的配置文件和脚本
/etc/rc.d/init.d系統开机的時候载入服务的 scripts 的摆放地点
/etc/passwd     用户数据库，其中的域给出了用户名、真实姓名、家目录、加密的口令和用户的其他信息。
/etc/fdprm      软盘参数表。说明不同的软盘格式。用setfdprm 设置。
/etc/fstab     启动时mount -a命令(在/etc/rc 或等效的启动文件中)自动mount的文件系统列表。 Linux下，也包括用swapon -a启用的swap区的信息。
/etc/group     类似/etc/passwd ，但说明的不是用户而是组。
/etc/inittab     init 的配置文件。
/etc/issue     getty 在登录提示符前的输出信息。通常包括系统的一段短说明或欢迎信息。内容由系统管理员确定。
/etc/magic     file 的配置文件。包含不同文件格式的说明，file 基于它猜测文件类型。
/etc/motd     Message Of The Day，成功登录后自动输出。内容由系统管理员确定。经常用于通告信息，如计划关机时间的警告。
/etc/mtab     当前安装的文件系统列表。由scripts初始化，并由mount 命令自动更新。需要一个当前安装的文件系统的列表时使用，例如df 命令。
/etc/shadow     在安装了影子口令软件的系统上的影子口令文件。影子口令文件将/etc/passwd 文件中的加密口令移动到/etc/shadow 中，而后者只对root可读。这使破译口令更困难。
/etc/login.defs login 命令的配置文件。
/etc/printcap     类似/etc/termcap ，但针对打印机。语法不同。
/etc/profile
/etc/csh.login
/etc/csh.cshrc     登录或启动时Bourne或C shells执行的文件。这允许系统管理员为所有用户建立全局缺省环境。
/etc/securetty     确认安全终端，即哪个终端允许root登录。一般只列出虚拟控制台，这样就不可能(至少很困难)通过modem或网络闯入系统并得到超级用户特权。
/etc/shells     列出可信任的shell。chsh 命令允许用户在本文件指定范围内改变登录shell。提供一台机器FTP服务的服务进程ftpd 检查用户shell是否列在 /etc/shells 文件中，如果不是将不允许该用户登录。
/etc/termcap     终端性能数据库。说明不同的终端用什么&quot;转义序列&quot;控制。写程序时不直接输出转义序列(这样只能工作于特定品牌的终端)，而是从/etc/termcap 中查找要做的工作的正确序列。这样，多数的程序可以在多数终端上运行。
/home        用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示
/lib        标准程序设计库，又叫动态链接共享库，作用类似windows里的.dll文件
/sbin        系统管理命令，这里存放的是系统管理员使用的管理程序
/tmp        公用的临时文件存储点
/root        系统管理员的主目录
/mnt        系统提供这个目录是让用户临时挂载其他的文件系统。
/lost+found    摆放系统不正常产生错误时遗失的片段
/proc        虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。它不存在在磁盘某个磁盘上。而是由核心在内存中产生。用于提供关于系统的信息(originally about processes, hence the name)。
/proc/1     关于进程1的信息目录。每个进程在/proc 下有一个名为其进程号的目录。
/proc/cpuinfo    处理器信息，如类型、制造商、型号和性能。
/proc/devices     当前运行的核心配置的设备驱动的列表。
/proc/dma     显示当前使用的DMA通道。
/proc/filesystems 核心配置的文件系统。
/proc/interrupts 显示使用的中断，and how many of each there have been.
/proc/ioports     当前使用的I/O端口。
/proc/kcore    系统物理内存映象。与物理内存大小完全一样，但不实际占用这么多内存；it is generated on the fly as programs access it. (记住：除非你把它拷贝到什么地方，/proc 下没有任何东西占用任何磁盘空间。)
/proc/kmsg     核心输出的消息。也被送到syslog 。
/proc/ksyms     核心符号表。
/proc/loadavg     系统&quot;平均负载&quot;；3个指示器指出系统当前的工作量。
/proc/meminfo     存储器使用信息，包括物理内存和swap。
/proc/modules     当前加载了哪些核心模块。
/proc/net     网络协议状态信息。
/proc/self     到查看/proc 的程序的进程目录的符号连接。当2个进程查看/proc 时，是不同的连接。这主要便于程序得到它自己的进程目录。
/proc/stat     系统的不同状态，such as the number of page faults since the system was booted.
/proc/uptime     系统启动的时间长度。
/proc/version     核心版本。
/var        某些大文件的溢出区，比方说各种服务的日志文件
/usr        最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：
/usr/X11R6    存放X window的目录
/usr/bin    众多的应用程序
/usr/sbin    超级用户的一些管理程序
/usr/doc    linux文档
/usr/include    linux下开发和编译应用程序所需要的头文件
/usr/lib    常用的动态链接库和软件包的配置文件
/usr/man    帮助文档
/usr/src    源代码，linux内核的源代码就放在/usr/src/linux里
/usr/local/bin  本地增加的命令
/usr/local/lib  本地增加的库
/usr/X11R6     X Window系统的所有文件。为简化X的开发和安装，X的文件没有集成到系统中。 X自己在/usr/X11R6 下类似/usr 。
/usr/X386     类似/usr/X11R6 ，但是给X11 Release 5的。
/usr/bin     几乎所有用户命令。有些命令在/bin 或/usr/local/bin 中。
/usr/sbin    根文件系统不必要的系统管理命令，例如多数服务程序。
/usr/man
/usr/info
/usr/doc     手册页、GNU信息文档和各种其他文档文件。
/usr/include     C编程语言的头文件。为了一致性这实际上应该在/usr/lib 下，但传统上支持这个名字。
/usr/lib     程序或子系统的不变的数据文件，包括一些site-wide配置文件。名字lib来源于库(library); 编程的原始库存在/usr/lib 里。
/usr/local     本地安装的软件和其他文件放在这里。
/var        包括系统一般运行时要改变的数据。每个系统是特定的，即不通过网络与其他计算机共享。
/var/catman    当要求格式化时的man页的cache。man页的源文件一般存在/usr/man/man&lt;em&gt;中；有些man页可能有预格式化的版本，存在/usr/man/cat&lt;/em&gt;中。而其他的man页在第一次看时需要格式化，格式化完的版本存在/var/man 中，这样其他人再看相同的页时就无须等待格式化了。(/var/catman 经常被清除，就象清除临时目录一样。)
/var/lib     系统正常运行时要改变的文件。
/var/local     /usr/local 中安装的程序的可变数据(即系统管理员安装的程序)。注意，如果必要，即使本地安装的程序也会使用其他/var 目录，例如/var/lock 。
/var/lock     锁定文件。许多程序遵循在/var/lock 中产生一个锁定文件的约定，以支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件，将不试图使用这个设备或文件。
/var/log    各种程序的Log文件，特别是login (/var/log/wtmp log所有到系统的登录和注销) 和syslog(/var/log/messages 里存储所有核心和系统程序信息。 /var/log 里的文件经常不确定地增长，应该定期清除。
/var/run     保存到下次引导前有效的关于系统的信息文件。例如， /var/run/utmp 包含当前登录的用户的信息。&lt;/p&gt;

&lt;p&gt;/var/spool mail, news, 打印队列和其他队列工作的目录。每个不同的spool在/var/spool 下有自己的子目录，例如，用户的邮箱在/var/spool/mail 中。
/var/tmp     比/tmp 允许的大或需要存在较长时间的临时文件。 (虽然系统管理员可能不允许/var/tmp 有很旧的文件。)&lt;/p&gt;

&lt;p&gt;主要目录
根、/usr 、/var 和 /home
每台机器都有根文件系统，它包含系统引导和使其他文件系统得以mount所必要的文件，根文件系统应该有单用户状态所必须的足够的内容。还应该包括修复损坏系统、恢复备份等的工具。
/usr
文件系统包含所有命令、库、man页和其他一般操作中所需的不改变的文件。 /usr不应该有一般使用中要修改的文件。这样允许此文件系统中的文件通过网络共享，这样可以更有效，因为这样节省了磁盘空间(/usr很容易是数百兆)，且易于管理(当升级应用时，只有主/usr 需要改变，而无须改变每台机器)
即使此文件系统在本地盘上，也可以只读mount，以减少系统崩溃时文件系统的损坏。
/var 文件系统包含会改变的文件，比如spool目录(mail、news、打印机等用的)， log文件、formatted manual pages和暂存文件。传统上/var 的所有东西曾在 /usr 下的某个地方，但这样/usr 就不可能只读安装了。
/home 文件系统包含用户家目录，即系统上的所有实际数据。一个大的/home 可能要分为若干文件系统，需要在/home 下加一级名字，如/home/students 、/home/staff 等。&lt;/p&gt;

&lt;p&gt;在同一分区上，名字/usr/lib/libc.a 和/var/adm/messages 必须能工作，例如将/var下的文件移动到/usr/var ，并将/var 作为/usr/var 的符号连接。&lt;/p&gt;

&lt;p&gt;根文件系统
根文件系统一般应该比较小，因为包括严格的文件和一个小的不经常改变的文件系统不容易损坏。损坏的根文件系统一般意味着除非用特定的方法(例如从软盘)系统无法引导。
根目录一般不含任何文件，除了可能的标准的系统引导映象，通常叫/vmlinuz 。所有其他文件在根文件系统的子目录中。
/bin   引导启动所需的命令或普通用户可能用的命令(可能在引导启动后)。
/sbin   类似/bin ，但不给普通用户使用，虽然如果必要且允许时可以使用。
/etc   特定机器的配置文件。
/root   root用户的家目录。
/lib   根文件系统上的程序所需的共享库。
/lib/modules 核心可加载模块，特别是那些恢复损坏系统时引导所需的(例如网络和文件系统驱动)。
/dev 设备文件。
/tmp 临时文件。引导启动后运行的程序应该使用/var/tmp ，而不是/tmp ，因为前者可能在一个拥有更多空间的磁盘上。
/boot 引导加载器(bootstraploader)使用的文件，如LILO。核心映象也经常在这里，而不是在根目录。如果有许多核心映象，这个目录可能变得很大，这时可能使用单独的文件系统更好。另一个理由是要确保核心映象必须在IDE硬盘的前1024柱面内。
/mnt 系统管理员临时mount的安装点。程序并不自动支持安装到/mnt 。 /mnt 可以分为子目录(例如/mnt/dosa 可能是使用MSDOS文件系统的软驱，而/mnt/exta 可能是使用ext2文件系统的软驱)。
/dev目录 /dev 目录包括所有设备的设备文件。设备文件用特定的约定命名。
/usr
文件系统 /usr 文件系统经常很大，因为所有程序安装在这里。 /usr 里的所有文件一般来自Linux
distribution；本地安装的程序和其他东西在/usr/local
下。这样可能在升级新版系统或新distribution时无须重新安装全部程序。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;ch2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。
Llinux文件系统使用索引节点来记录文件信息，作用像windows的文件分配表。
索引节点是一个结构，它包含了一个文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。一个文件系统维护了一个索引节点的数组，每个文件或目录都与索引节点数组中的唯一一个元素对应。系统给每个索引节点分配了一个号码，也就是该节点在数组中的索引号，称为索引节点号。
linux文件系统将文件索引节点号和文件名同时保存在目录中。所以，目录只是将文件的名称和它的索引节点号结合在一起的一张表，目录中每一对文件名称和索引节点号称为一个连接。
对于一个文件来说有唯一的索引节点号与之对应，对于一个索引节点号，却可以有多个文件名与之对应。因此，在磁盘上的同一个文件可以通过不同的路径去访问它。
可以用ln命令对一个已经存在的文件再建立一个新的连接，而不复制文件的内容。连接有软连接和硬连接之分，软连接又叫符号连接。它们各自的特点是：
硬连接：原文件名和连接文件名都指向相同的物理地址。
目录不能有硬连接；硬连接不能跨越文件系统（不能跨越不同的分区）
文件在磁盘中只有一个拷贝，节省硬盘空间；
由于删除文件要在同一个索引节点属于唯一的连接时才能成功，因此可以防止不必要的误删除。
符号连接：用ln -s命令建立文件的符号连接符号连接是linux特殊文件的一种，作为一个文件，它的数据是它所连接的文件的路径名。类似windows下的快捷方式。
可以删除原有的文件而保存连接文件，没有防止误删除功能。
这一段的的内容过于抽象，又是节点又是数组的，我已经尽量通俗再通俗了，又不好加例子作演示。大家如果还是云里雾里的话，我也没有什么办法了，只有先记住，日后在实际应用中慢慢体会、理解了。这也是我学习的一个方法吧。
&lt;a name=&quot;ch3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;由上一节知道，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。这里所说的“按一定方式”就是指的挂载。
将一个文件系统的顶层目录挂到另一个文件系统的子目录上，使它们成为一个整体，称为挂载。把该子目录称为挂载点。
举个例子吧：
根分区：
/根目录
┃
┏━━━━┳━━━━━┳━━━━━┳━━━━━╋━━━━━┳━━━━━┳━━━━━┳━━━━━┓
┃       ┃          ┃         ┃          ┃         ┃         ┃          ┃         ┃
bin    home      dev       etc        lib      sbin       tmp       usr       var
┃
┏━┻━┓
┃      ┃
rc.d   cron.d
┃
┏━━━┳━━━┳━┻━┳━━━━┓
┃      ┃     ┃      ┃       ┃
init.d  rc0.d rc1.d  rc2.d    ……&lt;/p&gt;

&lt;p&gt;/usr分区 ：
usr
┃
┏━━━━┳━━━╋━━━┳━━━┳━━━┓
┃       ┃      ┃      ┃     ┃      ┃
X11 R6  src    lib  local  man     bin
┃                ┃
┃ ┏━━━╋━━━┓
┃   ┃          ┃            ┃
linux bin lib src&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;ch4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在/etc目录下有个fstab文件，它里面列出了linux开机时自动挂载的文件系统的列表。我的/etc/fstab文件如下：
/dev/hda2 / ext3 defaults 1 1
/dev/hda1 /boot ext3 defaults 1 2
none /dev/pts devpts gid=5,mode=620 0 0
none /proc proc defaults 0 0
none /dev/shm tmpfs defaults 0 0
/dev/hda3 swap swap defaults 0 0
/dev/cdrom /mnt/cdrom iso9660 noauto,codepage=936,iocharset=gb2312 0 0
/dev/fd0 /mnt/floppy auto noauto,owner,kudzu 0 0
/dev/hdb1 /mnt/winc vfat defaults,codepage=936,iocharset=cp936 0 0
/dev/hda5 /mnt/wind vfat defaults,codepage=936,iocharset=cp936 0 0
在/etc/fstab文件里，第一列是挂载的文件系统的设备名，第二列是挂载点，第三列是挂载的文件系统类型，第四列是挂载的选项，选项间用逗号分隔。
在最后两行是我手工添加的windows下的C；D盘，加了codepage=936和iocharset=cp936参数以支持中文文件名。参数defaults实际上包含了一组默认参数：
rw 以可读写模式挂载
suid 开启用户ID和群组ID设置位
dev 可解读文件系统上的字符或区块设备
exec 可执行二进制文件
auto 自动挂载
nouser 使一般用户无法挂载
async 以非同步方式执行文件系统的输入输出操作
大家可以看到在这个列表里，光驱和软驱是不自动挂载的，参数设置为noauto。（如果你非要设成自动挂载，你要确保每次开机时你的光驱和软驱里都要有盘，呵呵。)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>RPM命令详解</title>
   <link href="http://dreambt.github.com/Linux/2009/04/05/rpm"/>
   <updated>2009-04-05T07:24:28+08:00</updated>
   <id>http://dreambt.github.com/Linux/2009/04/05/rpm</id>
   <content type="html">&lt;p&gt;初始化rpm 数据库&lt;/p&gt;

&lt;p&gt;rpm –initdb
rpm –rebuilddb 注：这个要花好长时间&lt;/p&gt;

&lt;p&gt;对已安装软件的查询&lt;/p&gt;

&lt;p&gt;查询系统已安装的软件：rpm -q 软件名
查看系统中所有已经安装的包：rpm -qa 如果分页查看加上｜more
查询一个已经安装的文件属于哪个软件包：rpm -qf 文件名
查询已安装软件包都安装到何处：rpm -ql 软件名 或 rpmquery -ql 软件名
查询一个已安装软件包的信息：rpm -qi 软件名
查看一下已安装软件的配置文件：rpm -qc 软件名
查看一个已经安装软件的文档安装位置：rpm -qd 软件名
查看一下已安装软件所依赖的软件包及文件：rpm -qR 软件名&lt;/p&gt;

&lt;p&gt;对未安装软件的查询&lt;/p&gt;

&lt;p&gt;查看一个软件包的用途、版本等信息：rpm -qpi file.rpm
查看一件软件包所包含的文件：rpm -qpl file.rpm
查看软件包的文档所在的位置：rpm -qpd file.rpm
查看一个软件包的配置文件：rpm -qpc file.rpm
查看一个软件包的依赖关系：rpm -qpR file.rpm&lt;/p&gt;

&lt;p&gt;安装和升级一个rpm包&lt;/p&gt;

&lt;p&gt;rpm -vih file.rpm 注：这个是用来安装一个新的rpm 包
rpm -Uvh file.rpm 注：这是用来升级一个rpm 包&lt;/p&gt;

&lt;p&gt;测试安装参数 –test ，用来检查依赖关系；并不是真正的安装
由新版本降级为旧版本，要加 –oldpackage 参数&lt;/p&gt;

&lt;p&gt;如：[root@localhost RPMS]# rpm -qa gaim
gaim-1.5.0-1.fc4
[root@localhost RPMS]# rpm -Uvh –oldpackage gaim-1.3.0-1.fc4.i386.rpm&lt;/p&gt;

&lt;p&gt;为软件包指定安装目录：要加 -relocate 参数
如把gaim-1.3.0-1.fc4.i386.rpm指定安装在 /opt/gaim 目录中&lt;/p&gt;

&lt;p&gt;[root@localhost RPMS]# rpm -ivh –relocate /=/opt/gaim gaim-1.3.0-1.fc4.i386.rpm
Preparing… ########################################### [100%]
1:gaim ########################################### [100%]
[root@localhost RPMS]# ls /opt/gaim&lt;/p&gt;

&lt;p&gt;我们安装在指定目录中的程序如何调用呢？一般执行程序，都放在安装目录的bin或者sbin目录中；看下面的例子；如果有错误输出，就做相应的链接，用 ln -s&lt;/p&gt;

&lt;p&gt;[root@localhost RPMS]# /opt/lynx/usr/bin/lynx
Configuration file /etc/lynx.cfg is not available.
[root@localhost RPMS]# ln -s /opt/lynx/etc/lynx.cfg /etc/lynx.cfg
[root@localhost RPMS]# /opt/lynx/usr/bin/lynx www.linuxsir.org&lt;/p&gt;

&lt;p&gt;例如移除lynx包，完整的操作应该是&lt;/p&gt;

&lt;p&gt;[root@localhost RPMS]# rpm -e lynx
如果有依赖关系，您也可以用–nodeps 忽略依赖的检查来删除。但尽可能不要这么做，最好用软件包管理器 systerm-config-packages 来删除或者添加软件；
[root@localhost beinan]# rpm -e lynx –nodeps&lt;/p&gt;

&lt;p&gt;src.rpm格式的包必须rpmbuild –rebuild filename.src.rpm ,然后cd /usr/src/redhat/RPMS/…. 寻找包并安装!&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>记2009年春节在新东方学习</title>
   <link href="http://dreambt.github.com/Life/2009/04/03/2009"/>
   <updated>2009-04-03T13:37:53+08:00</updated>
   <id>http://dreambt.github.com/Life/2009/04/03/2009</id>
   <content type="html">&lt;p&gt;2009年春节刚过，大年初三我便去了济南新东方学习。还是老规矩，先上图。&lt;/p&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;DSC00243&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e936012069fe6c5434c8&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/14245738f69d/medium.jpg&quot; alt=&quot;DSC00243|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00247&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e8a601206a07c944316e&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/46988738f8ff/medium.jpg&quot; alt=&quot;DSC00247|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00245&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e96b01206a0308a56483&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/35403738f7cd/medium.jpg&quot; alt=&quot;DSC00245|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00249&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045ea0301206a11a275665e&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/78194738fb88/medium.jpg&quot; alt=&quot;DSC00249|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00251&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e90001206a19e5913876&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/88831738fda6/medium.jpg&quot; alt=&quot;DSC00251|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00257&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e8a601206a1f5bf53368&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/84797738ff08/medium.jpg&quot; alt=&quot;DSC00257|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00258&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e8e001206a23f868362a&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/92952739003b/medium.jpg&quot; alt=&quot;DSC00258|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;strong&gt;DSC00260&lt;/strong&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e93601206a29321a3991&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/552047390190/medium.jpg&quot; alt=&quot;DSC00260|yupoo.com&quot; /&gt;&lt;/a&gt; &lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e90001206a2e9d1b3a61&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/9450673902f5/medium.jpg&quot; alt=&quot;|yupoo.com&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;http://www.yupoo.com/photos/view?id=ff8080812045e96b01206a3446b9688d&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://pic.yupoo.com/dreambt/173487390468/medium.jpg&quot; alt=&quot;|yupoo.com&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>XMLHttpRequest对象</title>
   <link href="http://dreambt.github.com/Web Design/2009/03/25/xmlhttprequest"/>
   <updated>2009-03-25T20:46:19+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2009/03/25/xmlhttprequest</id>
   <content type="html">&lt;p&gt;XMLHttpRequest对象是当今所有AJAX和Web 2.0应用程序的技术基础。尽管软件经销商和开源社团现在都在提供各种AJAX框架以进一步简化XMLHttpRequest对象的使用；但是，我们仍然很有必要理解这个对象的详细工作机制。&lt;/p&gt;

&lt;div&gt;&lt;strong&gt;一、 引言&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;异步JavaScript与XML(AJAX)是一个专用术语，用于实现在客户端脚本与服务器之间的数据交互过程。这一技术的优点在于，它向开发者提供了一种从Web服务器检索数据而不必把用户当前正在观察的页面回馈给服务器。与现代浏览器的通过存取浏览器DOM结构的编程代码(JavaScript)动态地改变被显示内容的支持相配合，AJAX让开发者在浏览器端更新被显示的HTML内容而不必刷新页面。换句话说，AJAX可以使基于浏览器的应用程序更具交互性而且更类似传统型桌面应用程序。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;Google的Gmail和Outlook Express就是两个使用AJAX技术的我们所熟悉的例子。而且，AJAX可以用于任何客户端脚本语言中，这包括JavaScript，Jscript和VBScript。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;AJAX利用一个构建到所有现代浏览器内部的对象-XMLHttpRequest-来实现发送和接收HTTP请求与响应信息。一个经由XMLHttpRequest对象发送的HTTP请求并不要求页面中拥有或回寄一个＜form＞元素。AJAX中的&quot;A&quot;代表了&quot;异步&quot;，这意味着XMLHttpRequest对象的send()方法可以立即返回，从而让Web页面上的其它HTML/JavaScript继续其浏览器端处理而由服务器处理HTTP请求并发送响应。尽管缺省情况下请求是异步进行的，但是，你可以选择发送同步请求，这将会暂停其它Web页面的处理，直到该页面接收到服务器的响应为止。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;微软在其Internet Explorer(IE) 5中作为一个ActiveX对象形式引入了XMLHttpRequest对象。其他的认识到这一对象重要性的浏览器制造商也都纷纷在他们的浏览器内实现了XMLHttpRequest对象，但是作为一个本地JavaScript对象而不是作为一个ActiveX对象实现。而如今，在认识到实现这一类型的价值及安全性特征之后，微软已经在其IE 7中把XMLHttpRequest实现为一个窗口对象属性。幸运的是，尽管其实现(因而也影响到调用方式)细节不同，但是，所有的浏览器实现都具有类似的功能，并且实质上是相同方法。目前，W3C组织正在努力进行XMLHttpRequest对象的标准化，并且已经发行了有关该W3C规范的一个草案。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;本文将对XMLHttpRequest对象API进行详细讨论，并将解释其所有的属性和方法。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;二、 XMLHttpRequest对象的属性和事件&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;XMLHttpRequest对象暴露各种属性、方法和事件以便于脚本处理和控制HTTP请求与响应。下面，我们将对此展开详细的讨论。&lt;/div&gt;


&lt;div&gt;readyState属性&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;当XMLHttpRequest对象把一个HTTP请求发送到服务器时将经历若干种状态：一直等待直到请求被处理；然后，它才接收一个响应。这样以来，脚本才正确响应各种状态-XMLHttpRequest对象暴露一个描述对象的当前状态的readyState属性，如表格1所示。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;表格1.XMLHttpRequest对象的ReadyState属性值列表。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;ReadyState取值 描述&lt;/div&gt;


&lt;div&gt;0  描述一种&quot;未初始化&quot;状态；此时，已经创建一个XMLHttpRequest对象，但是还没有初始化。&lt;/div&gt;


&lt;div&gt;1  描述一种&quot;发送&quot;状态；此时，代码已经调用了XMLHttpRequest open()方法并且XMLHttpRequest已经准备好把一个请求发送到服务器。&lt;/div&gt;


&lt;div&gt;2  描述一种&quot;发送&quot;状态；此时，已经通过send()方法把一个请求发送到服务器端，但是还没有收到一个响应。&lt;/div&gt;


&lt;div&gt;3  描述一种&quot;正在接收&quot;状态；此时，已经接收到HTTP响应头部信息，但是消息体部分还没有完全接收结束。&lt;/div&gt;


&lt;div&gt;4  描述一种&quot;已加载&quot;状态；此时，响应已经被完全接收。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;onreadystatechange事件&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;无论readyState值何时发生改变，XMLHttpRequest对象都会激发一个readystatechange事件。其中，onreadystatechange属性接收一个EventListener值-向该方法指示无论readyState值何时发生改变，该对象都将激活。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;responseText属性&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;这个responseText属性包含客户端接收到的HTTP响应的文本内容。当readyState值为0、1或2时，responseText包含一个空字符串。当readyState值为3(正在接收)时，响应中包含客户端还未完成的响应信息。当readyState为4(已加载)时，该responseText包含完整的响应信息。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;responseXML属性&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;此responseXML属性用于当接收到完整的HTTP响应时(readyState为4)描述XML响应；此时，Content-Type头部指定MIME(媒体)类型为text/xml，application/xml或以+xml结尾。如果Content-Type头部并不包含这些媒体类型之一，那么responseXML的值为null。无论何时，只要readyState值不为4，那么该responseXML的值也为null。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;其实，这个responseXML属性值是一个文档接口类型的对象，用来描述被分析的文档。如果文档不能被分析(例如，如果文档不是良构的或不支持文档相应的字符编码)，那么responseXML的值将为null。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;status属性&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;这个status属性描述了HTTP状态代码，而且其类型为short。而且，仅当readyState值为3(正在接收中)或4(已加载)时，这个status属性才可用。当readyState的值小于3时试图存取status的值将引发一个异常。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;statusText属性&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;这个statusText属性描述了HTTP状态代码文本；并且仅当readyState值为3或4才可用。当readyState为其它值时试图存取statusText属性将引发一个异常。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;三、 XMLHttpRequest对象的方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;XMLHttpRequest对象提供了各种方法用于初始化和处理HTTP请求，下列将逐个展开详细讨论。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;abort()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;你可以使用这个abort()方法来暂停与一个XMLHttpRequest对象相联系的HTTP请求，从而把该对象复位到未初始化状态。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;open()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;你需要调用open(DOMString method，DOMString uri，boolean async，DOMString username，DOMString password)方法初始化一个XMLHttpRequest对象。其中，method参数是必须提供的-用于指定你想用来发送请求的HTTP方法(GET，POST，PUT，Delete或HEAD)。为了把数据发送到服务器，应该使用POST方法；为了从服务器端检索数据，应该使用GET方法。另外，uri参数用于指定XMLHttpRequest对象把请求发送到的服务器相应的URI。借助于window.document.baseURI属性，该uri被解析为一个绝对的URI-换句话说，你可以使用相对的URI-它将使用与浏览器解析相对的URI一样的方式被解析。async参数指定是否请求是异步的-缺省值为true。为了发送一个同步请求，需要把这个参数设置为false。对于要求认证的服务器，你可以提供可选的用户名和口令参数。在调用open()方法后，XMLHttpRequest对象把它的readyState属性设置为1(打开)并且把responseText、responseXML、status和statusText属性复位到它们的初始值。另外，它还复位请求头部。注意，如果你调用open()方法并且此时readyState为4，则XMLHttpRequest对象将复位这些值。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;send()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;在通过调用open()方法准备好一个请求之后，你需要把该请求发送到服务器。仅当readyState值为1时，你才可以调用send()方法；否则的话，XMLHttpRequest对象将引发一个异常。该请求被使用提供给open()方法的参数发送到服务器。当async参数为true时，send()方法立即返回，从而允许其它客户端脚本处理继续。在调用send()方法后，XMLHttpRequest对象把readyState的值设置为2(发送)。当服务器响应时，在接收消息体之前，如果存在任何消息体的话，XMLHttpRequest对象将把readyState设置为3(正在接收中)。当请求完成加载时，它把readyState设置为4(已加载)。对于一个HEAD类型的请求，它将在把readyState值设置为3后再立即把它设置为4。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;send()方法使用一个可选的参数-该参数可以包含可变类型的数据。典型地，你使用它并通过POST方法把数据发送到服务器。另外，你可以显式地使用null参数调用send()方法，这与不用参数调用它一样。对于大多数其它的数据类型，在调用send()方法之前，应该使用setRequestHeader()方法(见后面的解释)先设置Content-Type头部。如果在send(data)方法中的data参数的类型为DOMString，那么，数据将被编码为UTF-8。如果数据是Document类型，那么将使用由data.xmlEncoding指定的编码串行化该数据。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;setRequestHeader()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;该setRequestHeader(DOMString header，DOMString value)方法用来设置请求的头部信息。当readyState值为1时，你可以在调用open()方法后调用这个方法；否则，你将得到一个异常。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;getResponseHeader()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;getResponseHeader(DOMString header，value)方法用于检索响应的头部值。仅当readyState值是3或4(换句话说，在响应头部可用以后)时，才可以调用这个方法；否则，该方法返回一个空字符串。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;getAllResponseHeaders()方法&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;该getAllResponseHeaders()方法以一个字符串形式返回所有的响应头部（每一个头部占单独的一行）。如果readyState的值不是3或4，则该方法返回null。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;四、 发送请求&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;在AJAX中，许多使用XMLHttpRequest的请求都是从一个HTML事件（例如一个调用JavaScript函数的按钮点击(onclick)或一个按键(onkeypress)）中被初始化的。AJAX支持包括表单校验在内的各种应用程序。有时，在填充表单的其它内容之前要求校验一个唯一的表单域。例如要求使用一个唯一的UserID来注册表单。如果不是使用AJAX技术来校验这个UserID域，那么整个表单都必须被填充和提交。如果该UserID不是有效的，这个表单必须被重新提交。例如，一个相应于一个要求必须在服务器端进行校验的Catalog ID的表单域可能按下列形式指定：&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;＜form name=&quot;validationForm&quot; action=&quot;validateForm&quot; method=&quot;post&quot;＞&lt;/div&gt;


&lt;div&gt;＜table＞&lt;/div&gt;


&lt;div&gt;＜tr＞＜td＞Catalog Id:＜/td＞&lt;/div&gt;


&lt;div&gt;＜td＞&lt;/div&gt;


&lt;div&gt;＜input type=&quot;text&quot; size=&quot;20&quot; id=&quot;catalogId&quot; name=&quot;catalogId&quot; autocomplete=&quot;off&quot; onkeyup=&quot;sendRequest()&quot;＞&lt;/div&gt;


&lt;div&gt;＜/td＞&lt;/div&gt;


&lt;div&gt;＜td＞＜div id=&quot;validationMessage&quot;＞＜/div＞＜/td＞&lt;/div&gt;


&lt;div&gt;＜/tr＞&lt;/div&gt;


&lt;div&gt;＜/table＞＜/form＞&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;前面的HTML使用validationMessage div来显示相应于这个输入域Catalog Id的一个校验消息。onkeyup事件调用一个JavaScript sendRequest()函数。这个sendRequest()函数创建一个XMLHttpRequest对象。创建一个XMLHttpRequest对象的过程因浏览器实现的不同而有所区别。如果浏览器支持XMLHttpRequest对象作为一个窗口属性(所有普通的浏览器都是这样的，除了IE 5和IE 6之外)，那么，代码可以调用XMLHttpRequest的构造器。如果浏览器把XMLHttpRequest对象实现为一个ActiveXObject对象(就象在IE 5和IE 6中一样)，那么，代码可以使用ActiveXObject的构造器。下面的函数将调用一个init()函数，它负责检查并决定要使用的适当的创建方法-在创建和返回对象之前。&lt;/div&gt;


&lt;div&gt;＜script type=&quot;text/javascript&quot;＞&lt;/div&gt;


&lt;div&gt;function sendRequest(){&lt;/div&gt;


&lt;div&gt;var xmlHttpReq=init();&lt;/div&gt;


&lt;div&gt;function init(){&lt;/div&gt;


&lt;div&gt;if (window.XMLHttpRequest) {&lt;/div&gt;


&lt;div&gt;return new XMLHttpRequest();&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;else if (window.ActiveXObject) {&lt;/div&gt;


&lt;div&gt;return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;＜/script＞&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;接下来，你需要使用Open()方法初始化XMLHttpRequest对象-指定HTTP方法和要使用的服务器URL。&lt;/div&gt;


&lt;div&gt;var catalogId=encodeURIComponent(document.getElementById(&quot;catalogId&quot;).value);&lt;/div&gt;


&lt;div&gt;xmlHttpReq.open(&quot;GET&quot;， &quot;validateForm?catalogId=&quot; + catalogId， true);&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;默认情况下，使用XMLHttpRequest发送的HTTP请求是异步进行的，但是你可以显式地把async参数设置为true，如上面所展示的。&lt;/div&gt;


&lt;div&gt;在这种情况下，对URL validateForm的调用将激活服务器端的一个servlet，但是你应该能够注意到服务器端技术不是根本性的；实际上，该URL可能是一个ASP，ASP.NET或PHP页面或一个Web服务-这无关紧要，只要该页面能够返回一个响应-指示CatalogID值是否是有效的-即可。因为你在作一个异步调用，所以你需要注册一个XMLHttpRequest对象将调用的回调事件处理器-当它的readyState值改变时调用。记住，readyState值的改变将会激发一个readystatechange事件。你可以使用onreadystatechange属性来注册该回调事件处理器。&lt;/div&gt;


&lt;div&gt;xmlHttpReq.onreadystatechange=processRequest;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;然后，我们需要使用send()方法发送该请求。因为这个请求使用的是HTTP GET方法，所以，你可以在不指定参数或使用null参数的情况下调用send()方法。&lt;/div&gt;


&lt;div&gt;xmlHttpReq.send(null);&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;五、 处理请求&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;在这个示例中，因为HTTP方法是GET，所以在服务器端的接收servlet将调用一个doGet()方法，该方法将检索在URL中指定的catalogId参数值，并且从一个数据库中检查它的有效性。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;本文示例中的这个servlet需要构造一个发送到客户端的响应；而且，这个示例返回的是XML类型，因此，它把响应的HTTP内容类型设置为text/xml并且把Cache-Control头部设置为no-cache。设置Cache-Control头部可以阻止浏览器简单地从缓存中重载页面。&lt;/div&gt;


&lt;div&gt;public void doGet(HttpServletRequest request，&lt;/div&gt;


&lt;div&gt;HttpServletResponse response)&lt;/div&gt;


&lt;div&gt;throws ServletException， IOException {&lt;/div&gt;


&lt;div&gt;...&lt;/div&gt;


&lt;div&gt;...&lt;/div&gt;


&lt;div&gt;response.setContentType(&quot;text/xml&quot;);&lt;/div&gt;


&lt;div&gt;response.setHeader(&quot;Cache-Control&quot;， &quot;no-cache&quot;);&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;来自于服务器端的响应是一个XML DOM对象，此对象将创建一个XML字符串-其中包含要在客户端进行处理的指令。另外，该XML字符串必须有一个根元素。&lt;/div&gt;


&lt;div&gt;out.println(&quot;＜catalogId＞valid＜/catalogId＞&quot;);&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;【注意】XMLHttpRequest对象的设计目的是为了处理由普通文本或XML组成的响应；但是，一个响应也可能是另外一种类型，如果用户代理(UA)支持这种内容类型的话。&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;当请求状态改变时，XMLHttpRequest对象调用使用onreadystatechange注册的事件处理器。因此，在处理该响应之前，你的事件处理器应该首先检查readyState的值和HTTP状态。当请求完成加载（readyState值为4）并且响应已经完成（HTTP状态为&quot;OK&quot;）时，你就可以调用一个JavaScript函数来处理该响应内容。下列脚本负责在响应完成时检查相应的值并调用一个processResponse()方法。&lt;/div&gt;


&lt;div&gt;function processRequest(){&lt;/div&gt;


&lt;div&gt;if(xmlHttpReq.readyState==4){&lt;/div&gt;


&lt;div&gt;if(xmlHttpReq.status==200){&lt;/div&gt;


&lt;div&gt;processResponse();&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;该processResponse()方法使用XMLHttpRequest对象的responseXML和responseText属性来检索HTTP响应。如上面所解释的，仅当在响应的媒体类型是text/xml，application/xml或以+xml结尾时，这个responseXML才可用。这个responseText属性将以普通文本形式返回响应。对于一个XML响应，你将按如下方式检索内容：&lt;/div&gt;


&lt;div&gt;var msg=xmlHttpReq.responseXML;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;借助于存储在msg变量中的XML，你可以使用DOM方法getElementsByTagName()来检索该元素的值：&lt;/div&gt;


&lt;div&gt;var catalogId=msg.getElementsByTagName(&quot;catalogId&quot;)[0].firstChild.nodeValue;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;最后，通过更新Web页面的validationMessage div中的HTML内容并借助于innerHTML属性，你可以测试该元素值以创建一个要显示的消息：&lt;/div&gt;


&lt;div&gt;if(catalogId==&quot;valid&quot;){&lt;/div&gt;


&lt;div&gt;var validationMessage = document.getElementById(&quot;validationMessage&quot;);&lt;/div&gt;


&lt;div&gt;validationMessage.innerHTML = &quot;Catalog Id is Valid&quot;;&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;else&lt;/div&gt;


&lt;div&gt;{&lt;/div&gt;


&lt;div&gt;var validationMessage = document.getElementById(&quot;validationMessage&quot;);&lt;/div&gt;


&lt;div&gt;validationMessage.innerHTML = &quot;Catalog Id is not Valid&quot;;&lt;/div&gt;


&lt;div&gt;}&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;&lt;strong&gt;六、 小结&lt;/strong&gt;&lt;/div&gt;


&lt;div&gt;&lt;/div&gt;


&lt;div&gt;上面就是XMLHttpRequest对象使用的所有细节实现。通过不必把Web页面寄送到服务器而实现数据传送，XMLHttpRequest对象为客户端与服务器之间提供了一种动态的交互能力。你可以使用JavaScript启动一个请求并处理相应的返回值，然后使用浏览器的DOM方法更新页面中的数据。&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>提问的智慧</title>
   <link href="http://dreambt.github.com/Life/2009/03/21/clever-question"/>
   <updated>2009-03-21T13:57:54+08:00</updated>
   <id>http://dreambt.github.com/Life/2009/03/21/clever-question</id>
   <content type="html">&lt;dl&gt;&lt;dt&gt;&lt;embed width=&quot;458&quot; height=&quot;649&quot; menu=&quot;true&quot; loop=&quot;true&quot; play=&quot;true&quot; src=&quot;http://f.yupoo.com/v.swf?id=dreambt-ff8080811ffdb5b701202798cbf90ce2-o&quot; pluginspage=&quot;http://www.macromedia.com/go/getflashplayer&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/embed&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#translations&quot;&gt;译文&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#disclaimer&quot;&gt;弃权申明&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#intro&quot;&gt;引言&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#before&quot;&gt;提问前&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#asking&quot;&gt;提问时&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;                     &lt;dl&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#forum&quot;&gt;仔细挑选论坛&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#usefora&quot;&gt;面向新手的网页论坛和IRC通常响应最快&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#uselists&quot;&gt;第二步，使用项目邮件列表&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#bespecific&quot;&gt;使用明确而有意义的主题&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#easyreply&quot;&gt;使之更易回复&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#writewell&quot;&gt;使用清晰、语法与拼写正确的语句&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#formats&quot;&gt;使用易懂的格式发送问题&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#beprecise&quot;&gt;描述问题应准确且有内容&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#volume&quot;&gt;多不等于准确&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3001405&quot;&gt;别动辄声称找到臭虫&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3001578&quot;&gt;低声下气不能代替自己应做之事&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#symptoms&quot;&gt;描述问题症状而不是猜测&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#chronology&quot;&gt;按时间先后罗列问题症状&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#goal&quot;&gt;描述目的而不是步骤&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#noprivate&quot;&gt;别要求私下回复&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#explicit&quot;&gt;问题应明晰&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#homework&quot;&gt;别张贴家庭作业&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#prune&quot;&gt;删除无意义的问题&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#urgent&quot;&gt;不要刻意标明问题紧急&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#courtesy&quot;&gt;礼貌总是无害的&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#followup&quot;&gt;问题解决后追加一条简要说明&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;                 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#answers&quot;&gt;如何解读回答&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;                     &lt;dl&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#rtfm&quot;&gt;RTFM与STFW：如何知道你已完全搞砸 &lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#lesser&quot;&gt;如果还不明白.&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect2&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#keepcool&quot;&gt;对待无礼&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;                 &lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#not_losing&quot;&gt;别象个失败者那样反应 &lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#classic&quot;&gt;提问禁忌&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#examples&quot;&gt;好问题与坏问题&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002966&quot;&gt;如果没有回复 &lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3003018&quot;&gt;如何更好地回答问题&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3003109&quot;&gt;相关资源&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;span class=&quot;sect1&quot;&gt;&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3003139&quot;&gt;鸣谢&lt;br /&gt;
&lt;/a&gt;&lt;/span&gt;&lt;/dt&gt;&lt;/dl&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;translations&quot;&gt;&lt;/a&gt;译文&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;译文: &lt;a href=&quot;http://stare.cz/otazky/index.html&quot; target=&quot;_top&quot;&gt;捷克语&lt;/a&gt; &lt;a href=&quot;http://www.usenet.dk/netikette/udvdebatteknik.html&quot; target=&quot;_top&quot;&gt;丹麦语&lt;/a&gt; &lt;a href=&quot;http://linux.ee/%7Ekala/smart-questions.html&quot; target=&quot;_top&quot;&gt;                         爱沙尼 亚语&lt;/a&gt; &lt;a href=&quot;http://www.gnurou.org/documents/smart-questions-fr.html&quot; target=&quot;_top&quot;&gt;                             法语&lt;/a&gt; &lt;a href=&quot;http://www.lugbz.org/documents/smart-questions_de.html&quot; target=&quot;_top&quot;&gt;                                 德语&lt;/a&gt; &lt;a href=&quot;http://www.penguin.org.il/essays/smart-questions-he.html&quot; target=&quot;_top&quot;&gt;                                     希伯来语&lt;/a&gt; &lt;a href=&quot;http://www.no.info.hu/%7Ekryss/gnu/esr/smart-questions_hu.html&quot; target=&quot;_top&quot;&gt;匈牙利语&lt;/a&gt; &lt;a href=&quot;http://members.xoom.virgilio.it/army1987/domande.html&quot; target=&quot;_top&quot;&gt;意大利语&lt;/a&gt; &lt;a href=&quot;http://www.ranvis.com/articles/smart-questions.ja.html&quot; target=&quot;_top&quot;&gt;日语&lt;/a&gt; &lt;a href=&quot;http://rtfm.killfile.pl/&quot; target=&quot;_top&quot;&gt;波 兰语&lt;/a&gt;                 &lt;a href=&quot;http://ln.com.ua/%7Eopenxs/articles/smart-questions-ru.html&quot; target=&quot;_top&quot;&gt;                     俄语&lt;/a&gt; &lt;a href=&quot;http://www.sindominio.net/ayuda/preguntas-inteligentes.html&quot; target=&quot;_top&quot;&gt;                         西班牙语&lt;/a&gt; &lt;a href=&quot;http://www.se.linux.org/dokumentation/howto/smartafragor&quot; target=&quot;_top&quot;&gt;                             瑞典语&lt;/a&gt; &lt;a href=&quot;http://belgeler.org/howto/smart-questions.html&quot; target=&quot;_top&quot;&gt;土 耳其语&lt;/a&gt;.                 如果你想复制、镜像、翻译或引用本文，请参阅我的 &lt;a href=&quot;http://www.catb.org/%7Eesr/copying.html&quot; target=&quot;_top&quot;&gt;                     复制须知&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;disclaimer&quot;&gt;&lt;/a&gt;弃权申明&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;emphasis&quot;&gt;许多项目的网站在 如何取得帮助的部分链接了本文，这没有关系，也是我们想要的。但如果你是该项目生成此链接的网管，请在链接附近显著位置注明&amp;ldquo;&lt;span style=&quot;font-style: italic;&quot;&gt;我们不是此项目的服务部！&lt;/span&gt;&amp;rdquo;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们已经遭受没有此说明带来的痛苦，不断受到一些白痴的骚扰。他们认为既然我们发表了此文，那么我们就有责任解决世上所有技术问题！&lt;/p&gt;
&lt;p&gt;如果你因为需要帮助阅读了本文，然后带着可以直接从作者那取得帮助的印象离开，你就不幸成了那些白痴之一。不要向我们提问，我们不会理睬 的。 我们在这只是给你说明如何从那些真正懂得你软硬件问题的人那里取得帮助的方法，99%的时间我们不会是那些人。除非你确信此文作者是你遇到问题方面的专 家， 请不要打扰，这样大家都更开心一点。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在 &lt;a href=&quot;http://www.catb.org/%7Eesr/faqs/hacker-howto.html&quot; target=&quot;_top&quot;&gt;黑客&lt;/a&gt;                 的世界，你所提技术问题的回答很大程度上取决于你提问的方式与解决此问题的难度，本文将教你如何提问才更有可能得到满意的答复。&lt;/p&gt;
&lt;p&gt;开源程序的使用已经很广，你通常可以从其它更有经验的用户而不是黑客那里得到回答。这是好事，他们一般对新手常有的毛病更容忍一点。然尔，使用我们 介 绍的方法象对待黑客那样对待这些有经验的用户，通常能最有效地得到问题的解答。&lt;/p&gt;
&lt;p&gt;第一件需要明白的事是黑客喜欢难题和激发思考的好问题。假如不是这样，我们也不会写本文了。如果你能提出一个有趣的问题让我们咀嚼玩味，我们会感激 你。 好的 问题是种激励与礼物，帮助我们发展认知，揭示没有注意或想过的问题。在黑客中，&amp;ldquo;好问题！&amp;rdquo;是非常真挚的赞许。&lt;/p&gt;
&lt;p&gt;除此而外，黑客有遇到简单问题就表现出敌视或傲慢的名声，有时候我们看起来还对新手和愚蠢的家伙有条件反 射式的无礼，但并不真正是这样。&lt;/p&gt;
&lt;p&gt;我们只是毫无歉意地敌视那些提问前 不愿思考、不做自己该做之事的人。这种人就象时间无底洞──他们只知道获取，不愿意付出，他们浪费了时间，这些时间本可用于其它更值得回答的人和                 更有趣 的问题。我们将这种人叫做&amp;ldquo;失败者 (loser)&amp;rdquo; (由于历史原因，我们有时将&amp;ldquo;loser&amp;rdquo;拼为&amp;ldquo;lusers&amp;quot;)&lt;/p&gt;
&lt;p&gt;我们注意到许多人只想用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，计算机只是种工具，是种达到目的的手段。他们要生活并且有更要 紧的事要做，我们承认这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。不过，我们回答问题的风格是为了适应那些真正对此有兴趣并愿意主动参与 问题解决的 人，这一点不会变，也不该变。如果这都变了，我们就会在自己能做得最好的事情上不再那么犀利。&lt;/p&gt;
&lt;p&gt;我们(多数)是自愿者，从自己繁忙的生活中抽时间来回答问题，有时会力不从心。因此，我们会无情地滤除问题，特别是那些看起来象是失败者的，以 便更有效地把回答问题的时间留给那些&amp;ldquo;胜利者&amp;rdquo;&lt;/p&gt;
&lt;p&gt;如果你认为这种态度 令人憎恶、以施惠者自居或傲慢自大，请检查你的假设，我们并未要求你屈服──事实上，假如你做了该做的努力使之成为可能，我们中的 大多数人非常乐意平等地与你交流并欢迎你接纳我们的文化。试图去帮助那些不愿自救的人对我们简直没有效率，不懂没有关系，但愚蠢地行事不行。&lt;/p&gt;
&lt;p&gt;所以，你不必在技术上很在行才能吸引我们的注意，但你&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;必须&lt;/span&gt;表现出能引导你在行的姿态──机                 敏、思考、善于观察、乐于主动参与问题的解决。如果你 做不到这些使你与众不同的事情，我们建议你付钱跟别人签商业服务合同，而不是要求黑客无偿帮助。&lt;/p&gt;
&lt;p&gt;如果你决定向我们求助，你不会想成为一名失败者，你也不想被看成一个失败者。得到快速有效回复的最好方法是使提问者看起来象个聪明、自 信的人，并且暗示只是碰巧在某一特别问题上需要帮助。&lt;/p&gt;
&lt;p&gt;(欢迎对本文指正，可以将建议发至 &lt;a href=&quot;mailto:esr@thyrsus.com&quot; target=&quot;_top&quot;&gt;esr@thyrsus.com&lt;/a&gt;                 。 请注意，本文不想成为一般性的 &lt;a href=&quot;http://www.dtcc.edu/cs/rfc1855.html&quot; target=&quot;_top&quot;&gt;网络礼仪&lt;/a&gt;                 指南，我一般会拒绝那些与引出技术论坛中有用的回复不特别相关的建议)&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;before&quot;&gt;&lt;/a&gt;提问前&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在通过电子邮件、新闻组或网页论坛提技术问题之前，做以下事情：&lt;/p&gt;
&lt;div class=&quot;procedure&quot;&gt;
&lt;ol type=&quot;1&quot;&gt;
    &lt;li&gt;
    &lt;p&gt;尝试搜索互联网以找到答案&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;尝试阅读手册以找到答案&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;尝试阅读FAQ(常见问题)文档以找到答案&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;尝试自己检查或试验以 找到答案&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;尝试请教懂行的朋友以找到答案&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;如果你是程序员，尝试阅读源代码以找到答案&lt;/p&gt;
    &lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;p&gt;提问时，请先表述你已经做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;学到的东西&lt;/span&gt;，我们喜欢 回答那些表现出能从答案中学习的人。&lt;/p&gt;
&lt;p&gt;使用某些策略，比如用Google搜索你遇到的错误提示(既搜索网页也查查讨论组)，可能就直接找到了解决问题的文档或邮件列表线索。即使没有结 果，在电子邮件或新闻组张贴问题时提一句&amp;ldquo;我在Google中查过下列句子但没有找到什么有用的东西&amp;rdquo;也是件好事。&lt;/p&gt;
&lt;p&gt;准备你的问题，彻底地思考。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，越是表现出做过思考并在努力解 决问题，你越有可能得到 实际帮助。&lt;/p&gt;
&lt;p&gt;注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想&amp;rdquo;愚蠢的问题&amp;hellip;&amp;hellip;&amp;ldquo;，一边用按照问题字面的无用答案回复你，并且希望这种只 是得到 字 面回答而不是真正所需的经历给你一个教训。&lt;/p&gt;
&lt;p&gt;永远不要假设你&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;有资格&lt;/span&gt;得 到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社                 区贡献经验而不仅仅是消极地要求从别人那获取知识的问题，你将&amp;ldquo;挣到&amp;rdquo;答案。&lt;/p&gt;
&lt;p&gt;另一方面，表明你能够也乐意参与问题的解决是个很好的开端。&amp;ldquo;有没有 人能指个方向？&amp;rdquo;、&amp;ldquo;我这还漏点什么？&amp;rdquo;、&amp;ldquo;我应该查哪些网站？&amp;rdquo;通常要比 &amp;ldquo;请给出我可以用的完整步骤&amp;rdquo;更容易得到回复，因为你表明了只要有人能指个方向你就很乐意完成剩下的过程。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;asking&quot;&gt;&lt;/a&gt;提问时&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;forum&quot;&gt;&lt;/a&gt;仔细挑选论坛&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;要对在哪提问留心，如果你做了下 述事情，多半会被一笔勾销或被看成&amp;ldquo;失败者&amp;rdquo;：&lt;/p&gt;
&lt;div class=&quot;itemizedlist&quot;&gt;
&lt;ul type=&quot;disc&quot;&gt;
    &lt;li&gt;
    &lt;p&gt;张贴与论坛主题完全无关的问题&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;在面向高级技术问题的论坛上提非常 初浅的问题，或者反之。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;在太多不同的新闻组同时交叉张贴&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;给既非熟人也没有义务解决你问题的个人张贴你私人的电子邮件&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;为保护通信的渠道不被无 关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想有这种经历的。&lt;/p&gt;
&lt;p&gt;所以第一步是找对论坛，Google与其它搜索引擎还是你的朋友，可以用它们搜索与你遇到困难的软硬件问题最相关的项目的网站。那 里通常都有项目的FAQ列表、邮件列表及其文档的链接。如果你的努力(包括阅读FAQ)都没有结果，这些邮件列表就是最后能取得帮助 的地方。项目的网站也许还有报告臭虫的流程或链接，如果是这样，去看看。&lt;/p&gt;
&lt;p&gt;向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个富含信息的网页的编写者想充当你的免费顾问，不要对你 的问题是否会受到欢迎做乐 观的 估计──如果你                     不确定，向别处发或者根本别发。&lt;/p&gt;
&lt;p&gt;在选择网页论坛、新闻组或邮件列表时，不要太相信名字，先看看FAQ或者许可书以明确你的问题 是否与其主题相关。张贴前先翻翻已有的帖 子可 以 帮助你感受一下那里行事的方式。事实上，张贴之前在新闻组或邮件列表中搜索与你问题相关的关键词是个很好的主意，也许就找到答案了。即使没有，也能帮助你 整理 出 更好的问题。&lt;/p&gt;
&lt;p&gt;别象机关枪似的一次性&amp;ldquo;扫射&amp;rdquo;所有的帮助通 道，那就象大嚷大叫并使人不快。一个一个地来。&lt;/p&gt;
&lt;p&gt;弄清楚你的主题！最典型的错误之一是在某种致立于跨Unix和Windows平台的语言、库或工具的论坛中提关于操作系统程序接口的问题。如果你不 明白为什么这是大错，最好在搞清楚概念前什么也别问。&lt;/p&gt;
&lt;p&gt;一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回复。有许多理由支持这一点，一是看潜在的回复者有多少，二是看 论 坛的参与者有多少，黑客更愿回答能启发多数人的问题。&lt;/p&gt;
&lt;p&gt;可以理解，老练的黑客和一些流行软件的作者正在收到超出他们承受能力的不当消息。就象那根多出来就可以压垮骆驼背的稻草一样，你的 加入也可能会使情况走向极端──已经好几次了，一些流行软件的作者退出了对其软件的支持，因为伴随而来的涌向其私人邮箱的大量无用消息变得无法 忍受。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3&gt;&lt;a name=&quot;usefora&quot;&gt;&lt;/a&gt;面向新手的网页论坛和IRC通常响应最快&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;本地的用户组织或者你所用的Linux发行版也许正在宣传新手取得帮助的网页论坛或IRC(互联网中继聊天) (在非英语国家，新手论坛很可能还是邮件列表)，这些 地                     方 是开始提问的好去处，尤其是当你觉得遇到的也许只是相对简单或者一般的问题时。经过宣传的IRC通道是个公开邀请提问的地方，通常可以得到实时的回复。&lt;/p&gt;
&lt;p&gt;事实上，如果出问题的程序来自某发行版(这很常见)，在程序的项目论坛或列表提问前最好先在发行版的论坛或列表中问问，(否则)项目的黑客可能仅仅 回复&amp;ldquo;用&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;我们&lt;/span&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;的&lt;/span&gt;代码&amp;rdquo;&lt;/p&gt;
&lt;p&gt;在任何网页论坛张贴之前，先看看是否有搜索功能。如果有，就试试用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索 (你应该这样做)，还是再搜索一下论坛，搜索引擎最近也许还没有索引此论坛的全部内容。&lt;/p&gt;
&lt;p&gt;通过网页论坛或IRC频道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发保留。先在网页论坛或IRC中寻求与项目相关的帮 助。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;uselists&quot;&gt;&lt;/a&gt;第二步，使用项目邮件列表&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当某项目存在开发者邮件列表时，即使你确信谁能最好地回答问题，也要向列表而不是其中的个体提问。检查项目的文档和主页，找到项目的邮件列表并使 用它。采用这种策略有几个好理由：&lt;/p&gt;
&lt;div class=&quot;itemizedlist&quot;&gt;
&lt;ul type=&quot;disc&quot;&gt;
    &lt;li&gt;
    &lt;p&gt;任何向单个开发者提的足够好的问题也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为打扰 单个开发者的理由。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;向列表提问可以平衡开发者的负担，单个开发者(特别是项目领导)也许太忙以至于无法回答你的问题。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;大多数邮件列表有历史文档并被搜索引擎索引，其它人可以通过网页搜索找到你的问题和答案而不用再次在邮件列表中发问。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整 场景。&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;如果一个项目既有&amp;ldquo;用户&amp;rdquo;也有&amp;ldquo;开发者&amp;rdquo;(或&amp;ldquo;黑客&amp;rdquo;)邮件列表或网页论坛，而你又不摆弄那些代码，向&amp;ldquo;用户&amp;rdquo;列表或论坛提问。不要假设自己在开发 者列表中会受欢 迎，那些人多半会遭受你的噪音干扰。&lt;/p&gt;
&lt;p&gt;然尔，如果你&lt;span style=&quot;font-style: italic;&quot;&gt;确信&lt;/span&gt;你的问题不一般，而且在&amp;ldquo;用户&amp;rdquo; 列表或论坛中几天都没有回复，可以试试&amp;ldquo;开发者&amp;rdquo;列表或论坛。建议你在张贴前最好先暗暗地观察几天                     以了解那的行事方式(事实上这是参与任何私有或半私有列表的好主意)&lt;/p&gt;
&lt;p&gt;如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设(项目)邮件列表不存在。在你的电子邮 件中陈述你已 经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人(许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子 邮件 转 发他人给 了相应人员处置你邮件的选择)。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;bespecific&quot;&gt;&lt;/a&gt;使用明确而有意义的主题&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在邮件列表、新闻组或网页论坛中，主题是你在五十个或更少的字符以内吸引有资格的专家注意的黄金机会，不要用诸如&amp;ldquo;请帮我&amp;rdquo;(更别提大写的&amp;ldquo;请帮 我！！！！&amp;rdquo;，这种主题的消息会被条件反射式地删掉)之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题 描述。&lt;/p&gt;
&lt;p&gt;使用主题的好惯例是&amp;ldquo;对象──偏差&amp;rdquo;(式的描述)，许多技术支持组织就是这样做的。在&amp;ldquo;对象&amp;rdquo;部分指明是哪一个或哪一组东西有问题，在&amp;ldquo;偏差&amp;rdquo;部分 则描述与期望 行 为不一致的地方。&lt;/p&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;                             &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;愚蠢：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;救命啊！我的笔记本视频工作不正常！&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;                             &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;明智：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;XFree86 4.1扭曲鼠标光标，某显卡MV1005型号的芯片组&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;                             &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;更明智：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;使用某显卡MV1005型号芯片组的XFree86 4.1的鼠标光标被扭曲&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;p&gt;编写&amp;ldquo;对象──偏差&amp;rdquo;式描述的过程有助于你更具体地组织你的问题。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在XFree86中出现？或 只是在其4.1版中？是针对某显卡？或者只是其MV1005型号的芯片组？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。&lt;/p&gt;
&lt;p&gt;更一般地，想象一下在只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接找到答案的线索而不用 再次张贴提问。&lt;/p&gt;
&lt;p&gt;如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象&amp;ldquo;re: 测试&amp;rdquo;或&amp;ldquo;re: 新臭虫&amp;rdquo;的消息不太可能引起足够的注意。同 时，将回复中与新主题不甚相关的引用内容尽量删除&lt;/p&gt;
&lt;p&gt;对于列表消息，不要直接点击回复(按钮)来开始一个新的线索，这将限制你的观众。有些邮件阅读程序，比如mutt，允许用户按线索排序并通过折叠线 索来隐藏消息， 这样做的人永远看不到你发的消息。&lt;/p&gt;
&lt;p&gt;仅仅改变主题还不够。mutt和其它邮件阅读程序还要检查主题以外的其它邮件头信息，以便为其指定线索，所以宁可发一 个全 新的邮件。&lt;/p&gt;
&lt;p&gt;在网页论坛，因为消息与特定的线索紧密结合并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧(一些论坛甚至不允许在 回复中出现分离的主题，而且这样做了基本上没有人会去看)。不过通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该 线索的人读到。所以，除非你只想在该线索当前活跃的人群中提问，还是另起炉灶比较好。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;easyreply&quot;&gt;&lt;/a&gt;使之更易回复&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;以&amp;ldquo;请向&amp;hellip;&amp;hellip;回复&amp;rdquo;来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟 考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的。如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。&lt;/p&gt;
&lt;p&gt;在网页论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是机密的(而且有人会为了某种未知的原因只让你而不是整个论坛知道答 案)。如果 你只是想 在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都提供诸如&amp;ldquo;留意本线索&amp;rdquo;、&amp;ldquo;有回复发送邮件&amp;rdquo;的功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;writewell&quot;&gt;&lt;/a&gt;使用清晰、语法与拼写正确的语句&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程(我敢打赌)。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将 时间花在其它地方。&lt;/p&gt;
&lt;p&gt;清楚、完整地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意(你的问题)麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实 上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;准确&lt;/span&gt;，而且有迹象表明你是在思考和关 注问题。&lt;/p&gt;
&lt;p&gt;正确地拼写、使用标点和大小写，不要将&amp;ldquo;its&amp;rdquo;混淆为&amp;ldquo;it's&amp;rdquo;，&amp;ldquo;loose&amp;rdquo;搞成&amp;ldquo;lose&amp;rdquo;或者将&amp;ldquo;discrete&amp;rdquo;弄成 &amp;ldquo;discreet&amp;rdquo;。&lt;span style=&quot;font-weight: bold;&quot;&gt;不要全部用大写&lt;/span&gt;，这会被看成无礼的大声嚷嚷 (全部小写也好不到哪去，因为不易阅读。Alan                     Cox[注：著名黑客，Linux内核的重要参与者]也许可以这样做，但你不行 )。&lt;/p&gt;
&lt;p&gt;一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。如果象个小孩似地乱写乱画那绝对是在找死，可以肯定没人会理你(或者最多 是给你一大堆指责与挖苦)。&lt;/p&gt;
&lt;p&gt;如果在非母语论坛中提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍(是的，我们通常看得出其中的差别)。同时，除非你知道回复者 使用 的语言，请使用                     英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被 阅读就被直接删除的可能降到最低。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;formats&quot;&gt;&lt;/a&gt;使用易懂的格式发送问题&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：&lt;/p&gt;
&lt;div class=&quot;itemizedlist&quot;&gt;
&lt;ul type=&quot;disc&quot;&gt;
    &lt;li&gt;
    &lt;p&gt;使用文本而不是HTML(超文本标注语言) ( &lt;a href=&quot;http://expita.com/nomime.html&quot; target=&quot;_top&quot;&gt;关闭HTML&lt;/a&gt;                                 并不难)&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;使用MIME(多用途互联网邮件扩展)附件通常没有问题，前提是真正有内容(譬如附带的源文件或补丁)，而不仅仅是邮件客户端程序 生 成的模板(譬如只是消息内容的拷贝)。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;不要发送整段只是单行句子但多次折回的邮件(这使得回复部分内容非常困难)。设想你的读者是在80个字符宽的文本终端阅读邮件， 设置你的行折回点小于80列。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;但是，也&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;不要&lt;/span&gt;用 任何固定列折回数据(譬如直接传送的日                                 志文件或会话记录)。数据应该原样包含，使回复者确信他们看到的与你看到的东西一样。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;在英语论坛中，不要使用'Quoted-Printable' MIME编码发送消息。这种编码对于张贴非ASCII语言可能是必须的，但很多邮件代理程序并不支持。当它们分断时，那些文本中四处散布                                 的 &amp;ldquo;=20&amp;rdquo;符号既难看也分散注意力。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;永远不要&lt;/span&gt;指 望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的Word或Excel文件等，大多数黑客对此的反应就象有人将还在冒热气的猪                                 粪倒在你门口时你的反应一样。即使他们能够处理，他们也很厌恶这么做。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;如果你从使用视窗的电脑发送电子邮件，关闭微软愚蠢的&amp;ldquo;聪明引用&amp;rdquo;功能，以免在你的邮件中到处散布垃圾字符。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;在网页论坛，勿滥用&amp;ldquo;表情符号&amp;rdquo;和&amp;ldquo;html&amp;rdquo;功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为 你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;如果你使用图形用户界面的邮件客户端程序(如网景公司的Messenger、微软公司的Outlook或者其它类似的)，注意它们的缺省配置不一 定满足这些要求。大多数这类程序有基于菜单的&amp;ldquo;查看源码&amp;rdquo;命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;beprecise&quot;&gt;&lt;/a&gt;描述问题应准确且有内容&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;itemizedlist&quot;&gt;
&lt;ul type=&quot;disc&quot;&gt;
    &lt;li&gt;
    &lt;p&gt;仔细、清楚地描述问题的症状&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;描述问题发生的环境(主机，操作系统，应用程序，任何相关的)，提供销售商的发行版和版本号(如：&amp;ldquo;Fedora Core 2&amp;rdquo;、&amp;ldquo;Slackware 9.1&amp;rdquo;等)&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;描述提问前做过的研究及其理解。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;描述提问前为确定问题而采取的诊断步骤。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
    &lt;p&gt;描述最近对计算机或软件配置的任何相关改变。&lt;/p&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;尽最大努力预测黑客会提到的问题，并提前备好答案。&lt;/p&gt;
&lt;p&gt;Simon Tatham写过一篇叫 &lt;a href=&quot;http://www.chiark.greenend.org.uk/%7Esgtatham/bugs.html&quot; target=&quot;_top&quot;&gt;如何有效报告臭虫&lt;/a&gt; 的文章，我强烈推荐各位阅读。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;volume&quot;&gt;&lt;/a&gt;多不等于准确&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;你应该(写得)准确且有内容，简单地将一大堆代码或数据&amp;ldquo;倾倒&amp;rdquo;在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝 试将其裁剪得越小越好。&lt;/p&gt;
&lt;p&gt;至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到&lt;span style=&quot;font-style: italic; font-weight: bold;&quot;&gt;有用的&lt;/span&gt;回复。第三，在提纯臭虫 报告的过程中，你可能自己就找到了解决问题的方法或权宜之计。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id3001405&quot;&gt;&lt;/a&gt;别动辄声称找到臭虫&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当你在一个软件中遇到问题，除非你&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;非 常、非常&lt;/span&gt;的有根据，不要动辄声称找到了臭虫。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测                     试 表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你(声称)发现了文档的&amp;ldquo;臭虫&amp;rdquo;，你应该能提供相应位置的替代文本。&lt;/p&gt;
&lt;p&gt;记住，还有许多其它用户未经历你遇到的问题，否则你在阅读文档或网页搜索时就应该发现了(你在报怨前已经做了这些，&lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#before&quot; title=&quot;Before You Ask&quot;&gt;是吧&lt;/a&gt;？)。这也意味着很有可能是你弄错了而不是软件本身有问                     题。&lt;/p&gt;
&lt;p&gt;编写软件的人通常非常辛苦地使它尽可能完美。如果你声称找到了臭虫，也就暗示他们做错了什么，而这几乎总会使人不快──即使你是对的， 在主题中嚷嚷&amp;ldquo;臭虫&amp;rdquo;也是特别不老练的。&lt;/p&gt;
&lt;p&gt;提问时，即使你私下非常确信已经发现一个真正的臭虫，最好写得象是&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;你&lt;/span&gt;做                     错了什么。如果真的有臭虫，你会在回复中看到这点。这么做的话，如果真有虫子，维护者就会向你道歉，这总比你弄 砸了然后欠别人一个道歉要强。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;id3001578&quot;&gt;&lt;/a&gt;低声下气不能代替自己应做之事&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端，&amp;ldquo;我知道我只是个什么也不是、什么也不懂的失败者， 但&amp;hellip;&amp;hellip;&amp;rdquo;。这既使人困扰也没有帮助，当伴随着对实际问题含糊的描述时还特别令人反感。&lt;/p&gt;
&lt;p&gt;别用低级灵长类动物的策略浪费大家的时间，相反，尽量清楚地表述背景事实和你的问题，这比低声下气更好地摆正了你的位置。&lt;/p&gt;
&lt;p&gt;有时，网页论坛设有单独的初学者提问区域，如果你真的认为遇到了初浅的问题，到那去就是了，但一样别低声下气。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;symptoms&quot;&gt;&lt;/a&gt;描述问题症状而不是猜测&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;告诉黑客你认为是什么导致了问题是没有用的(如果你的诊断理论是了不起的东西，你还会向他人咨询求助吗？)。所以，确保只是告诉他们问题的原始 症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述你的猜测很重要，清楚地说明这只是你的猜测并描述为什么它们不起作用。&lt;/p&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;                             &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;愚蠢：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;我在编译内核时接连遇到SIG11错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;明智：&lt;/span&gt; &lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;我组装的电脑(K6/233 CPU、FIC-PA2007主板(威盛Apollo VP2芯片组)、Corsair PC133 SDRAM 256Mb内 存)最近在开机20分钟左右、做内核编译时频繁地报SIG11错，但在头20分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问 题，相关的典型编译会话日志附后。&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;chronology&quot;&gt;&lt;/a&gt;按时间先后罗列症状&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你及电脑在崩溃之前都做了些什么。在命令行处理的 情况下，有会话日志(如运行脚本工具生成的)并引用相关的若干(如20)行记录会非常有帮助。&lt;/p&gt;
&lt;p&gt;如果崩溃的程序有诊断选项(如-v详述选项)，仔细考虑选择这些能在记录中增加排错信息的选项。&lt;/p&gt;
&lt;p&gt;如果你的记录很长(如超过四段)，也许在开头简述问题随后按时间先后罗列详细过程更有用。这样做，黑客在读你的记录时就知道该查哪些内容了。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;goal&quot;&gt;&lt;/a&gt;描述目的而不是步骤&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你想弄清楚如何做某事(而不是报告一个臭虫)，在开头就描述你的目标，此后才描述为此采取的措施所遇到的问题。&lt;/p&gt;
&lt;p&gt;经常有这种情况，寻求技术帮助的人在脑袋里有个更高层面的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但 没有意识到这条路本身有问题，结果要费很大的劲才能通过。&lt;/p&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;愚蠢：&lt;/span&gt; &lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;我怎样才能让某图形程序的颜色拾取器取得十六进制的RGB值？&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;strong&quot;&gt;明智：&lt;/span&gt; &lt;/span&gt;&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;我正试图用自己选定数值的颜色替换一幅图片的颜色表，我现在唯一知道的方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进 制的RGB值。&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;p&gt;第二种提法是明智的，它使得建议采用更合适的工具完成任务的回复成为可能。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;noprivate&quot;&gt;&lt;/a&gt;别要求私下回复&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被更正。同时，作为 回复者也因为能力和学识被其它同行看到而得到某种回报。&lt;/p&gt;
&lt;p&gt;当你要求私下回复时，此过程和回报都被中止。别这样做，让&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;回复者&lt;/span&gt;来决定是否私下回答──如果他                     真这么做了，通常是因为他认为问题编写太差或者太肤浅 以 至于对其它人无意义。&lt;/p&gt;
&lt;p&gt;对这条规则存在一条有限的例外，如果你确信提问可能会导致大量雷同的回复时，那么&amp;ldquo;给我发电子邮件，我将为小组归纳这些回复&amp;rdquo;将是神奇的句子。试图 将邮 件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你应信守诺言。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;explicit&quot;&gt;&lt;/a&gt;问题应明晰&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人(假如只是因为他们承担了大多数工作的话)，这些 人 对于没 有限制的时间无底洞极其反感，所以他们也倾向于讨厌那些漫无边际的问题。&lt;/p&gt;
&lt;p&gt;如果你明确了想让回复者做的事(如指点方向、发送代码、检查补丁或其它)，你更有可能得到有用的回复。这可以使他们集中精力并间接地设定了他们为帮 助你需要花费的时间和精力上限，这很好。&lt;/p&gt;
&lt;p&gt;要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很 忙的专家 那里得到回答。&lt;/p&gt;
&lt;p&gt;所以限定你的问题以使专家回答时需要付出的时间最少──这通常还与简化问题不一样。举个例，&amp;ldquo;请问可否指点一下哪有好一点的X解释？&amp;rdquo;通常要 比&amp;ldquo;请解释一下X&amp;rdquo;明智。如果你有什么代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;homework&quot;&gt;&lt;/a&gt;别张贴家庭作业&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;黑客们善于发现&amp;ldquo;家庭作业&amp;rdquo;式的问题。我们大多数人已经做了自己的家庭作业，那是&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;该你&lt;/span&gt;做的，以便从其经历中学习。问一                     下提示没有关系，但不是要求完整的解决方案。&lt;/p&gt;
&lt;p&gt;如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，尝试在用户组论坛或(作为最后一招)在项目的&amp;ldquo;用户&amp;rdquo;邮件列表或论坛中提问。尽管 黑客们会看出来，一些高级用户也许仍会给你提示。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;prune&quot;&gt;&lt;/a&gt;删除无意义的问题&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;抵制在求助消息末尾加上诸如&amp;ldquo;有人能帮我吗？&amp;rdquo;或&amp;ldquo;有没有答案？&amp;rdquo;之类在语义上无任何意义东西的诱惑。第一，如果问题描述还不完整，这些附 加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如&amp;ldquo;是的，你可 以得到帮助&amp;rdquo;和&amp;ldquo;不，没有给你的帮助&amp;rdquo;&lt;/p&gt;
&lt;p&gt;一般来说，避免提&amp;ldquo;是或否&amp;rdquo;类型的问题，除非你想得到 &lt;a href=&quot;http://homepages.tesco.net/%7EJ.deBoynePollard/FGA/questions-with-yes-or-no-answers.html&quot; target=&quot;_top&quot;&gt;&amp;ldquo;是或否&amp;rdquo;类型的回答&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;urgent&quot;&gt;&lt;/a&gt;不要刻意标明问题紧急&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这是你自己的问题，不要我们的。宣称&amp;ldquo;紧急&amp;rdquo;极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关 照。&lt;/p&gt;
&lt;p&gt;有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌 地提到这点，人们也许会有足够的兴趣快一点回答。&lt;/p&gt;
&lt;p&gt;当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原 因这样做几乎肯定不行。事实上，张贴诸如&amp;ldquo;紧急：帮我救救这个毛绒绒的小海豹！&amp;rdquo;肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。&lt;/p&gt;
&lt;p&gt;如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄清楚了再发贴。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;courtesy&quot;&gt;&lt;/a&gt;礼貌总是无害的&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;礼貌一点，使用&amp;ldquo;请&amp;rdquo;和&amp;ldquo;谢谢你的关注&amp;rdquo;或者&amp;ldquo;谢谢你的意见&amp;rdquo;，让别人明白你感谢他们无偿花时间帮助你。&lt;/p&gt;
&lt;p&gt;坦率地说，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要(同时也不能替代它们)。黑客们一般宁可读有点唐突但技术鲜明的臭 虫报告，而不是那种礼貌但含糊的报告。(如果这点让你不解，记住我们是按问题能教我们些什么来评价一个问题的)&lt;/p&gt;
&lt;p&gt;然尔，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。&lt;/p&gt;
&lt;p&gt;(我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的&amp;ldquo;提前谢了&amp;rdquo;，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的 建议是 先说 &amp;ldquo;提前谢了&amp;rdquo;，事后再对回复者表示感谢。或者换种方式表达，譬如用&amp;ldquo;谢谢你的关注&amp;rdquo;或&amp;ldquo;谢谢你的意见&amp;rdquo;)。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;followup&quot;&gt;&lt;/a&gt;问题解决后追加一条简要说明&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比 较恰当。&lt;/p&gt;
&lt;p&gt;最理想的方式是向最初提问的线索回复此消息并在主题包含&amp;ldquo;已解决&amp;rdquo;、&amp;ldquo;已搞定&amp;rdquo;或其它同样意思的明显标记。在人来人往的邮件列表里，一个看见线索 &amp;ldquo;问题X&amp;rdquo;和&amp;ldquo;问题X-已解决&amp;rdquo;的潜在回复者就明白不用再浪费时间了(除非他个人觉得&amp;ldquo;问题X&amp;rdquo;有趣)，因此可以用此时间去解决其它 问题。&lt;/p&gt;
&lt;p&gt;你追加的消息用不着太长太复杂，一条简单的&amp;ldquo;你好──是网线坏了！谢谢大家──比尔&amp;rdquo;就比什么都没有要强。事实上，除 非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。&lt;/p&gt;
&lt;p&gt;对于有深度的问题，张贴排错历史的摘要是适当的。描述问题的最终状态，说明是什么解决了问题，在此&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;之后&lt;/span&gt;才指明可以避免的弯路。应避免的                     弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。&lt;/p&gt;
&lt;p&gt;除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。&lt;/p&gt;
&lt;p&gt;除上述而外，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如 果你自己 不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家非常重要。问题叙述到最后不知所终总是令人沮丧的，黑客们痒                     痒地渴望看到它们被解决。&amp;ldquo;挠痒痒&amp;rdquo;为你挣到的好报将对你下次再次张贴提问非常非常的有帮助。&lt;/p&gt;
&lt;p&gt;考虑一下怎样才能避免其他人将来也遇到类似的问题，问问自己编一份文档或FAQ补丁有没有帮助，如果有的话就将补丁发给维护者。&lt;/p&gt;
&lt;p&gt;在黑客中，这种行为实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2&gt;&lt;a name=&quot;answers&quot;&gt;&lt;/a&gt;如何解读回答&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;rtfm&quot;&gt;&lt;/a&gt;RTFM和STFW：如何知道你已完全搞砸&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;有一个古老而神圣的传统：如果你收到了&amp;ldquo;RTFM&amp;rdquo;的回复，发信人认为你应该去&amp;ldquo;读读该死的手册&amp;rdquo;。他多半是对的，去读一下吧。&lt;/p&gt;
&lt;p&gt;RTFM有个年轻的亲戚，如果你收到&amp;ldquo;STFW&amp;rdquo;的回复，发信人认为你应该&amp;ldquo;搜搜该死的网络&amp;rdquo;。他多半也是对的，去搜一下吧。(更温和一点的说法是 &amp;ldquo;Google 是你的朋友！&amp;rdquo;)&lt;/p&gt;
&lt;p&gt;在网页论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种好心，提问前应先搜索 一下文 档。&lt;/p&gt;
&lt;p&gt;通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为：第一，你要的信息很容易找到。第二，自已找 要比别人喂到嘴里能学得更多。&lt;/p&gt;
&lt;p&gt;你不应该觉得这样就被冒犯了，按黑客的标准，他没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;lesser&quot;&gt;&lt;/a&gt;如果还不明白&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果你看不懂回复，不要马上回发一个要求说明的消息，先试试那些最初提问时用过的同样工具(手册、FAQ，网页、懂行的朋友等)试着搞懂回 复。如果还是需要说明，展现你已经明白的。&lt;/p&gt;
&lt;p&gt;譬如，假如我告诉你：&amp;ldquo;听起来象是某输入项有问题，你需要清除它&amp;rdquo;，接着是个&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;不好&lt;/span&gt;的回帖：&amp;ldquo;什么是某输入项？&amp;rdquo;。                     而这是一个&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;好&lt;/span&gt;的跟帖：&amp;ldquo;是 的， 我读了手册，某输入项只在-z和-p开关中被提到，但都没有提及清除某选项，你指的是哪一个还是我弄错了什么？&amp;rdquo;&lt;/p&gt;
&lt;/div&gt;
&lt;div lang=&quot;en&quot; class=&quot;sect2&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h3 class=&quot;title&quot;&gt;&lt;a name=&quot;keepcool&quot;&gt;&lt;/a&gt;对待无礼&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一刀见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱 的人 是很自然的。&lt;/p&gt;
&lt;p&gt;你如果觉得被冒犯，努力平静地反应。如果有人真的做了过格的事，邮件列表或新闻组或论坛中的前辈多半会招呼他。如果这&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;没有&lt;/span&gt;发生而你却发火了，那么你发火对 象的言语 可能在黑客社区中看起来是正常的，而&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;你&lt;/span&gt;将 被视为有错的一方，这将伤害到你获取信息或帮助的机会。&lt;/p&gt;
&lt;p&gt;另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以 接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线情况并不鲜见。如果你是新 手或外来者，避开这种莽撞的机会不高。如果你 想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。&lt;/p&gt;
&lt;p&gt;(有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，一定缺少平滑人类社会&amp;ldquo;正常&amp;rdquo;交往所需的脑电路。这既可能是真也可能是假。如果你自己不是 黑客，兴许 你认为我                     们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;喜欢&lt;/span&gt;我们现在这个样子，并且一般都对                     临床诊断有相当的怀疑。)&lt;/p&gt;
&lt;p&gt;在下一节，我们会谈到另一个问题，当你行为不当时会受到的&amp;ldquo;冒犯&amp;rdquo;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2&gt;&lt;a name=&quot;not_losing&quot;&gt;&lt;/a&gt;别象个失败者那样反应&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在黑客社区的论坛中有那么几次你会搞砸──以本文详述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。&lt;/p&gt;
&lt;p&gt;这种事发生以后，你能做的最糟的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等 等。相 反，你该这样去做：&lt;/p&gt;
&lt;p&gt;熬过去，这很正常。事实上，它是有益健康与恰当的。&lt;/p&gt;
&lt;p&gt;社区的标准不会自己维持，它们是通过参与者积极而&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;公开&lt;/span&gt;地执行来维持的。不要哭嚎所有的                 批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人批评你的 一些主张或者其看法不同时，坚持声称个人被侮辱也毫无用处，这些都是失败者的态度。&lt;/p&gt;
&lt;p&gt;也有其它的黑客论坛，受太高礼节要求的误导，要求参与者禁止张贴任何对别人帖子挑毛病的消息，并被告知&amp;ldquo;如果你不想帮助用户就闭嘴&amp;rdquo;。有思路的参与 者纷纷 离 开 的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。&lt;/p&gt;
&lt;p&gt;是夸张的&amp;ldquo;友谊&amp;rdquo;(以上述方式)还是有用？挑一个。&lt;/p&gt;
&lt;p&gt;记住：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要 容易得 多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃 那样对你。&lt;/p&gt;
&lt;p&gt;有时候，即使你没有搞砸(或者只是别人想象你搞砸了)， 有些人会无缘无故地攻击你本人。在这种情况下，报怨倒是&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;真的&lt;/span&gt;会把问题搞砸。&lt;/p&gt;
&lt;p&gt;这些找茬者要么是什么也不懂但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理学家。其它读者要么不理睬，要么用自己的方式对付他们。 这些找茬者在给自己找麻烦，这点你不用操心。&lt;/p&gt;
&lt;p&gt;也别让自己卷入口水战，大多数口水战最好不要理睬──当然是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其 中 (这也 是 可能的)之后。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;classic&quot;&gt;&lt;/a&gt;提问禁忌&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;下面是些典型的愚蠢问题和黑客不回答它们时的想法。&lt;/p&gt;
&lt;div class=&quot;qandaset&quot;&gt;&lt;dl&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002488&quot;&gt;我到哪可以找到程序或X资源？ &lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002514&quot;&gt;我怎样用X做Y？&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002537&quot;&gt;如何配置我的shell提示？&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002563&quot;&gt;我可以用Bass-o-matic文件转换工具将AcmeCorp文档转为TeX格式 吗？&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002586&quot;&gt;我的{程序、配置、SQL语句}不运行了&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002626&quot;&gt;我的视窗电脑出问题了，你能帮忙吗？&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002657&quot;&gt;我的程序不运行了，我认为系统工具X有问题&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002681&quot;&gt;我安装Linux或X遇到困难，你能帮忙吗？&lt;/a&gt;&lt;/dt&gt;&lt;dt&gt;问： &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#id3002722&quot;&gt;我如何才能破解超级用户口令/盗取频道操作员的特权/查看某人的电子邮件？&lt;/a&gt;&lt;/dt&gt;&lt;/dl&gt;
&lt;table border=&quot;0&quot; summary=&quot;Q and A Set&quot;&gt;
    &lt;col width=&quot;1%&quot; align=&quot;left&quot; /&gt;
    &lt;tbody&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;问：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002488&quot;&gt;&lt;/a&gt;我到哪可以找到程序或X资源？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;答：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 &lt;a href=&quot;http://www.google.com/&quot;&gt;Google&lt;/a&gt;                                     吗？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;问：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002514&quot;&gt;&lt;/a&gt;我怎样用X做Y？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;答：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;如果你想做的是Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对X完全无知，也对要解决的Y问题糊涂，还被特定形势禁 锢了思维。等他们把问题弄 好再说。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;问：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002537&quot;&gt;&lt;/a&gt;如何配置我的shell提示？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;b&gt;答：&lt;/b&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;如果你有足够的智慧提这个问题，你也该有足够的智慧去 &lt;a href=&quot;file:///home/frank/work/tran/smart-questions-3.0-cn.html#rtfm&quot;&gt;                                         RTFM&lt;/a&gt;， 然后自己去找。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002563&quot;&gt;&lt;/a&gt;我可以用Bass-o-matic文件转换工具将AcmeCorp文档转为TeX格 式吗？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;试试就知道了。如果你试过，你既知道答案，又不用浪费我的时间了。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002586&quot;&gt;&lt;/a&gt;我的{程序、配置、SQL语句}不运行了&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下：&lt;/p&gt;
            &lt;div class=&quot;itemizedlist&quot;&gt;
            &lt;ul type=&quot;disc&quot;&gt;
                &lt;li&gt;
                &lt;p&gt;你还有什么补充吗？&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                &lt;p&gt;噢，太糟了，希望你能搞定。&lt;/p&gt;
                &lt;/li&gt;
                &lt;li&gt;
                &lt;p&gt;这跟我究竟有什么关系？&lt;/p&gt;
                &lt;/li&gt;
            &lt;/ul&gt;
            &lt;/div&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002626&quot;&gt;&lt;/a&gt;我的视窗电脑出问题了，你能帮忙吗？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;是的，把视窗垃圾删了，装个象Linux或BSD的开源操作系统吧。&lt;/p&gt;
            &lt;p&gt;注意：如果程序有官方的视窗版或与视窗有交互(如Samba)，你&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;可以&lt;/span&gt;问与视窗电脑相关的问题，只是别                                     对问题是由视窗操作系统而不是程序本身造成的回复感 到惊讶，因 为视窗一般来说太差，这种说法一般都成立。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002657&quot;&gt;&lt;/a&gt;我的程序不运行了，我认为系统工具X有问题&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需 要不同凡响的证据， 当你这样 声称时，你必须有清楚而详尽的缺陷说明文档作后盾。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;a name=&quot;id3002681&quot;&gt;&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;我安装Linux或X遇到问题，你能帮忙吗？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;不行，我需要亲手操作你的电脑才能帮你排错，去向当地的Linux用户组寻求方便的帮助(你可以在 &lt;a href=&quot;http://www.linux.org/groups/index.html&quot;&gt;                                         这里&lt;/a&gt; 找到用户组列表)&lt;/p&gt;
            &lt;p&gt;注意：在为某一Linux发行版服务的邮件列表或论坛或本地用户组织中提关于安装该发行版的问题也许是恰当的。此时，应描述问题的准确 细节。在此之前，先用 &amp;ldquo;linux&amp;rdquo;和&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;所有&lt;/span&gt;被怀 疑的硬件(为关键词)仔细搜索。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;question&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;问：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;&lt;a name=&quot;id3002722&quot;&gt;&lt;/a&gt;我如何才能破解超级用户口令/盗取频道操作员的特权/查看某人的电子邮件？&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr class=&quot;answer&quot;&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;答：&lt;/span&gt;&lt;/td&gt;
            &lt;td valign=&quot;top&quot; align=&quot;left&quot;&gt;
            &lt;p&gt;想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。&lt;/p&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;examples&quot;&gt;&lt;/a&gt;好问题与坏问题&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后，我将通过举例来演示提问的智慧。同样的问题两种问法，一种愚蠢，另一种明智。&lt;/p&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;愚蠢：我在哪能找到关于Foonly Flurbamatic设备的东西？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;这个问题在乞求得到 &lt;a href=&quot;http://community.csdn.net/IndexPage/SmartQuestion.aspx#rtfm&quot;&gt;STFW&lt;/a&gt; 式的回复。&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;明智：我用Google搜索过&amp;ldquo;Foonly Flurbamatic 2600&amp;rdquo;，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;愚蠢：我不能编译某项目的源代码，它为什 么这么破？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;他假设是别人搞砸了，太自大了。&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;明智：某项目的源代码不能在某Linux 6.2版下编译。我读了常见问题文档，但其中没有与某Linux相关的问题。这是编译时的记录，我做错了什么吗？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;他指明了运行环境，读了FAQ，列出了错误，也没有假设问题是别人的过错，这家伙值得注意。&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;div class=&quot;variablelist&quot;&gt;&lt;dl&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;愚蠢：我的主板有问题，谁能帮我？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;某黑客对此的反应可能是：&amp;ldquo;是的，还需要帮你拍背和换尿布吗？&amp;rdquo;，然后是敲下删除键。&lt;/p&gt;
&lt;/dd&gt;&lt;dt&gt;                         &lt;br /&gt;
&lt;span class=&quot;term&quot;&gt;&lt;span class=&quot;term&quot;&gt;明智：我在S2464主板上试过X、Y和 Z，当它们都失败后，又试了A、B和C。注意我试C时的奇怪症状，显然某某东西正在做某某事情，这不是期望的。通常                             在Athlon MP主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？&lt;/span&gt;&lt;/span&gt;&lt;/dt&gt;&lt;dt&gt;&lt;br /&gt;
&lt;/dt&gt;&lt;dd&gt;
&lt;p&gt;相反地，这个人看来值得回答。他展现了解决问题的能力而不是坐等天上掉馅饼。&lt;/p&gt;
&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;
&lt;p&gt;在最后那个问题中，注意&amp;ldquo;给我一个回复&amp;rdquo;与&amp;ldquo;请帮我看看我还能再做点什么测试以得到启发&amp;rdquo;之间细微但重要的差别。&lt;/p&gt;
&lt;p&gt;事实上，最后那个问题基本上源于2001年8月Linux内核邮件列表(lkml)上的真实事件，是我(Eric)当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。&lt;/p&gt;
&lt;p&gt;通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通 过告诉 他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。&lt;/p&gt;
&lt;p&gt;事后，当我感谢大家并评论这次良好的经历时，一个Linux内核邮件列表的成员谈到，他认为并不是因为我的名字在列表上，而是因为我正确的提问方式 才 得到了答 案。&lt;/p&gt;
&lt;p&gt;黑客们在某种方面是非常不留情面的精英分子。我想他是对的，如果我表现得象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为 对其它 人 提问的指导直接导致了本文的编写。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;id3002966&quot;&gt;&lt;/a&gt;如果没有回复&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果得不到回答，请不要认为我们不想帮你，有时候只是因为小组成员的确不知道答案。没有回复不等于被忽略，当然必须承认从外面很难看出两者的差别。&lt;/p&gt;
&lt;p&gt;一般来说，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。&lt;/p&gt;
&lt;p&gt;还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。&lt;/p&gt;
&lt;p&gt;有许多在线与本地用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。&lt;/p&gt;
&lt;p&gt;还有众多大小商业公司提供签约支持服务(红帽与Linuxcare是两家最出名的，还有许多其它的)。别因为要付点钱才有支持就感到沮丧！毕竟，如 果你车子的 汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。&lt;/p&gt;
&lt;p&gt;象Linux这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比 你还得额外花钱买软件要少得多(而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点)&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;id3003018&quot;&gt;&lt;/a&gt;如何更好地回答 问题&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;                     态度和善一点。&lt;/span&gt;问题带来的压力常使人 显得无礼或愚蠢，其实并不是这样。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;                     对初犯者私下回复。&lt;/span&gt;对那些坦诚犯错 之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找FAQ都不知道。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;                     如果你不确定，一定要说出来！&lt;/span&gt;一个听 起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;                     如果帮不了忙，别妨 碍。&lt;/span&gt;&lt;/span&gt;不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;                     探索性的反问以引出更多的细节&lt;/span&gt;。如 果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。&lt;/p&gt;
&lt;p&gt;尽管对那些懒虫报怨一声RTFM是正当的，指出文档的位置(即使只是建议做个Google关键词搜索)会更好。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;                     如果你决意回答，给 出好的答案。&lt;/span&gt;&lt;/span&gt;当别人正使用错误的工具或不当 的方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。&lt;/p&gt;
&lt;p&gt;&lt;span style=&quot;font-style: italic;&quot;&gt;&lt;span style=&quot;font-weight: bold;&quot;&gt;                     帮助你的社区从问题中 学习。&lt;/span&gt;&lt;/span&gt;当回复一个好问题时，问问自己 &amp;ldquo;如何修改相关文件或FAQ文档以免再次解答同样的问题？&amp;rdquo;，接着再向文档维护者发一份补丁。&lt;/p&gt;
&lt;p&gt;如果你的确是在研究一番后才做出的回答，&lt;span style=&quot;font-weight: bold; font-style: italic;&quot;&gt;展 现你的技巧而不是直接端出结果。&lt;/span&gt;毕竟&amp;ldquo;授                 人以鱼，不如授人以渔&amp;rdquo;。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;id3003109&quot;&gt;&lt;/a&gt;相关资源&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果还需要个人电脑、Unix和互联网如何工作的基础知识，参阅 &lt;a href=&quot;http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/&quot;&gt;                     Unix 和互联网如何工作的基本原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你发布软件或补丁时，尝试按 &lt;a href=&quot;http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html&quot;&gt;                     软 件发布实践&lt;/a&gt; 指南进行。&lt;/p&gt;
&lt;/div&gt;


&lt;div lang=&quot;en&quot; class=&quot;sect1&quot; xml:lang=&quot;en&quot;&gt;
&lt;div class=&quot;titlepage&quot;&gt;
&lt;div&gt;
&lt;div&gt;
&lt;h2 class=&quot;title&quot; style=&quot;clear: both;&quot;&gt;&lt;a name=&quot;id3003139&quot;&gt;&lt;/a&gt;鸣谢&lt;/h2&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Evelyn Mitchell 贡献了一些愚蠢问题样例并启发了编写&amp;ldquo;如何更好地回答问题&amp;rdquo;这一节，Mikhail Ramendik 贡献了一些特别有价值的建议和改进。&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;p&gt;Powered&amp;nbsp;by&amp;nbsp;MessageSoft&amp;nbsp;SMG&amp;nbsp;&lt;/p&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;p&gt;SPAM,&amp;nbsp;virus-free&amp;nbsp;and&amp;nbsp;secure&amp;nbsp;email&amp;nbsp;&lt;/p&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;p&gt;http://www.messagesoft.com&lt;/p&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>12岁小朋友在Google TechTalk上讲解jQuery</title>
   <link href="http://dreambt.github.com/Life/2008/12/11/12-girl-google-techtalk-jquery"/>
   <updated>2008-12-11T12:45:07+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/12/11/12-girl-google-techtalk-jquery</id>
   <content type="html">&lt;p&gt;这两天又看到了一个很不错的国外的资料，show给读者朋友看一看，也许会对您有所帮助和启发。&lt;/p&gt;


&lt;p&gt;下面这段视频是在Youtube上的，内容是一个12岁的小朋友在Google TechTalk上的一次讲座，向听众介绍jQeury，非常有趣，看了这段视频，我想对学习Javascript、编程序有畏惧心理的读者朋友，都可以有信心学好它了。&lt;/p&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;object height=&quot;344&quot; width=&quot;425&quot;&gt;
&lt;param value=&quot;http://www.youtube.com/v/8mwKq7_JlS8&amp;amp;hl=zh_CN&amp;amp;fs=1&amp;amp;rel=0&quot; name=&quot;movie&quot; /&gt;
&lt;param value=&quot;true&quot; name=&quot;allowFullScreen&quot; /&gt;
&lt;param value=&quot;always&quot; name=&quot;allowscriptaccess&quot; /&gt;&lt;embed height=&quot;344&quot; width=&quot;425&quot; allowfullscreen=&quot;true&quot; allowscriptaccess=&quot;always&quot; type=&quot;application/x-shockwave-flash&quot; src=&quot;http://www.youtube.com/v/8mwKq7_JlS8&amp;amp;hl=zh_CN&amp;amp;fs=1&amp;amp;rel=0&quot;&gt;&lt;/embed&gt;&lt;/object&gt;


&lt;p&gt;&amp;nbsp;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;关于Google TechTalk：&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;Google TechTalk 是由Google邀请和赞助的一系列演讲，每次都是在Google总部加利福尼亚山景城举行。这些演讲者将会涉及不同的领域，包括技术或更为抽象的领域，已经建立起来或者具有前瞻性的理论。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;关于这次讲演者（6年级的小学生）：&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://dmitri.nfshost.com/blog/&quot;&gt;&lt;font color=&quot;#cc0000&quot;&gt;Dmitri Gaskin&lt;/font&gt;&lt;/a&gt; 是一位 jQuery 和 Drupal （世界最著名的CMS系统之一）方面的专家，兴趣包括Drupal, PHP, JavaScript 和 jQuery。他对jQuery 和 Drupal 两个开源项目都有诸多贡献。在 Drupal 项目中，他在Drupal负责安全的团队中维护着几个模块，以及核心Patch。Dmitri已经多次被邀请讲授关于 Drupal 和 jQuery, 包括 Logitech, Drupalcon 和 广播中的节目。他在不写程序的时候，喜欢演奏现代音乐和作曲。&lt;/p&gt;


&lt;p&gt;======================================&lt;/p&gt;


&lt;p&gt;看了这个小朋友的事迹，加油吧，朋友们！&lt;/p&gt;


&lt;p&gt;另外，听了这个小朋友的讲解，我们才发现，我们总是把jQuery读成&amp;ldquo;JQ瑞&amp;rdquo;，其实应该读为&amp;ldquo;J盔瑞&amp;rdquo;。不知是不是还有像我们一样，读错了query这个单词的朋友。不过这个词真不好读。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>char与varchar数据类型转化的奇怪问题</title>
   <link href="http://dreambt.github.com/Database/2008/11/21/char-varchar"/>
   <updated>2008-11-21T09:45:02+08:00</updated>
   <id>http://dreambt.github.com/Database/2008/11/21/char-varchar</id>
   <content type="html">&lt;p&gt;今天写jsp留言板时遇到一个奇怪的问题，其实以前也遇见过。当时只是很郁闷，现在我仔细研究了一下。先分享如下：&lt;/p&gt;

&lt;div class=&quot;codeText&quot;&gt;
&lt;div class=&quot;codeHead&quot;&gt;jsp代码&lt;/div&gt;
&lt;ol class=&quot;dp-j&quot;&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;&lt;span&gt;PassWord=request.getParameter(&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;psw&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; sql=&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;select Upws from [User] where Uname='&quot;&lt;/span&gt;&lt;span&gt;+UserName+&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;'&quot;&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; rs=stmt.executeQuery(sql); &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; rs.next(); &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; PassWord3=rs.getString(&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;Upws&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;&lt;span&gt; (PassWord.equals(PassWord3)&lt;/span&gt;&lt;span&gt;) { &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt; session.setAttribute(&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;ADMIN&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;enable&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt;} &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;span&gt; { &lt;/span&gt;&lt;/li&gt;
    &lt;li class=&quot;alt&quot;&gt;&lt;span&gt; session.setAttribute(&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;ADMIN&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;disable&quot;&lt;/span&gt;&lt;span&gt;); &lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;} &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;


&lt;p&gt;当数据库中的Upws为char型时，可能会出现多一个或多个空格的问题，导致登录失败。&lt;/p&gt;

&lt;p&gt;因此，我们应该优先考虑使用varchar型数据。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>莫名其妙的Error reading data from static cursor cache</title>
   <link href="http://dreambt.github.com/Database/2008/11/14/error-reading-data-from-static-cursor-cache"/>
   <updated>2008-11-14T09:11:24+08:00</updated>
   <id>http://dreambt.github.com/Database/2008/11/14/error-reading-data-from-static-cursor-cache</id>
   <content type="html">&lt;div&gt;JDBC连接SQL执行select语句，当SQL SERVER表中有text类型字段，并且字段中的内容为空时，就会出现 &amp;ldquo;Error reading data from static cursor cache&amp;rdquo; 错误。&lt;br /&gt;&lt;br /&gt;解决方法 ：&lt;br /&gt;1、保证text字段内容都不为空&lt;br /&gt;2、如果一定有空的话，存放个空格字符&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>任何Web开发人员需要必备的技巧</title>
   <link href="http://dreambt.github.com/Web Design/2008/09/15/web-developers-need-the-necessary-skills"/>
   <updated>2008-09-15T16:52:42+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2008/09/15/web-developers-need-the-necessary-skills</id>
   <content type="html">&lt;p&gt;开发Web应用程序的技术已经变得更成熟、更复杂了。现在，构建一个Web应用程序不仅仅需要简单的HTML技术了。数据库访问、脚本语言和管理都是一个Web程序员需要具备的技术。让我们来看看要成为一个市场上受欢迎的Web开发人员都需要些什么技能吧。&lt;/p&gt;

&lt;p&gt;自从CERN（欧洲粒子物理研究所），日内瓦附近的高能物理研究中心，在1991年发布了Web以来，Web技术已经从静态的内容和Common Gateway Interface（CGI）发展成servlet技术和JavaServer Pages了。然而，在这个竞争更激烈的社会中，一个Web程序员需要更多的知识。例如，如果在面试中，你提到你熟悉XML并在JNDI方面有些经验（这两种技术初看似乎同Web编程没有很紧密的关系），那么你就会给你未来的老板留下更深的印象。设想你已经了解了Java编程语言和面向对象的编程，下面还有两组技术是一个Web开发人员日常工作中所需要的。第一组包括每个Web程序员必须具备的技术。第二组包含要想成为一个高级程序员所应该掌握的技术。&lt;/p&gt;

&lt;p&gt;基本技能
如果想称自己是个Web开发人员，下面就是必须具备的技术。&lt;/p&gt;

&lt;p&gt;HTML（HyperText Markup Language）
HTML几乎是显示在浏览器上所有内容的语言。难怪HTML就好像是一个Web程序员的生存本能一样。如果你仍需要在你的HTML中查找&lt;tr&gt;或&lt;b&gt;，那么你真的需要提高你的HTML技术了。HTML的当前版本是4.01，你可以从http://www.w3.org/TR/1999/REC-html401-19991224/了解更多关于它的内容。&lt;/p&gt;

&lt;p&gt;Servlets和JSP
Java servlet技术是开发Java Web应用程序的主要技术。它是由Sun Microsystems在1996年开发的，当前的版本是2.3，但人们正在为版本2.4做准备。&lt;/p&gt;

&lt;p&gt;JSP是servlet技术的扩展，现在的版本是1.2（2.0版将很快定下来）。有人认为JSP是servlets的替代，但实际并不是这样的。Servlets和JSP是一起用于复杂的Web应用程序的。&lt;/p&gt;

&lt;p&gt;用Java进行Web编程的一个好的开端就是学习servlet技术。即使你打算在你的Web应用程序中只运用JSP页面，你仍需要学习servlet技术。在更复杂的Web应用程序中，JSP页面只用于显示，而JavaBeans和自定义标签库用来嵌入商业逻辑。即：你也必须精通JavaBeans和自定义标签库。&lt;/p&gt;

&lt;p&gt;JavaScript
JavaScript是运行于所有的主要的浏览器中的脚本语言。你用JavaScript来进行客户端的编程。客户端编程中最重要的工作就是确认用户输入。运用客户端输入验证的好处是减少服务器的工作量并提高响应时间。另外，JavaScript可以用于重新定向（redirection）、cookie处理、控制applets、创建导航树、打开一个浏览器的一个新的实例、等等。&lt;/p&gt;

&lt;p&gt;SQL（Strutured Query Language）和JDBC（Java Database Connectivity）
如今，大多数Web应用程序都包括访问关系数据库中的数据。作为一个Web程序员，你需要知道如何存储、得到并操作数据库中的数据。有时侯，你也需要设计数据库，构建数据库中的表和其它结构。SQL就是用来操作数据库中数据的语言。你通常需要编写SQL语句（常常是动态的），把它们传递到数据库服务器，并得到返回的数据（如果有的话）。&lt;/p&gt;

&lt;p&gt;运用Java语言，你需要用JDBC来帮助Web应用程序和数据库服务器进行通讯。JDBC有两部分：JDBC Core API（Application Programming Interface)和JDBC Optional Package API。第一组用来执行基本的数据操作，如创建一个连接或读取、更新并删除一个表中的记录。第二组提供更高级的数据库连接功能，如连接池、事务和RowSet。JDBC的当前版本是3.0，API包含在J2SE v. 1.4中。&lt;/p&gt;

&lt;p&gt;Web Container管理和应用程序部署
你的servlets和JSP页面在一个叫做servlet/JSP container或Web container的引擎中运行。你至少需要知道如何为测试以及生产运行部署你的Web资源。例如，如果你运用Tomcat，你需要了解的一件事就是如何映射配置文件（server.xml）中的应用程序，使Tomcat知道如何调用你的JSP页面。另外，你需要知道在哪里保存你的库以及如何创建应用程序部署描述符。&lt;/p&gt;

&lt;p&gt;XML（eXtensible Markup Language）
XML是计算机领域中一个成功的后起之秀。由World Wide Web Consortium在1996年开发，XML现在已经是用于数据交换和可扩展数据结构的一个广泛的、公认的标准了。XML在Java Web开发中扮演着一个重要的角色。例如，每个应用程序的部署描述符都是XML格式的。而且，如果你在开发Web servies，你就会用到SOAP（Simple Object Access Protocol），它主要是基于HTTP和XML的。&lt;/p&gt;

&lt;p&gt;另外，在Web应用程序中，XML也可能用于存储分等级的数据。&lt;/p&gt;

&lt;p&gt;Model 2结构
这种技术在该类别中是最先进的。建议用这种结构来构建相当复杂的Java Web应用程序。Model 2结构是基于Model-View-Controller设计范例的。&lt;/p&gt;

&lt;p&gt;高级技术
下面这些技术可以将你同初学者区别开来。&lt;/p&gt;

&lt;p&gt;JSTL（JSP Standard Tag Libraries）、Jakarta Taglibs项目和其它库
为了加速应用程序的开发，你应该经常重用代码。简单地说，代码重用就是，如果有人已经编写了用来执行某些功能的代码，你最好就去用那些代码，而不要自己编写了。因此，JSP可以让你运用自定义标签。你可以运用几个库，最受欢迎的是Apache的Jakarta Taglibs项目中的库。从http://jakarta.apache.org/taglibs/index.html 可以下载这个包，你在开始创建新类前，可以运用在这个包中找到的任何现成的东西。&lt;/p&gt;

&lt;p&gt;JSTL最近已经成为了一个标准。其它标签库可以免费或以商业方式得到。&lt;/p&gt;

&lt;p&gt;Apache的Struts项目
Struts是一个Apache赞助的公共资源项目，它为构建Model 2 Java Web应用程序提供了一个构架。Struts为MVC结构提供它自己的Controller组件，将EJB、JDBC和JNDI用于Model，将JSP和其它技术用于View。你可以从它的网站找到更多关于这个项目的更详细的信息：http://jakarta.apache.org/struts/index.html。&lt;/p&gt;

&lt;p&gt;XHTML（Extensible HyperText Markup Language）
XHTML是努力将HTML和XML结合起来的一种技术。你可以把XHTML当作下一代的HTML。其当前的版本是1.0（第二版是于2002年8月1日发布的），XHTML还没有像HTML那么流行，但它在将来会发挥更重要的作用。根据Web设计专家Molly Holzschlag的观点，推动各个公司转向XHTML的主要原因是美国的关于公开访问（accessibility）的法律。更多关于XHTML的信息，参阅Holzschlag访谈。&lt;/p&gt;

&lt;p&gt;DHTML（动态HTML）
DHTML可以允许人们在你的网站上进行更多的交互。例如，运用DHTML，当用户移动鼠标到一个链接上时，你就可以很容易地创建并显示子菜单。运用DHTML的最大的挑战是创建跨浏览器的页面。的确，在理论上，页面设计应该是由美工处理的，其中动态的HTML是通过运用一个工具而产生的。然而，一个Web程序员通常要负责集成所有的部分，如果在页面中生成的代码被破坏了，你就需要了解DHTML来修理它。&lt;/p&gt;

&lt;p&gt;Applet 编程
Applets曾经在提供交互性方面很重要，尤其在DHTML出现前。现在，applets的作用被削减了，更多的程序员已经不用applets了。Microsoft决定在它的新浏览器中不为applets提供缺省的支持极大地削减了applets在Web应用程序中的作用。然而，applets并没有消亡。对于某些任务，如显示新闻标题，applets仍然是不可替代的，而且applets不会产生另人头痛的跨浏览器兼容方面的问题。&lt;/p&gt;

&lt;p&gt;HTTP协议
Java Web程序员通常运用比HTTP更高的协议，如运用servlet和JSP APIs。这些APIs隐藏了HTTP协议的复杂性。因此，你仍可以构建重要的应用程序而不需要知道多少关于HTTP协议的知识。只有当你需要处理原始数据，比如将文件作为附件上载或传送时，你才需要更多关于协议的知识。&lt;/p&gt;

&lt;p&gt;EJB（Enterprise JavaBeans）
EJB是J2EE的一部分，当可扩展性和强大性是你的Web应用程序的主要需求时，EJB就很重要。在当前规范（EJB 2.0）中有三种类型的EJBs：会话（session）EJBs、实体（entity）EJBs和消息驱动的（message driven）EJBs。新的规范，2.1版，正在设计中。&lt;/p&gt;

&lt;p&gt;JNDI（Java Naming and Directory Interface）
当你在开发企业beans时，JNDI很重要，因为对一个EJB的访问是通过JNDI的命名服务完成的。运用一个命名服务来查找与一个特定名字相关的一个对象。在EJB context中，一个命名服务找到一个企业bean，给定这个bean的名字。因此，了解JNDI在开发一个EJB应用程序中是至关重要的。另外，JDBC可以用JNDI来访问一个关系数据库。&lt;/p&gt;

&lt;p&gt;其它工具
了解在哪里可以找到特定的支持工具通常有助于的你的事业的发展。例如，如果你碰巧被分配去做关于基准的任务，那么你如果知道你可以从Apache的Jakarta Project下载Jmeter，你就会很高兴。另外，如果你需要以PDF格式发送输出结果，建议你从http://www.lowagie.com/iText/ 运用可以免费下载的Java-PDF库。Internet技术范围很广而且发展很快。这就是说，作为一个Web程序员，你应该时时留心业界出现了什么新技术，发生了什么大事。在这个方面，没有什么比Internet本身更伟大的资源了。&lt;/b&gt;&lt;/tr&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>通用SQL数据库查询语句精华使用简介</title>
   <link href="http://dreambt.github.com/Database/2008/09/15/sql"/>
   <updated>2008-09-15T08:46:18+08:00</updated>
   <id>http://dreambt.github.com/Database/2008/09/15/sql</id>
   <content type="html">&lt;p&gt;&lt;strong&gt;一、 简单查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单的Transact-SQL查询只包括选择列表、FROM子句和Where子句。它们分别说明所查询列、查询的表或视图、以及搜索条件等。&lt;/p&gt;

&lt;p&gt;例如，下面的语句查询testtable表中姓名为“张三”的nickname字段和email字段。&lt;/p&gt;

&lt;p&gt;[code]　　Select nickname,email
　　FROM testtable
　　Where name='张三'[/code]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(一) 选择列表&lt;/strong&gt;
　　
选择列表(select_list)指出所查询列，它可以是一组列名列表、星号、表达式、变量(包括局部变量和全局变量)等构成。
　　
1、选择所有列
　　
例如，下面语句显示testtable表中所有列的数据：&lt;/p&gt;

&lt;p&gt;[code]　　Select *
　　FROM testtable[/code]&lt;/p&gt;

&lt;p&gt;2、选择部分列并指定它们的显示次序
　　
查询结果集合中数据的排列顺序与选择列表中所指定的列名排列顺序相同。例如：&lt;/p&gt;

&lt;p&gt;[code]　　Select nickname,email
　　FROM testtable[/code]&lt;/p&gt;

&lt;p&gt;3、更改列标题
　　
在选择列表中，可重新指定列标题。定义格式为：&lt;/p&gt;

&lt;p&gt;[code]　　列标题=列名
　　列名 列标题[/code]&lt;/p&gt;

&lt;p&gt;如果指定的列标题不是标准的标识符格式时，应使用引号定界符，例如，下列语句使用汉字显示列标题：&lt;/p&gt;

&lt;p&gt;[code]　　Select 昵称=nickname,电子邮件=email
　　FROM testtable[/code]&lt;/p&gt;

&lt;p&gt;4、删除重复行
　　
Select语句中使用ALL或DISTINCT选项来显示表中符合条件的所有行或删除其中重复的数据行，默认为ALL。使用DISTINCT选项时，对于所有重复的数据行在Select返回的结果集合中只保留一行。
　　
5、限制返回的行数
　　
使用TOP n [PERCENT]选项限制返回的数据行数，TOP n说明返回n行，而TOP n PERCENT时，说明n是表示一百分数，指定返回的行数等于总行数的百分之几。例如：&lt;/p&gt;

&lt;div class=&quot;UBBPanel&quot;&gt;&lt;div class=&quot;UBBTitle&quot;&gt;&lt;img src=&quot;images/code.gif&quot; style=&quot;margin:0px 2px -3px 0px&quot; alt=&quot;程序代码&quot;/&gt; 程序代码&lt;/div&gt;&lt;div class=&quot;UBBContent&quot;&gt;Select TOP 2 *FROM testtable Select TOP 20 PERCENT * FROM testtable&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;(二) FROM子句&lt;/strong&gt;
　　
FROM子句指定Select语句查询及与查询相关的表或视图。在FROM子句中最多可指定256个表或视图，它们之间用逗号分隔。
　　
在FROM子句同时指定多个表或视图时，如果选择列表中存在同名列，这时应使用对象名限定这些列所属的表或视图。例如在usertable和citytable表中同时存在cityid列，在查询两个表中的cityid时应使用下面语句格式加以限定：&lt;/p&gt;

&lt;p&gt;[code]　　Select username,citytable.cityid
　　FROM usertable,citytable
　　Where usertable.cityid=citytable.cityid[/code]&lt;/p&gt;

&lt;p&gt;在FROM子句中可用以下两种格式为表或视图指定别名：&lt;/p&gt;

&lt;p&gt;[code]　　表名 as 别名
　　表名 别名[/code]&lt;/p&gt;

&lt;p&gt;例如上面语句可用表的别名格式表示为：&lt;/p&gt;

&lt;p&gt;[code]　　Select username,b.cityid
　　FROM usertable a,citytable b
　　Where a.cityid=b.cityid[/code]&lt;/p&gt;

&lt;p&gt;Select不仅能从表或视图中检索数据，它还能够从其它查询语句所返回的结果集合中查询数据。例如：&lt;/p&gt;

&lt;p&gt;[code]　　Select a.au_fname+a.au_lname
　　FROM authors a,titleauthor ta
　　(Select title_id,title
　　FROM titles
　　Where ytd_sales&gt;10000
　　) AS t
　　Where a.au_id=ta.au_id
　　AND ta.title_id=t.title_id[/code]&lt;/p&gt;

&lt;p&gt;此例中，将Select返回的结果集合给予一别名t，然后再从中检索数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(三) 使用Where子句设置查询条件&lt;/strong&gt;
　　
Where子句设置查询条件，过滤掉不需要的数据行。例如下面语句查询年龄大于20的数据：&lt;/p&gt;

&lt;p&gt;[code]　　Select *
　　FROM usertable
　　Where age&gt;20[/code]&lt;/p&gt;

&lt;p&gt;Where子句可包括各种条件运算符：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;比较运算符(大小比较)：&gt;、&gt;=、=、&lt; 、&lt;=、&lt;&gt;、!&gt;、!&lt; &lt;/li&gt;&lt;/li&gt;&lt;li&gt;NOT BETWEEN…AND…
&lt;/li&gt;&lt;li&gt;列表运算符(判断表达式是否为列表中的指定项)：IN (项1,项2……)
&lt;/li&gt;&lt;li&gt;NOT IN (项1,项2……)
&lt;/li&gt;&lt;li&gt;模式匹配符(判断值是否与指定的字符通配格式相符):LIKE、NOT LIKE
&lt;/li&gt;&lt;li&gt;空值判断符(判断表达式是否为空)：IS NULL、NOT IS NULL
&lt;/li&gt;&lt;li&gt;逻辑运算符(用于多条件的逻辑连接)：NOT、AND、OR
&lt;/li&gt;&lt;/ul&gt;


&lt;p&gt;1、范围运算符例：age BETWEEN 10 AND 30相当于age&gt;=10 AND age&amp;lt; =30
2、列表运算符例：country IN ('Germany','China')
3、模式匹配符例：常用于模糊查找，它判断列值是否与指定的字符串格式相匹配。可用于char、varchar、text、ntext、datetime和smalldatetime等类型查询。&lt;/p&gt;

&lt;p&gt;可使用以下通配字符：&lt;/p&gt;

&lt;p&gt;　　百分号%：可匹配任意类型和长度的字符，如果是中文，请使用两个百分号即%%。
　　下划线_：匹配单个任意字符，它常用来限制表达式的字符长度。
　　方括号[]：指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      [^]：其取值也[] 相同，但它要求所匹配对象为指定字符以外的任一个字符。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　
例如：
　　限制以Publishing结尾，使用LIKE '%Publishing'
　　限制以A开头：LIKE '[A]%'
　　限制以A开头外：LIKE '[&lt;sup&gt;A]%'&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;4、空值判断符例Where age IS NULL
5、逻辑运算符：优先级为NOT、AND、OR&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(四)查询结果排序&lt;/p&gt;

&lt;p&gt;使用ORDER BY子句对查询返回的结果按一列或多列排序。ORDER BY子句的语法格式为：&lt;/p&gt;

&lt;p&gt;　　&lt;div class=&quot;UBBPanel&quot;&gt;&lt;div class=&quot;UBBTitle&quot;&gt;&lt;img src=&quot;images/code.gif&quot; style=&quot;margin:0px 2px -3px 0px&quot; alt=&quot;程序代码&quot;/&gt; 程序代码&lt;/div&gt;&lt;div class=&quot;UBBContent&quot;&gt;ORDER BY {column_name [ASC|DESC]} [,…n]&lt;/div&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;其中ASC表示升序，为默认值，DESC为降序。ORDER BY不能按ntext、text和image数据类型进行排序。例如：&lt;/p&gt;

&lt;p&gt;[code]　　Select *
　　FROM usertable
　　ORDER BY age desc,userid ASC[/code]&lt;/p&gt;

&lt;p&gt;另外，可以根据表达式进行排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、 联合查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;UNION运算符可以将两个或两个以上上Select语句的查询结果集合合并成一个结果集合显示，即执行联合查询。UNION的语法格式为：&lt;/p&gt;

&lt;p&gt;[code]　　select_statement
　　UNION [ALL] selectstatement
　　[UNION [ALL] selectstatement][…n][/code]&lt;/p&gt;

&lt;p&gt;其中selectstatement为待联合的Select查询语句。&lt;/p&gt;

&lt;p&gt;ALL选项表示将所有行合并到结果集合中。不指定该项时，被联合查询结果集合中的重复行将只保留一行。&lt;/p&gt;

&lt;p&gt;联合查询时，查询结果的列标题为第一个查询语句的列标题。因此，要定义列标题必须在第一个查询语句中定义。要对联合查询结果排序时，也必须使用第一查询语句中的列名、列标题或者列序号。&lt;/p&gt;

&lt;p&gt;在使用UNION 运算符时，应保证每个联合查询语句的选择列表中有相同数量的表达式，并且每个查询选择表达式应具有相同的数据类型，或是可以自动将它们转换为相同的数据类型。在自动转换时，对于数值类型，系统将低精度的数据类型转换为高精度的数据类型。&lt;/p&gt;

&lt;p&gt;在包括多个查询的UNION语句中，其执行顺序是自左至右，使用括号可以改变这一执行顺序。例如：&lt;/p&gt;

&lt;p&gt;查询1 UNION (查询2 UNION 查询3)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、连接查询&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过连接运算符可以实现多个表查询。连接是关系数据库模型的主要特点，也是它区别于其它类型数据库管理系统的一个标志。&lt;/p&gt;

&lt;p&gt;在关系数据库管理系统中，表建立时各数据之间的关系不必确定，常把一个实体的所有信息存放在一个表中。当检索数据时，通过连接操作查询出存放在多个表中的不同实体的信息。连接操作给用户带来很大的灵活性，他们可以在任何时候增加新的数据类型。为不同实体创建新的表，尔后通过连接进行查询。&lt;/p&gt;

&lt;p&gt;连接可以在Select 语句的FROM子句或Where子句中建立，似是而非在FROM子句中指出连接时有助于将连接操作与Where子句中的搜索条件区分开来。所以，在Transact-SQL中推荐使用这种方法。&lt;/p&gt;

&lt;p&gt;SQL-92标准所定义的FROM子句的连接语法格式为：&lt;/p&gt;

&lt;p&gt;[code]　　FROM join_table join_type join_table
　　[ON (join_condition)][/code]&lt;/p&gt;

&lt;p&gt;其中join_table指出参与连接操作的表名，连接可以对同一个表操作，也可以对多表操作，对同一个表操作的连接又称做自连接。&lt;/p&gt;

&lt;p&gt;join_type 指出连接类型，可分为三种：内连接、外连接和交叉连接。内连接(INNER JOIN)使用比较运算符进行表间某(些)列数据的比较操作，并列出这些表中与连接条件相匹配的数据行。根据所使用的比较方式不同，内连接又分为等值连接、自然连接和不等连接三种。外连接分为左外连接(LEFT OUTER JOIN或LEFT JOIN)、右外连接(RIGHT OUTER JOIN或RIGHT JOIN)和全外连接(FULL OUTER JOIN或FULL JOIN)三种。与内连接不同的是，外连接不只列出与连接条件相匹配的行，而是列出左表(左外连接时)、右表(右外连接时)或两个表(全外连接时)中所有符合搜索条件的数据行。&lt;/p&gt;

&lt;p&gt;交叉连接(CROSS JOIN)没有Where 子句，它返回连接表中所有数据行的笛卡尔积，其结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。&lt;/p&gt;

&lt;p&gt;连接操作中的ON (join_condition) 子句指出连接条件，它由被连接表中的列和比较运算符、逻辑运算符等构成。&lt;/p&gt;

&lt;p&gt;无论哪种连接都不能对text、ntext和image数据类型列进行直接连接，但可以对这三种列进行间接连接。例如：&lt;/p&gt;

&lt;p&gt;[code]　　Select p1.pub_id,p2.pub_id,p1.pr_info
　　FROM pub_info AS p1 INNER JOIN pub_info AS p2
　　ON DATALENGTH(p1.pr_info)=DATALENGTH(p2.pr_info)[/code]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(一)内连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内连接查询操作列出与连接条件匹配的数据行，它使用比较运算符比较被连接列的列值。内连接分三种：&lt;/p&gt;

&lt;p&gt;1、等值连接：在连接条件中使用等于号(=)运算符比较被连接列的列值，其查询结果中列出被连接表中的所有列，包括其中的重复列。&lt;/p&gt;

&lt;p&gt;2、不等连接： 在连接条件使用除等于运算符以外的其它比较运算符比较被连接的列的列值。这些运算符包括&gt;、&gt;=、&amp;lt; =、&amp;lt;、!&gt;、!&amp;lt; 和&amp;lt;&gt;。&lt;/p&gt;

&lt;p&gt;3、自然连接：在连接条件中使用等于(=)运算符比较被连接列的列值，但它使用选择列表指出查询结果集合中所包括的列，并删除连接表中的重复列。&lt;/p&gt;

&lt;p&gt;例，下面使用等值连接列出authors和publishers表中位于同一城市的作者和出版社：&lt;/p&gt;

&lt;p&gt;[code]　　Select *
　　FROM authors AS a INNER JOIN publishers AS p
　　ON a.city=p.city[/code]&lt;/p&gt;

&lt;p&gt;又如使用自然连接，在选择列表中删除authors 和publishers 表中重复列(city和state)：&lt;/p&gt;

&lt;p&gt;[code]　　Select a.*,p.pub_id,p.pub_name,p.country
　　FROM authors AS a INNER JOIN publishers AS p
　　ON a.city=p.city[/code]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(二)外连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;内连接时，返回查询结果集合中的仅是符合查询条件( Where 搜索条件或 HAVING 条件)和连接条件的行。而采用外连接时，它返回到查询结果集合中的不仅包含符合连接条件的行，而且还包括左表(左外连接时)、右表(右外连接时)或两个边接表(全外连接)中的所有数据行。如下面使用左外连接将论坛内容和作者信息连接起来：&lt;/p&gt;

&lt;p&gt;[code]　　Select a.&lt;em&gt;,b.&lt;/em&gt; FROM luntan LEFT JOIN usertable as b
　　ON a.username=b.username[/code]&lt;/p&gt;

&lt;p&gt;下面使用全外连接将city表中的所有作者以及user表中的所有作者，以及他们所在的城市：&lt;/p&gt;

&lt;p&gt;[code]　　Select a.&lt;em&gt;,b.&lt;/em&gt;
　　FROM city as a FULL OUTER JOIN user as b
　　ON a.username=b.username[/code]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(三)交叉连接&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;交叉连接不带Where 子句，它返回被连接的两个表所有数据行的笛卡尔积，返回到结果集合中的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。例，titles表中有6类图书，而publishers表中有8家出版社，则下列交叉连接检索到的记录数将等于6*8=48行。&lt;/p&gt;

&lt;p&gt;[code]　　Select type,pub_name
　　FROM titles CROSS JOIN publishers
　　ORDER BY type[/code]&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>有关SQL模糊查询</title>
   <link href="http://dreambt.github.com/Database/2008/09/14/sql-fuzzy-query"/>
   <updated>2008-09-14T14:36:13+08:00</updated>
   <id>http://dreambt.github.com/Database/2008/09/14/sql-fuzzy-query</id>
   <content type="html">&lt;p&gt;在进行数据库查询时，有完整查询和模糊查询之分。&lt;/p&gt;

&lt;p&gt;一般模糊语句如下：&lt;/p&gt;

&lt;div class=&quot;UBBPanel&quot;&gt;
&lt;div class=&quot;UBBTitle&quot;&gt;程序代码&lt;/div&gt;
&lt;div class=&quot;UBBContent&quot;&gt;Select 字段 FROM 表 Where 某字段 Like 条件&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;其中关于条件，SQL提供了四种匹配模式：&lt;/p&gt;

&lt;p&gt;1，%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。&lt;/p&gt;

&lt;p&gt;比如 Select * FROM [user] Where u_name LIKE '%三%'&lt;/p&gt;

&lt;p&gt;将会把u_name为“张三”，“张猫三”、“三脚猫”，“唐三藏”等等有“三”的记录全找出来。&lt;/p&gt;

&lt;p&gt;另外，如果需要找出u_name中既有“三”又有“猫”的记录，请使用and条件&lt;/p&gt;

&lt;div class=&quot;UBBPanel&quot;&gt;
&lt;div class=&quot;UBBTitle&quot;&gt;程序代码&lt;/div&gt;
&lt;div class=&quot;UBBContent&quot;&gt;Select * FROM [user] Where u_name LIKE '%三%' AND u_name LIKE '%猫%'&lt;/div&gt;
&lt;/div&gt;


&lt;p&gt;若使用 Select * FROM [user] Where u_name LIKE '%三%猫%'
虽然能搜索出“三脚猫”，但不能搜索出符合条件的“张猫三”。&lt;/p&gt;

&lt;p&gt;2，_： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句：&lt;/p&gt;

&lt;p&gt;比如 Select * FROM [user] Where u_name LIKE '&lt;em&gt;三&lt;/em&gt;'
只找出“唐三藏”这样u_name为三个字且中间一个字是“三”的；&lt;/p&gt;

&lt;p&gt;再比如 Select * FROM [user] Where u_name LIKE '三__';
只找出“三脚猫”这样name为三个字且第一个字是“三”的；&lt;/p&gt;

&lt;p&gt;3，[ ]：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个。&lt;/p&gt;

&lt;p&gt;比如 Select * FROM [user] Where u_name LIKE '[张李王]三'
将找出“张三”、“李三”、“王三”（而不是“张李王三”）；&lt;/p&gt;

&lt;p&gt;如 [ ] 内有一系列字符（01234、abcde之类的）则可略写为“0-4”、“a-e”
Select * FROM [user] Where u_name LIKE '老[1-9]'
将找出“老1”、“老2”、……、“老9”；&lt;/p&gt;

&lt;p&gt;4，[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符。&lt;/p&gt;

&lt;p&gt;比如 Select * FROM [user] Where u_name LIKE '[&lt;sup&gt;张李王]三'&lt;/sup&gt;
将找出不姓“张”、“李”、“王”的“赵三”、“孙三”等；&lt;/p&gt;

&lt;p&gt;Select * FROM [user] Where u_name LIKE '老[&lt;sup&gt;1-4]';&lt;/sup&gt;
将排除“老1”到“老4”，寻找“老5”、“老6”、……&lt;/p&gt;

&lt;p&gt;5，查询内容包含通配符时&lt;/p&gt;

&lt;p&gt;由于通配符的缘故，导致我们查询特殊字符“%”、“_”、“[”的语句无法正常实现，而把特殊字符用“[ ]”括起便可正常查询。据此我们写出以下函数：&lt;/p&gt;

&lt;p&gt;[code]function sqlencode(str)
str=replace(str,&amp;quot;[&amp;quot;,&amp;quot;[[]&amp;quot;) '此句一定要在最前
str=replace(str,&amp;quot;&lt;em&gt;&amp;quot;,&amp;quot;[&lt;/em&gt;]&amp;quot;)
str=replace(str,&amp;quot;%&amp;quot;,&amp;quot;[%]&amp;quot;)
sqlencode=str
end function[/code]&lt;/p&gt;

&lt;p&gt;在查询前将待查字符串先经该函数处理即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>如何成为一个成功的Jsp程序员？</title>
   <link href="http://dreambt.github.com/Java/2008/09/14/how-to-become-a-good-java-developer"/>
   <updated>2008-09-14T10:14:21+08:00</updated>
   <id>http://dreambt.github.com/Java/2008/09/14/how-to-become-a-good-java-developer</id>
   <content type="html">&lt;p&gt;一个普通的错误是把JSP当作简化的 Java。它不是，（事实上, JSP 是简化的 servlets 。）程序员通常试着没有学习要求的支持技巧而 直接学习 JSP 。JSP 是一个衔接技术，并且成功地连接你需要理解的另外的技术。如果你已经知道 Java，HTML 和 Javascript，这意味着 JSP 将确实是简单的。&lt;/p&gt;

&lt;p&gt;需要成为一个成功的 JSP 程序员可以参考这个时间表。请注意下列：&lt;/p&gt;

&lt;p&gt;&lt;em&gt;忽略你已经熟悉的步骤。
&lt;/em&gt;训练的时间只是代表学习好足够的基础时间，这样才能转移到下一步。&lt;/p&gt;

&lt;p&gt;１、建立并且理解你的Web Server。
因为Apache 是免费的并且在大多数平台上工作，为训练目的推荐 Apache。
安装时间：2 天。&lt;/p&gt;

&lt;p&gt;２、保证你理解 HTML / XHTML 。
你将需要了解html基础, 特别是 HTML 布局中的table的使用。XHTML 不久将代替 HTML ，学习 XHTML 的基础是一个好主意。许多程序员通过 HTML IDE 学习 HTML ( 集成开发环境 ) 。因为大多数 HTML IDE产生混乱的HTMl语法，所以花时间学习手工写作html是很有必要的。因 为你将会使用 JSP 和 HTML 混合编程，精通HTML语法是重要的。所以，你必须能流利地写 HTML 。
训练时间：2 ～ 4 个星期。&lt;/p&gt;

&lt;p&gt;３、开始学习 Java 。
开始学习 Java 1.4 理解 Java 基础是很重要的。不用担心学习Swing或 Java 的图形方面，因为在JSP 中你不会使用这些特征。集中精力 在 Java 工作的细节，学习 Java 的逻辑，也在 Java Bean上花时间。学习Applet是好的, 但是就象Swing， JSP 的大多数应用将不使用小程 序。
训练时间：3 ～ 6 个星期。&lt;/p&gt;

&lt;p&gt;３、学习 JavaScript
学习怎么将 JavaScript在HTML中验证输入的Form元素。也学习 JavaScript怎么能在一 HTML 页以内修改Form的元素。最后要求你能从一
HTML 页内的事件中触发 JavaScript Function。
训练时间：一～ 2 个星期。&lt;/p&gt;

&lt;p&gt;４、学习并且理解你的Web Server的更好的细节。
熟悉Web Server的特征，这是很重要的。
训练时间：2 天。&lt;/p&gt;

&lt;p&gt;５、建立你的 JSP Server
我推荐以Tomcat开始。它可以很好地运行JSP程序。当你不能在生产使用Tomcat时，学习尽可能多的知识以便于更好的运行程序。另外, 许多 JSP 程序员使用Tomcat。因此当你遇到一个问题时，你将容易发现帮助。
安装时间：一～ 2 天。&lt;/p&gt;

&lt;p&gt;６、开始学习 JSP 。
基本的 JSP 学习通过的步骤 1到步骤6可以完成, 然后使用 JSP 对象和脚本写 JSP 程序来联系。学习 JSP 的另外一个方面可以学习怎么创建一个分布式的应用程序。
训练时间：4 ～ 6 个星期。&lt;/p&gt;

&lt;p&gt;７、学习更多的 JSP server。
没有关于更多的 JSP Server当然也可以运行jsp程序。然而, 许多 JSP server都由自己特殊的特征，可以让你更好的理解你的JSP 工程。
学习更多的Jsp server如何处理jsp程序是有必要的。同样也可以优化你的 JSP 应用程序，并且使之运行得更快而不出任何问题。
训练时间：2 ～ 7 天。&lt;/p&gt;

&lt;p&gt;８、 学习 JDBC 。
JSP 大多数应用将使用数据库，JDBC 被用于数据库连接。经常忽略的一个事实就是，每个 JDBC Driver 所支持的东西是相当不同的。了 解并熟悉在jsp工程上被使用的 JDBC driver的细节是很重要的。（有时这部分的学习被包含在前面 Java 或JSP的学习中了 。）
训练时间：1～ 2 个星期。&lt;/p&gt;

&lt;p&gt;到现在，你已经成为了熟练的 JSP 程序员。仍然有很多需要学习，你可以考虑扩展你的知识比如 DHTML ， XML ，java证书， JSP Tag Libraries 或 Servlets , 看你想要造什么类型的网站而决定了。&lt;/p&gt;

&lt;p&gt;这些训练是JSP 的核心。你不必都学习上面所有的, 取决于你在工程中分配到什么任务和你已经有什么知识。但是这是我成功地训练程序员 的时间表。关键的单元是时间。平均的说, 5 个月时间确实能够训练一个人 ( 从开始到完成 ) 成为一个对jsp熟悉程序员。5 个月时间似乎很长，但要成为一个资深的WEB程序员所学的东西远远不止这一些。&lt;/p&gt;

&lt;p&gt;也许你认为这样学习一种语言花费的时间太长了，因为学 ASP 会更快、时间会更短。 但是学习 ASP 不需要学习java的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>网站开发的流程</title>
   <link href="http://dreambt.github.com/Web Design/2008/09/06/website-development-process"/>
   <updated>2008-09-06T17:05:51+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2008/09/06/website-development-process</id>
   <content type="html">&lt;p&gt;最近在构思一个新思路的站点，无意中搜索到了这篇好文。&lt;/p&gt;

&lt;p&gt;思路清晰自然，配图张张经典，同时可以向学习一下标准的建站流程。&lt;/p&gt;

&lt;p&gt;开发过程中的几个角色：程序员，网页设计师，美工设计师，网站策划师和客户；&lt;/p&gt;

&lt;p&gt;下面图片中用&lt;/p&gt;

&lt;ul&gt;
    &lt;li&gt;designer来统一描述网页设计师，美工设计师，网站策划师&lt;/li&gt;
    &lt;li&gt;programmer 程序员&lt;/li&gt;
    &lt;li&gt;client 客户&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;步骤1：项目讨论
在接到项目后首先需要开项目开发讨论会，讨论网站的栏目，开发方向，文字内容和图片等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/57333625bb2c/9u3gi3o4.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤2：激发灵感
网站策划师考虑网站结构，根据客户需求整理材料，组织文字；美工设计师则要认识客户中心思想要体现的内容，按客户需求展开创意的灵感。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/12235625bb2d/407611ky.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤3：框架导航
程序员和设计师具体讨论网站整体制作&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/50458625bb2e/phtx7t0l.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤4：项目计划
整个项目组确定项目大概工作量和所需的时间，写成项目计划书给客户看。这项工作通常由项目经理来做，俗称“老大”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/90585625bb2f/l2fxhgw9.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤5：设计初稿
美工设计师作最基本的设计工作，主页和主要分页。设计师作最基本的设计工作，主页和主要分页。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/85275625bb30/zx1wvjsz.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤6：客户反馈
客户对设计初稿提出建议。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/30261625bb31/m58lmnaw.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤7：重新设计
跟据客户对设计初稿建议和项目需求，进行修改设计或重新设计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/89888625bb32/qa3whohc.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤8：客户满意
经过：设计初稿-客户反馈-重新设计的过程，最后得到了客户的满意。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/56247625bb33/1shktwhd.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤9：其它页设计
最基本的设计同意, 您就能开始制作站点每个页的布局和设计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/43948625bb33/9cy2z5rq.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤10：客户确认
再一次让客户反馈，得到最后确认。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/66438625bb34/2smpq8ky.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤11：制作HTML
网页设计师将美工设计师制作出的页面，作成HTML页。并由美工设计师确定与设计稿无误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/17086625bb36/4as9cti9.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤12：…和CSS
对网站进行良好的规划，完成CSS和其它工作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/85889625bb36/o9yu2vxs.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤13：交给客户
由程序员完成后台程序，然后再返回网页设计师确认完成后页面，最后交给客户反馈，直到站点完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/57942625bb37/ob75nchy.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤14：测试
项目最后阶段是测试。站点需要进行跨平台测试，解决所技术问题和错误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/97262625bb38/ou0yup1i.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;步骤15：发布
最后收款，完成项目。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/11353625bb39/73z04d1u.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;.......&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/69454625bb39/m99wlkza.jpg&quot; border=&quot;0&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>从技术参数开始全面解读CPU</title>
   <link href="http://dreambt.github.com/Other/2008/09/02/cpu"/>
   <updated>2008-09-02T18:46:43+08:00</updated>
   <id>http://dreambt.github.com/Other/2008/09/02/cpu</id>
   <content type="html">&lt;p&gt;　CPU是PC的核心所在，在以下的文章里面我们从几个与CPU相关的性能参数谈起，使读者初步对CPU有个全面的了解，这样将有助于加深读者对PC的了解。
　　1.CPU的内部结构与工作原理
　　CPU是Central Processing Unit－－中央处理器的缩写，它由运算器和控制器组成，CPU的内部结构可分为控制单元，逻辑单元和存储单元三大部分。CPU的工作原理就象一个工厂对产品的加工过程：进入工厂的原料（指令），经过物资分配部门（控制单元）的调度分配，被送往生产线（逻辑运算单元），生产出成品（处理后的数据）后，再存储在仓库（存储器）中，最后等着拿到市场上去卖（交由应用程序使用）。
　　2.CPU的相关技术参数
　　(1)主频
　　主频也叫时钟频率，单位是MHz，用来表示CPU的运算速度。CPU的主频＝外频×倍频系数。很多人以为认为CPU的主频指的是CPU运行的速度，实际上这个认识是很片面的。CPU的主频表示在CPU内数字脉冲信号震荡的速度，与CPU实际的运算能力是没有直接关系的。当然，主频和实际的运算速度是有关的，但是目前还没有一个确定的公式能够实现两者之间的数值关系，而且CPU的运算速度还要看CPU的流水线的各方面的性能指标。由于主频并不直接代表运算速度，所以在一定情况下，很可能会出现主频较高的CPU实际运算速度较低的现象。因此主频仅仅是CPU性能表现的一个方面，而不代表CPU的整体性能。
　　(2)外频
　　外频是CPU的基准频率，单位也是MHz。外频是CPU与主板之间同步运行的速度，而且目前的绝大部分电脑系统中外频也是内存与主板之间的同步运行的速度，在这种方式下，可以理解为CPU的外频直接与内存相连通，实现两者间的同步运行状态。外频与前端总线(FSB)频率很容易被混为一谈，下面的前端总线介绍我们谈谈两者的区别。
　　(3)前端总线(FSB)频率
　　前端总线(FSB)频率（即总线频率）是直接影响CPU与内存直接数据交换速度。由于数据传输最大带宽取决于所有同时传输的数据的宽度和传输频率，即数据带宽＝（总线频率×数据带宽）/8。外频与前端总线(FSB)频率的区别：前端总线的速度指的是数据传输的速度，外频是CPU与主板之间同步运行的速度。也就是说，100MHz外频特指数字脉冲信号在每秒钟震荡一千万次；而100MHz前端总线指的是每秒钟CPU可接受的数据传输量是100MHz×64bit÷8Byte/bit=800MB/s。
　　(4)倍频系数
　　倍频系数是指CPU主频与外频之间的相对比例关系。在相同的外频下，倍频越高CPU的频率也越高。但实际上，在相同外频的前提下，高倍频的CPU本身意义并不大。这是因为CPU与系统之间数据传输速度是有限的，一味追求高倍频而得到高主频的CPU就会出现明显的“瓶颈”效应——CPU从系统中得到数据的极限速度不能够满足CPU运算的速度。
　　(5)缓存
　　缓存是指可以进行高速数据交换的存储器，它先于内存与CPU交换数据，因此速度很快。L1　Cache（一级缓存）是CPU第一层高速缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般L1缓存的容量通常在32～256KB.
　　L2 Cache（二级缓存）是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频详图，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是512KB，而服务器和工作站上用CPU的L2高速缓存更高达1MB-3MB。
　　(6)CPU扩展指令集
　　CPU扩展指令集指的是CPU增加的多媒体或者是3D处理指令，这些扩展指令可以提高CPU处理多媒体和3D图形的能力。著名的有MMX（多媒体扩展指令）、SSE（因特网数据流单指令扩展）和3DNow!指令集。
　　(7)CPU内核和I/O工作电压
　　从586CPU开始，CPU的工作电压分为内核电压和I/O电压两种。其中内核电压的大小是根据CPU的生产工艺而定，一般制作工艺越小，内核工作电压越低；I/O电压一般都在1.6~3V。低电压能解决耗电过大和发热过高的问题。
　　(8)制造工艺
　　指在硅材料上生产CPU时内部各元器材的连接线宽度，一般用微米表示。微米值越小制作工艺越先进，CPU可以达到的频率越高，集成的晶体管就可以更多。目前Intel的P4和AMD的XP都已经达到了0.13微米的制造工艺，明年将达到0.09微米的制作工艺。
　　了解了CPU的逻辑结构以及一些基本技术参数，我们将全面了解影响CPU性能的有关技术参数。下边还有一些其他相关资料，需要您来了解。
　　1.指令集
　　(1) X86指令集　要知道什么是指令集还要从当今的X86架构的CPU说起。X86指令集是Intel为其第一块16位CPU（i8086）专门开发的，IBM1981年推出的世界第一台PC机中的CPU—i8088（i8086简化版）使用的也是X86指令，同时电脑中为提高浮点数据处理能力而增加的X87芯片系列数学协处理器则另外使用X87指令，以后就将X86指令集和X87指令集统称为X86指令集。虽然随着CPU技术的不断发展，Intel陆续研制出更新型的i80386、i80486直到今天的Pentium Ⅲ（以下简为PⅢ）系列，但为了保证电脑能继续运行以往开发的各类应用程序以保护和继承丰富的软件资源，所以Intel公司所生产的所有CPU仍然继续使用X86指令集，所以它的CPU仍属于X86系列。由于Intel X86系列及其兼容CPU都使用X86指令集，所以就形成了今天庞大的X86系列及兼容CPU阵容。
　　(2) RISC指令集　RISC指令集是以后高性能CPU的发展方向。它与传统的CISC（复杂指令集）相对。相比而言，RISC的指令格式统一，种类比较少，寻址方式也比复杂指令集少。当然处理速度就提高很多了。而且RISC指令集还兼容原来的X86指令集。
　　2.字长
　　电脑技术中对CPU在单位时间内（同一时间）能一次处理的二进制数的位数叫字长。所以能处理字长为8位数据的CPU通常就叫8位的CPU。同理32位的CPU就能在单位时间内处理字长为32位的二进制数据。当前的CPU都是32位的CPU，但是字长的最佳是CPU发展的一个趋势。AMD未来将推出64位的CPU-Atlon64。未来必然是64位CPU的天下。
　　3.IA-32、IA-64架构
　　IA是Intel Architecture（英特尔体系结构）的英语缩写，IA-32或IA-64是指符合英特尔结构字长为32或64位的CPU，其他公司所生产的与Intel产品相兼容的CPU也包括在这一范畴。当前市场上所有的X86系列CPU仍属IA-32架构。AMD即将推出Athlon64是IA-64架构的CPU。
　　4.流水线与超流水线
　　流水线（pipeline）是Intel首次在486芯片中开始使用的。流水线的工作方式就象工业生产上的装配流水线。在CPU中由5~6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5~6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。超流水线（superpiplined）是指某型CPU内部的流水线超过通常的5~6步以上，例如Pentium pro的流水线就长达14步。将流水线设计的步（级）其完成一条指令的速度越快，因此才能适应工作主频更高的CPU。但是流水线过长也带来了一定副作用，很可能会出现主频较高的CPU实际运算速度较低的现象，Intel的奔腾4就出现了这种情况，虽然它的主频可以高达1.4G以上，但其运算性能却远远比不上AMD 1.2G的速龙甚至奔腾III。
　　5.封装形式
　　CPU封装是采用特定的材料将CPU芯片或CPU模块固化在其中以防损坏的保护措施，一般必须在封装后CPU才能交付用户使用。CPU的封装方式取决于CPU安装形式和器件集成设计，从大的分类来看通常采用Socket插座进行安装的CPU使用PGA(栅格阵列)方式封装，而采用Slot x槽安装的CPU则全部采用SEC(单边接插盒)的形式封装。现在还有PLGA(Plastic Land Grid Array)、OLGA(Organic Land Grid Array)等封装技术。由于市场竞争日益激烈，目前CPU封装技术的发展方向以节约成本为主。
　　超频理论篇：4种思路+2种方法+5项注意
　　“超频”在DIYer中是个永恒的话题，每每让CPU的速度提升一些或榨取一点硬件性能的“油水”，他们总会欣喜不已。DIYer就是为了让电脑用得更好，“超频”正是一把利器。随着游戏和大型应用软件的更新换代，电脑相对变慢或者根本“跑不动”都很快成为“残酷的现实”，升级？费用太高！别急，或许超频可以满足你暂时的需要。另外，据调查：电脑中几乎没有配件可以陪伴你三年。就拿笔者来说，2000年组装的“爱机”（i815E＋赛扬600＋128MB SDR）早已升级成（Barton 2600＋ ＋KT600＋512MB DDR），只有显示器还在为笔者服务。既然如此，我们何必让它们拥有那么长的寿命呢（何况“超频”是否不利于CPU还有争论，个人感觉运气成分更多一些）？“超”吧，“折腾”吧，我们会在更“快”中找到更快乐！下面我将从超频思路、超频方法、超频应注意的事项这三个方面简单地谈一下超频，算是一个“预热”！
　　超频思路：CPU主频=外频×倍频。这是一个众所周知的CPU主频计算公式，但这也从根本上为我们提供了“超频”的思路。很明显我们可以通过超外频、超倍频、两者同时超频、降倍频超外频等多种思路来达到超频的目的。以上这四种思路是比较有意义的，也是目前主要采用的。“降外频超倍频”从实质上来并没有什么实际意义，而仅仅是满足了没有体质强健CPU而又想炫耀频率的电脑爱好者一种虚荣而已。
　　四种超频思路
　　第一，超外频 这是目前采用最多的思路。谈到外频就会有标准外频和非标准外频。无论是Intel还是AMD都将100MHz、133MHz、166MHz、200MHz等作为标准外频（66MHz等非主流外频不提，另Intel现在最高的标准外频为266MHz，即1066FSB）。对于一些没有AGP/PCI锁定的主板，最好让CPU工作在标准外频上。提升外频对CPU性能影响很大，使前端总线的吞吐量大为提升，是一条不错的超频思路。
　　第二，超倍频 超倍频是建立在CPU倍频未锁定或已破解的基础上。不过，随着Intel和AMD在CPU Die（内核）上加装保护盖，和新版PCB的使用，这条路将走向没落。
　　第三，两者同时超 这种思路可以较容易使CPU接近极限频率，两者相互协调（并非最高的外频与最高的倍频相结合），在一个合适的条件下使CPU发挥更佳的性能。这种超频模式操作很烦琐，需要有足够的耐心和时间。
　　第四，降倍频超外频 同等频率如果可以通过降倍频超外频达到，通常这种超频模式可以获得更好的性能。现在Intel CPU倍频锁死，而且又有保护盖，这种思路表面上已走到尽头；君不见ASUS等厂商已破解倍频，可以在某一个范围内下调，真可谓“柳暗花明又一村”啊。而AMD的Athlon 64就更为超频用户考虑了，不用做任何改造，可以直接下调CPU倍频。倘若前者技术可以发扬光大，后者能继续保持；谁敢说明天不是康庄大道？！
　　两种超频方法
　　按照上面的思路主要有通过BIOS超频和通过软件超频这么两种方法。BIOS超频需要有一定的BIOS知识（这方面的文章不少，但大部分不太实用，不妨请教老鸟），在超频过程中需要不停地重启才能找到一个理想的状态。这种方法的优点就是不占用系统资源，简单直接。而软件超频需要你对主板的型号有确切地了解，但这还远远不够，需要你对该芯片的频率发生器型号有初步的了解（后面在讲到软件超频时，会详细解释），并且需要软件支持该型号；这种方法常被国内的DIYer称为“鸡肋”，但国外的超频玩家多采用这种方法。相对来说这种方法入门稍难，占用一些系统资源但不用反复重启即可更快地找到理想的超频状态。
　　超频注意事项
　　第一，选材 这里的选材不仅仅指一款核心优异的CPU，它包括更多的配件（主板、内存、硬盘等一系列可能影响超频的配件）的选择。这要求主板具备丰富的BIOS的调节（可逐兆对处理器外频进行线性调节，调节范围较大，能够对CPU、内存、芯片组电压和内存频率调整，最好可固定AGP/PCI频率等等），要求内存具备更高频率品质（如DDR500）或优秀的超频芯片（如Winbond的BH-5内存芯片），此外最好有一块可以稳定工作在更高PCI总线频率下的硬盘。这一切对于超频来说都具有举足轻重的作用，在以后的文章中将会一一展现在读者面前。
　　第二，散热 CPU现在的温度已经高得让人头疼了，尤其在增加电压超频时，更为恐怖的夏天即将来到我们身边，良好的散热便成了超频成功的保障。如何更好地为CPU超频护航，在林林总总的散热器中如何选择“对”的产品，这里所涉及的问题也非三言两语可以讲明白，请关注2005年6月6日出版的《中国电脑教育报》第22期“散热专题”，在该专题中，我们将获得一个全新的整体散热概念，敬请关注！而在“超频应用专题”系列文章的后续会简单的介绍超频所需要的散热系统。（不涉及液冷或压缩机等特殊散热方法，因为这并不适合普通消费者）。
　　第三，辅助手段 为了让CPU工作在更高的频率上，采用一些辅助手段是非常必要的。如对CPU及内存适量加压，一般情况下，只要CPU电压提升幅度控制在25%以内，还是非常安全的。另外，需要锁定AGP/PCI的频率（需主板支持），如果没有该功能，外频最好设定在标准外频下。辅助手段尚有许多，这大多属于超频技巧之类的，以后的文章会陆续介绍。
　　第四，测试稳定性 超频完成后能进入操作系统，并进行简单操作并不意味着超频就成功了，必须要对电脑进行全面的测试（“烤”机），而这里笔者推荐用SuperPi、3Dmark、Pemire95等进行最少两个小时的残酷测试。至于软件的简单使用以后会提到。
　　第五，其他 应该注意的事项着实不少，一一归总起来总是让人感觉介绍的还不够完整，如AMD Athlon 64处理器超频还需要注意系统总线的问题。在下期连载的文章中，笔者将会一一说明，希望读者多一些耐心。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>看后请不要哭，无论你想起了谁</title>
   <link href="http://dreambt.github.com/Life/2008/08/03/do-not-cry"/>
   <updated>2008-08-03T13:37:27+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/08/03/do-not-cry</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/572315f8b82d/d97cmquc.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/808455f8b82e/3rq1xzk6.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/791595f8b82f/thj88lyo.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/396525f8b82f/vwf4kfj1.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/527135f8b82f/u4m5f4cs.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/814735f8b82f/3fcpbbo3.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/461645f8b82f/1a99k69z.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/701355f8b82f/pbpfvkhp.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/789255f8b82f/jhsuzycw.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/817685f8b82d/liorwn8g.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/063585f8b82d/ujiauize.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/305125f8b82d/1zgsqspb.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/144805f8b82d/7211dm6z.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/040605f8b82e/1jf015an.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/640015f8b82e/zvefad2h.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/213445f8b82e/az0diyrg.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/969805f8b82f/bljpxmsz.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/661835f8b82e/ls5e9xsl.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/843545f8b82e/3u0pquo2.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/622515f8b82f/xdsfbocp.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/576805f8b82f/azu4ttxs.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>大学生“三下乡”社会实践有感</title>
   <link href="http://dreambt.github.com/Life/2008/07/28/social-practice-felt"/>
   <updated>2008-07-28T13:12:43+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/07/28/social-practice-felt</id>
   <content type="html">&lt;p&gt;为期七天的“三下乡”社会实践活动圆满结束了，我拖着疲惫的身躯回到久违的学校，开始了紧张有序的数学建模培训。七天里我们赴滨州沾化暑期实践服务团一行八人在张老师和步秋（领队）的带领下，克服了种种不可预见的难题，顺利完成了本次“三下乡”社会实践活动任务。
以下是我在本次“三下乡”社会实践活动中的一些感悟和体会。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:10pt&quot;&gt;体验理想与现实的差距，学会人与人之间的沟通。&lt;/span&gt;&lt;/strong&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/558085f8b3a7/v6mzxmmd.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们到达富国镇以后立即展开了社会实践活动的前期准备工作，经过多方调查，我们了解到当地的实际情况和我们的原定计划还是有一点差距的，于是当天晚上我们召开了紧急会议，重新制订了具体的日程安排。分散下户那天我们同样遇到了一些问题，比如部分村民对我们不够信任、部分村民认为我们是联通的或者是招生的、还有部分村民无法配合我们顺利完成调查问卷，于是我们积极与村民沟通，在了解农村信息化进程的同时让农民也了解了我们。&lt;/p&gt;

&lt;p&gt;&lt;i&gt;感悟一：理想≠现实。好在事是死的，人是活的。我们应该根据实际情况及时调整既定计划，同时我们在制作计划的时候应该尽量多的考虑各种突发事件和相关预案。同时，在我们正式踏入社会之前，提前体验这种理想与现实的差距有助于我们今后的学习和成长。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;i&gt;感悟二：人与人的交往在于心灵的沟通，只有沟通才能认识对方、了解对方，才能更好的实施计划。因此，我们要学会与他人沟通，善于与他人沟通。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:10pt&quot;&gt;骄阳似火，汗水打湿了我们的衣背；困难重重，泪水换来了更加坚定的信念。&lt;/span&gt;&lt;/strong&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/222095f8b3a7/gxrx1qzg.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们的活动安排正好赶在炎热的三伏天里，几乎每天都是骄阳似火，烈日当头。虽然每人都随身携带了一瓶水，但大家谁都舍不得多喝一口，都想留给最需要它的人。有的队员由于专心于填写调查问卷，手臂都被行李袋勒出了血痕，但是我们的队员依然面带微笑继续进行服务工作。每天晚上回到住所的时候，大家的衣服都早已被汗水浸透，来不及洗刷就要为第二天的计划忙碌起来了。与此同时我们也遇到了种种困难，为了尽量少的麻烦当地政府和群众，我们只好想办法自己去克服解决。在独立解决这些问题的实践过程中，我们大家都多多少少的得到了锻炼和提高。七天过后，我们的肤色都要比刚来的时候黑了许多，我的脖子也因为长时间挂带照相机出现了一道明显的“光环”。&lt;/p&gt;

&lt;p&gt;&lt;i&gt;感悟三：意志坚强者无坚不摧。艰苦的条件，恶劣的环境都不能摧毁我们坚定的信念，它们只会让我们意志更加坚强，从中得到更多的锻炼；唯有信念不坚定者才会将自己击败，中途退缩。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;i&gt;感悟四：不经历一番风雨哪能见彩虹？正是因为我们在困难面前挺住了，我们才会有今天的收获。经过了这次磨练，相信大家都会变得更加成熟和坚强。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;font-size:10pt&quot;&gt;朋友不哭，短暂的离别是为了不久后的相聚！&lt;/span&gt;&lt;/strong&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/576315f8b3a8/0sqa2mf5.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;离别的时候总是伤感的，俗话说，“天下没有不散的宴席”。今天我们就要带着无奈和几天来的劳动成果，离开这个刚刚熟悉过来的小村庄，离开我们朝夕相处的团队。七天里我们一起吃饭睡觉、一起下乡走访、一起实践理论知识、一起体验田间生活，我们互相帮助、互相照顾，我们结下了深厚的友谊，我们都舍不得离开彼此。我知道，离别的时候总是那么的伤感，彼此都舍不得离开。但我们还是不得不分别一段时光，强忍住夺眶而出的热泪，道一声朋友再见！
朋友不哭！短暂的离别是为了不久后的相聚。试想，再过几天我们又能相约在校园，我们又可以在一起生活了！&lt;/p&gt;

&lt;p&gt;&lt;i&gt;感悟五：虽然大家在一起仅仅生活了短暂的七天，但是我们却结下了深厚的友谊，我们一起吃的苦流的汗只有我们自己最清楚。不论我们来自哪个专业，不论经过这次实践活动我们收获了多少，我们都是一个优秀的团队，我们永远都是好朋友，我们永远都不会忘记彼此。&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;下面是本次活动的一部分照片，&lt;a target=&quot;_blank&quot; href=&quot;http://www.yupoo.com/albums/share/view?id=ff8080811b76d2a0011b86ff63aa0c9c&quot;&gt;点击查看&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>常用的CSS命名规则</title>
   <link href="http://dreambt.github.com/Web Design/2008/03/21/css-name-rule"/>
   <updated>2008-03-21T09:55:39+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2008/03/21/css-name-rule</id>
   <content type="html">&lt;p&gt;(一)常用的CSS命名规则
　　头：header
　　内容：content/container
　　尾：footer
　　导航：nav
　　侧栏：sidebar
　　栏目：column
　　页面外围控制整体布局宽度：wrapper
　　左右中：left right center
　　登录条：loginbar
　　标志：logo
　　广告：banner
　　页面主体：main
　　热点：hot
　　新闻：news
　　下载：download
　　子导航：subnav
　　菜单：menu
　 子菜单：submenu
　　搜索：search
　　友情链接：friendlink
　　页脚：footer
　　版权：copyright
　　滚动：scroll
　　内容：content
　　标签页：tab
　　文章列表：list
　　提示信息：msg
　　小技巧：tips
　　栏目标题：title
　　加入：joinus
　　指南：guild
　　服务：service
　　注册：regsiter
　　状态：status
　　投票：vote
　　合作伙伴：partner&lt;/p&gt;

&lt;p&gt;(二)注释的写法:
　　/&lt;em&gt; Footer &lt;/em&gt;/
　　内容区
　　/&lt;em&gt; End Footer &lt;/em&gt;/&lt;/p&gt;

&lt;p&gt;(三)id的命名:
　　(1)页面结构
　　容器: container
　　页头：header
　　内容：content/container
　　页面主体：main
　　页尾：footer
　　导航：nav
　　侧栏：sidebar
　　栏目：column
　　页面外围控制整体布局宽度：wrapper
　　左右中：left right center
　　(2)导航
　　导航：nav
　　主导航：mainbav
　　子导航：subnav
　　顶导航：topnav
　　边导航：sidebar
　　左导航：leftsidebar
　　右导航：rightsidebar
　　菜单：menu
　　子菜单：submenu
　　标题: title
　　摘要: summary
　　(3)功能
　　标志：logo
　　广告：banner
　　登陆：login
　　登录条：loginbar
　　注册：regsiter
　　搜索：search
　　功能区：shop
　　标题：title
　　加入：joinus
　　状态：status
　　按钮：btn
　　滚动：scroll
　　标签页：tab
　　文章列表：list
　　提示信息：msg
　　当前的: current
　　小技巧：tips
　　图标: icon
　　注释：note
　　指南：guild
　　服务：service
　　热点：hot
　　新闻：news
　　下载：download
　　投票：vote
　　合作伙伴：partner
　　友情链接：link
　　版权：copyright&lt;/p&gt;

&lt;p&gt;(四)class的命名:
　　(1)颜色:使用颜色的名称或者16进制代码,如
　　.red { color: red; }
　　.f60 { color: #f60; }
　　.ff8600 { color: #ff8600; }
　　(2)字体大小,直接使用&quot;font+字体大小&quot;作为名称,如
　　.font12px { font-size: 12px; }
　　.font9pt {font-size: 9pt; }
　　(3)对齐样式,使用对齐目标的英文名称,如
　　.left { float:left; }
　　.bottom { float:bottom; }
　　(4)标题栏样式,使用&quot;类别+功能&quot;的方式命名,如
　　.barnews { }
　　.barproduct { }
　　注意事项:
　　1.一律小写;
　　2.尽量用英文;
　　3.不加中杠和下划线;
　　4.尽量不缩写，除非一看就明白的单词.
　　主要的 master.css
　　模块 module.css
　　基本共用 base.css
　　布局，版面 layout.css
　　主题 themes.css
　　专栏 columns.css
　　文字 font.css
　　表单 forms.css
　　补丁 mend.css
　　打印 print.css&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SHOW一下我的新本本</title>
   <link href="http://dreambt.github.com/Life/2008/03/15/show-my-new-notebook"/>
   <updated>2008-03-15T11:48:29+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/03/15/show-my-new-notebook</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/4764353eb336/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
具体配置不想透露，因为涉及到安全问题。
给大家看看图片就好了。&lt;/p&gt;

&lt;p&gt;好大的箱子
&lt;img src=&quot;http://pic.yupoo.com/dreambt/6740253eb336/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;电源也不小哦
&lt;img src=&quot;http://pic.yupoo.com/dreambt/7630453eb337/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;贝尔金的宝宝
&lt;img src=&quot;http://pic.yupoo.com/dreambt/5127153eb336/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;DELL人真的很周到，给我准备了这么多东西
&lt;img src=&quot;http://pic.yupoo.com/dreambt/3176253eb336/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用本本看我的博客
&lt;img src=&quot;http://pic.yupoo.com/dreambt/1200853eb4fb/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/0948553eb4f8/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;晚上用的效果也不错哦
&lt;img src=&quot;http://pic.yupoo.com/dreambt/0356753eb4fa/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/5463953eb4f8/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;遥控器哎～～～～～～ &lt;img src=&quot;images/smilies/em16.gif&quot; border=&quot;0&quot; style=&quot;margin:0px 0px -2px 0px&quot; alt=&quot;&quot;/&gt;
&lt;img src=&quot;http://pic.yupoo.com/dreambt/3468653eb4f9/medium.jpg&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;就写这么多吧，关于配置问题，我过一段时间再公布吧&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>归途-终于回家了</title>
   <link href="http://dreambt.github.com/Life/2008/01/27/back"/>
   <updated>2008-01-27T06:00:21+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/01/27/back</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;http://pic.yupoo.com/dreambt/7090053f1494/medium.jpg&quot; alt=&quot;&quot; border=&quot;0&quot; /&gt;
终于回家了
心情异样的激动，但又异样的平静。
说是很矛盾，但又不无道理。
应该考了8门课，5门优秀，马基一般，精读和听说刚刚及格，专英生死未卜。&lt;/p&gt;

&lt;p&gt;回顾也应该是回顾大一的生活吧，大二还没有上完，不好妄加评论。&lt;/p&gt;

&lt;p&gt;刚来这个学校的时候爸妈也嘱咐过我一些问题。比如要我变得性格开朗一些，如果学校里高手如云，虚心向人家学习，如果自己就是那个高手，也别不帮助人家。就今天看来，性格是比以前开朗了，有人说我更呆了 帮了不少人，学习方面的、生活方面的、集体荣誉方面的，我不知道为什么到评奖学金的时候大家对我打分这么低。以后的日子还是归隐吧，闭关修炼一下再出来，免得好心没好报。&lt;/p&gt;

&lt;p&gt;大一过得很快乐，学到的东西不是很多，主要是学了一堆以前会点的的东西。也就C语言对我来说新了点，还好有点语言功底，没有被大家拉在后面。大二又要开语言课了，加油思奇！还有数据结构、电路分析云云，提前准备一下吧&lt;/p&gt;

&lt;p&gt;参加了一个社团，担当了个小角色，组织过一些活动，最后我还是决定要离开。那不是我想要的，我又更多的最求。后来又去给学生会做网站，顺利入围，最后学生会居然让#%￥当头，我晕！再次跳槽。现在去了网站建设兴趣小组，混得一官半职，还算可以，毕竟实力在那放着呢&lt;/p&gt;

&lt;p&gt;回家啦，在学校受的那些气不再去想，不再做那些傻事就是了，何苦呢？！&lt;/p&gt;

&lt;p&gt;祝大家都有一个开心快乐的寒假，别忘了学习哦～！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>一杯水的哲学</title>
   <link href="http://dreambt.github.com/Life/2008/01/26/philosophy-of-a-glass-of-water"/>
   <updated>2008-01-26T21:43:24+08:00</updated>
   <id>http://dreambt.github.com/Life/2008/01/26/philosophy-of-a-glass-of-water</id>
   <content type="html">&lt;p&gt;&lt;img height=&quot;273&quot; src=&quot;http://pic.yupoo.com/dreambt/0502253f1494/medium.jpg&quot; width=&quot;464&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1我们每个人就像一杯水，整个团队就像是大海。&lt;br /&gt;&lt;/strong&gt;你可能有时候会认为你对于团队来说相当重要，你的老板如何的需要你，离开了你就不能运转了。那么这个比喻可以很清楚的告诉你一个简单的道理。我们每个人就像一杯水，整个团队就像是大海。当一杯水放在桌子上的时候，你可以清楚的看到这是一杯水，也许是一大杯水；但是当你把杯子放入海中，当杯子完全的被淹没时，你就什么也看不到了，尽管你没入水中之前可以把浪花溅得多么漂亮。而当你把杯子再从水中拿出来的时候，空隙很快就填满了，不会留下丝毫的痕迹。&lt;br /&gt;&lt;br /&gt;&lt;b&gt;2印第安人酋长对他的臣民们说:&amp;ldquo;神给了每一个人一杯水,于是,你从里面饮入了生活。&lt;/b&gt;&lt;br /&gt;生活确实就是一杯水,杯子的华丽与否显示了一个人的贫与富。但杯子里的水,清澈透明,无色无味,对任何人都一样。接下来,你有权利加盐、加糖,只要你喜欢。 &lt;br /&gt;&lt;br /&gt;你有欲望,不停地往杯子里加自己喜欢的东西,应适可而止,因为杯子的容量有限。东西太多水却没有了! &lt;br /&gt;&lt;br /&gt;&lt;b&gt;3一杯水你能拿多久？拿一分钟，你一定觉得没问题；拿一个小时，可能觉得手酸；拿一天，你可能就会出问题。其实这杯水的重量没变，但是拿得越久，就觉得越沉重。&lt;/b&gt;&lt;br /&gt;&lt;br /&gt;这就像我们承担的压力一样，如果我们一直把压力放在身上，不管时间长短，到最后我们就觉得压力越来越沉重而无法承担。我们必须做的是，放下这杯水休息一下，然后再拿起这杯水，如此我们才能够拿得长久。 &lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Mozilla建议的CSS书写顺序</title>
   <link href="http://dreambt.github.com/Web Design/2008/01/26/mozilla-css-write-order"/>
   <updated>2008-01-26T18:44:58+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2008/01/26/mozilla-css-write-order</id>
   <content type="html">&lt;p&gt;/&lt;em&gt; mozilla.org Base Styles
* maintained by fantasai
* (classes defined in the Markup Guide - http://mozilla.org/contribute/writing/markup)
&lt;/em&gt;/
/&lt;em&gt; Suggested order:
//显示属性
* display
* list-style
* position
* float
* clear
//自身属性
* width
* height
* margin
* padding
* border
* background
//文本属性
* color
* font
* text-decoration
* text-align
* vertical-align
* white-space
* other text
* content
*
&lt;/em&gt;/&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Web前端工程师技能列表</title>
   <link href="http://dreambt.github.com/Web Design/2008/01/26/front-end-engineer-skills-list"/>
   <updated>2008-01-26T18:16:57+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2008/01/26/front-end-engineer-skills-list</id>
   <content type="html">&lt;p&gt;要打造一流的Web产品开发团队，在团队成员基础能力上一定要下功夫。对于Web前端产品开发来说，仅仅掌握Web1.0时代简单的&quot;网页套接&quot;是完全不够的。我结合自己的团队配备，特此罗列了Web前端产品工程师所涉及的技能列表如下：&lt;/p&gt;

&lt;p&gt;通过许多实际项目，个人认为一个完备的前端产品开发团队，必须拥有如下的人才配备：&lt;/p&gt;

&lt;p&gt;团队全体成员达到所有技能中的a级标准
团队全体成员必须掌握两项技能中的b级标准，并保证所有的b级标准在该团队中有50%以上成员能达到
团队全体成员必须掌握一项技能中的c级标准，并保证所有的c级标准在该团队中有25%以上成员能达到
具体技能描述：&lt;/p&gt;

&lt;p&gt;UserInterface&lt;/p&gt;

&lt;p&gt;PhotoShop/Fireworks Design
a - 配合美工将草图形成具体的符合WebPage的设计
b - 有快速制作分层高品质PSD、PNG的能力
c - 能迅速将PSD、PNG的内容构思成div+css或者table等HTML代码
Flash Design
a - 基本动画效果
b - 复杂的交互体系设计，了解第三方swf辅助设计软件
c - 复杂的交互体系设计以及较强的对各类外埠资源（PNG、JPG、MP3、WAV等）的整合能力。精通部分第三方辅助设计软件（AE、SwishMax、Swift3D等）&lt;/p&gt;

&lt;p&gt;Browser-side (Web Application)&lt;/p&gt;

&lt;p&gt;XHTML/CSS
a - 基本的layout实现
b - 严格跨平台的layout实现以
c - 优雅的HTML code，尽可能符合标准并有SEO的考虑因素。在任何平台、浏览器下基本保持一致。不要求了解各种CSS的hacks，但要求知道遇到问题应该如何查阅资料以在第一时间内解决。能够为JavaScript开发人员提供最好操作的DOM结构，让JS开发人员在开发的时候认为&quot;一切都已经准备就绪了&quot;，而不是&quot;捉襟见肘&quot;。
JavaScript/Ajax/DOM
a - 基本的DOM操作，了解AJAX，可以实现数据通信
b - 基本的DOM操作，能写高效率的OOP代码，以降低维护成本
c - 基于需求，进行不同的开发，选择合适的框架，做到代码效率最高，用户体验最好，代码下载量最小，并且可以在单独甚至更多产品线中最大限度重用代码
Flash Developement
a - 基于Timeline的ActionScript操作，能实现简单交互
b - 掌握a外，能实现数据层通信（与服务器以及本地SharedObject）
c - 精通AS1-3，能根据需求进行各类RIA开发。无论是要求支持FlashPlayer8的，还是FlashPlayer9的，都能做到开发效率最高、灵活性最大（比如对HTML层的接口设计，等等）。&lt;/p&gt;

&lt;p&gt;Client-side (Desktop Application)
Apollo
（待定，欢迎补充）
Windows Presentation Foundation、WPF/E（Silverlight）
（待定，欢迎补充）&lt;/p&gt;

&lt;p&gt;Server-side&lt;/p&gt;

&lt;p&gt;Server-side Language(PHP/ASP/CGI ...)
（待定，欢迎补充）
Media Server / Red5
（待定，欢迎补充）&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Web2.0视觉风格进化论二</title>
   <link href="http://dreambt.github.com/Web Design/2007/02/17/the-theory-of-evolution-web-2-visual-style"/>
   <updated>2007-02-17T11:41:16+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2007/02/17/the-theory-of-evolution-web-2-visual-style</id>
   <content type="html">&lt;p&gt;事实是这样吗？你不妨先回答我下面这两个问题：&lt;/p&gt;


&lt;p&gt;① Web2.0 作为一个新生的&amp;ldquo;概念&amp;rdquo;，是否不需要一个清晰的&amp;ldquo;视觉表现&amp;rdquo;？&lt;br /&gt;② 你认为自己已经找到体现 Web2.0 概念足够清晰的&amp;ldquo;视觉表现方式&amp;rdquo;了吗？&lt;/p&gt;


&lt;p&gt;如果你的回答都是&amp;ldquo;是&amp;rdquo;，那么我强烈建议你不要再往下看这篇文章，它完全在浪费你的时间。&lt;/p&gt;


&lt;p&gt;如果你心存疑虑犹豫不决，而你又想更详细的了解关于&amp;ldquo;WEb2.0视觉风格&amp;rdquo;的内容，就请抱着一同探究的心态，和我一起来完成这个&amp;ldquo;进化过程&amp;rdquo;吧。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;Web2.0 需要&amp;ldquo;视觉识别&amp;rdquo;，吗？&lt;br /&gt;Web2.0 Need &amp;quot;VI&amp;quot;, Is it?&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;如果我们把&amp;ldquo;Web2.0&amp;rdquo;看作&amp;ldquo;形象识别&amp;rdquo;的一个主体（因为它有着区别于以往Web概念的需求），那么我们就很容易看清它应该有的体系结构：作为&amp;ldquo;理念识别 (Mind Identity)&amp;rdquo;的&amp;ldquo;Web2.0概念&amp;rdquo;现在应该不会有人再怀疑，否则你也不会来看我这篇文章。因此我们可以说，作为&amp;ldquo;理念识别&amp;rdquo;的这个部分，已经基本完成。那么在在&amp;ldquo;理念识别&amp;rdquo;指导下的&amp;ldquo;行为识别(Behavior Identity)&amp;rdquo;和&amp;ldquo;视觉识别 (Visual Identity)&amp;rdquo;就应该逐步的完善和清晰起来。&lt;/p&gt;


&lt;p&gt;可喜的是，对于&amp;ldquo;Web2.0的行为特征&amp;rdquo;我们现在也已经有了很明确的概念，它的交互性，参与性，资料的产生和分配的动作方式，可移动性等等都将&amp;ldquo;Web2.0&amp;rdquo;的&amp;ldquo;行为识别&amp;rdquo;进行得如此生动鲜活，你很快就可以判定：&amp;ldquo;噢，这个网站是以web2.0的方式在玩！&amp;rdquo;&lt;/p&gt;


&lt;p&gt;可惜的是，对于&amp;ldquo;视觉识别&amp;rdquo;的范畴，我们拥有了这样一套清晰完整的，可以传达理念，表现特性的&amp;ldquo;视觉组件&amp;rdquo;了吗？没有！&lt;br /&gt;因此，作为有职业敏感和操守的设计师的你，为什么不和我一起来共同把我们需要做的工作完成呢？你还在等着一本装订成册，封面用荧光色印着&amp;ldquo;Web2.0 视觉手册&amp;rdquo;的书送到你的手里吗？Come On, You OUT!&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/web2.0_designer_card_5bkuDYHL7eGr.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：网上的兄弟们自己&amp;ldquo;颁发&amp;rdquo;的&amp;ldquo;Web2.0设计师证&amp;rdquo;，你也可以给自己来一个。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;我真的希望看到这里的你觉得我上面的解释是一大堆废话！因为这说明你真的知道作为一个设计师自己应该去做些什么，想些什么。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;视觉的进化与沿革&lt;br /&gt;Evolution of Visual Elements&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;谈到视觉元素的沿革，很多人兴趣就高涨起来了&amp;mdash;&amp;mdash;你看看论坛上的那些个帖子，点击量最高的，回复最多的不就是&amp;ldquo;最新XXX效果，附教程&amp;rdquo;之类的吗。一些人又说了：我们这不是一直追赶潮流吗？是啊，弄潮和追潮只有一字之差而已。&lt;/p&gt;


&lt;p&gt;好吧，就从论坛的热点帖子说起：之前有个帖子是关于Web2.0的Logo的，这个话题真是热得烫手。可惜的是，我在查找证据之后发现，许多所谓的&amp;ldquo;大公司的新Web2.0风格Logo&amp;rdquo;其实是某些&amp;ldquo;好事者&amp;rdquo;所为。呵呵，不必失望，这些行为颇有点Web2.0的风格，况且，其中的有据可查的确实被采用的Logo，有一小部分，也可以从这些版本中找到&amp;mdash;&amp;mdash;你现在可以把你喜欢的样式直接推荐给产品影响全球数以万亿计客户量的大公司，影响它们，改变它们！你不觉得Web2.0的可爱吗？&lt;/p&gt;


&lt;p&gt;换个角度来讲，很多公司在&amp;ldquo;Web1.0时代&amp;rdquo;没有改变它们的Logo，现在到了&amp;ldquo;Web2.0时代&amp;rdquo;为什么就都迫不及待的要改变Logo的设计呢？这除了说明Web2.0是&amp;ldquo;真正意义上的网络&amp;rdquo;以外，难道你还觉察不出&amp;ldquo;Web2.0的视觉设计&amp;rdquo;的重要吗？&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/web2_1_81wYRGtL0BmG.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：上面这些Logo，下排都是未被证实的&amp;ldquo;自作多情&amp;rdquo;作品。和&amp;ldquo;现任&amp;rdquo;Logo的比对。&lt;/font&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/iCoke_yOHDAc0Kfh87.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：还是来看看真正的Web2.0的色彩和符号在怎么玩吧！大公司老是跑在前面，一点不错，后续的文章还会详细介绍关于&amp;ldquo;可口可乐&amp;rdquo;的进化例子。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;我想说的是，你应该从这些真真假假的Logo中看出来，哪些才是真的符合Web2.0的标准而不被表象的那些所谓的渐变应该怎么拉，高光应该怎么做，影子的参数是多少所迷惑。觉得有些难度是吧？我们的这几篇文章不是为了Web2.0而说Web2.0，只是想从&amp;ldquo;视觉进化&amp;rdquo;的规则中告诉你怎么来鉴别和找出&amp;ldquo;真正的Web2.0风格&amp;rdquo;！&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;进化的概念&lt;br /&gt;What's the meaning of &amp;quot;Evolution&amp;quot;?&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;很清楚，所谓&amp;ldquo;进化&amp;rdquo;，就是在原有&amp;ldquo;物种&amp;rdquo;的基础上向前进步。在英语中的&amp;ldquo;Evolution&amp;rdquo;也可以翻译成&amp;ldquo;演变&amp;rdquo;，但是我宁可用&amp;ldquo;进化&amp;rdquo;这个比较积极的词汇。&lt;/p&gt;


&lt;p&gt;对于视觉元素的进化，由来久矣。谈到这里，我不得不提到一个人，因为我在分析新Web2.0的Logo走向（趋势）时，好多的Logo源头都指向了他，上面那个图里面4个原有的logo，3个都是他设计的。他的名字是：&lt;a href=&quot;http://en.wikipedia.org/wiki/Paul_Rand&quot; target=&quot;_blank&quot;&gt;保罗&amp;middot;兰德（Paul Rand　1914-1996）&lt;/a&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img height=&quot;400&quot; src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/Paul-Rand_5w0qQ6OvzzrV.jpg&quot; width=&quot;300&quot; border=&quot;3&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/Eye_Bee_M_m7UjJL8OwdDs.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：兰德为IBM做的海报，视觉音译了I.B.M (Eye, Bee, M)&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;你可能会奇怪，他怎么会出现在苹果的&lt;a href=&quot;http://members.aol.com/macsbug/thinkdiff.html&quot; target=&quot;_blank&quot;&gt;&amp;ldquo;想法与众不同&amp;rdquo;(Think Different)&lt;/a&gt;海报里，这里我引用一段介绍，详细的，你可以区下面的链接找寻。&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;保罗.兰德（Paul Rand，1914-1996）兰德作为当今美国乃至世界上最杰出的图形设计师、思想家及设计教育家之一，其先导地位和作用是勿庸争辩的。&lt;br /&gt;兰德1929-1932年就学于纽约Parsons设计学院。年仅23岁便成为Esquire Coronet广告公司的艺术指导，在随后的三十多年里他一直担任纽约广告代理公司的创意指导，也曾受聘为许多美国著名大公司的设计师或设计顾问，其中包括美国广播公司(ABC)、IBM公司、西屋电器公司、NEXT电脑公司、UPS快递公司、耶鲁大学等艺术顾问。他为这些公司和机构所设计的企业标志 ，已成了家喻户晓的经典之作。&lt;br /&gt;半个多世纪以来，他在视觉设计方面的建树和前卫精神对整个图形设计领域而言，影响巨大而深远。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;详细: &lt;a href=&quot;http://www.artcn.cn/Article/pmsj/wgsjs/200604/9407.html&quot; target=&quot;_blank&quot;&gt;http://www.artcn.cn/Article/pmsj/wgsjs/200604/9407.html&lt;/a&gt;&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/web2_2_1g8ETqFxIM99.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：上面用亮色表明年代的Logo，即是兰德的杰作了。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;我们向兰德致敬，感谢他为我们留下了这么多可以追寻的脉络，可以让我们踏着他的脚印向正确的方向行进。从某种意义上讲，我们现在面临的课题，也是当年兰德遇到的问题。但是庆幸的是，我们现在有了更多更便捷的方式来获取资讯，完成新一轮的&amp;ldquo;视觉元素的进化&amp;rdquo;过程。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;苹果风格是否就是web2.0风格？&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;为了不使有些人觉得枯燥，我决定把这个小节提到前面来讲。同时，我也正在改善我的&amp;ldquo;笔调&amp;rdquo;更Web2.0一些，希望大家不是正襟危坐的凝视这几行字，而是陷在沙发的一角用手机看小说的感觉。&lt;/p&gt;


&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/02/4479/iconaccessories_l8BagauXYHq1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;苹果风格是否就是web2.0风格？这个话题好像会使人感到困惑：的确，那些该死的苹果设计师团队每天都在&amp;ldquo;&lt;a href=&quot;http://en.wikipedia.org/wiki/Think_Different&quot; target=&quot;_blank&quot;&gt;Think Different&lt;/a&gt;&amp;rdquo;，难怪它们会跑在前面，因为它们会最快的找到&amp;ldquo;Good of Different&amp;rdquo;。不可否认，苹果确实创造并引领了好长一段时间的潮流。但是给我的感觉，自从1997年微软的&amp;ldquo;毒血&amp;rdquo;注入苹果之后，苹果的创造力就大不如前。（注：1997年8月6日，微软首次动用1.5亿美元购买苹果公司非投票股份）&lt;/p&gt;


&lt;p&gt;撇开这些&amp;ldquo;政治经济学&amp;rdquo;不谈，我们还是从理念上分析一下苹果的行为：&lt;/p&gt;


&lt;p&gt;①提高产品使用的愉悦感（不仅是舒适感），超越仅限于功能的满足。&lt;br /&gt;②为了愉悦视觉触觉&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Web2.0视觉风格进化论一</title>
   <link href="http://dreambt.github.com/Web Design/2007/02/17/the-theory-of-evolution-web-1-visual-style"/>
   <updated>2007-02-17T11:40:03+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2007/02/17/the-theory-of-evolution-web-1-visual-style</id>
   <content type="html">&lt;p&gt;&lt;b&gt;导语&lt;/b&gt;&lt;/p&gt;


&lt;p&gt;在设计论坛之前的讨论中曾经谈到过&amp;ldquo;设计师应该抓住这个时代的情感&amp;rdquo;，这是设计师的设计嗅觉和职业特性的体现，那么在纷纷扰扰中&amp;ldquo;裂变&amp;rdquo;的Web2.0向我们袭来之时，作为设计师的你，抓住了Web2.0的趋势与风格了吗？现在我们从设计演变的角度，通过分析和鉴别，来让我们的设计师们快速的进行&amp;ldquo;向 Web2.0风格的进化&amp;rdquo;过程！&lt;/p&gt;


&lt;p&gt;&lt;b&gt;引论&lt;/b&gt;&lt;/p&gt;


&lt;p&gt;在设计论坛之前的讨论中曾经谈到过&amp;ldquo;&lt;a href=&quot;http://bbs.blueidea.com/thread-2667788-1-1.html&quot; target=&quot;_blank&quot;&gt;设计师应该抓住这个时代的情感&lt;/a&gt;&amp;rdquo;，这是设计师的设计嗅觉和职业特性的体现，那么在纷纷扰扰中&amp;ldquo;裂变&amp;rdquo;的Web2.0向我们袭来之时，作为设计师的你，抓住了Web2.0的趋势与风格了吗？现在我们从设计演变的角度，通过分析和鉴别，来让我们的设计师们快速的进行&amp;ldquo;向 Web2.0风格的进化&amp;rdquo;过程！&lt;/p&gt;


&lt;p&gt;&lt;b&gt;什么是&amp;ldquo;风格&amp;rdquo;&lt;br /&gt;What is the &amp;quot;Style&amp;quot;?&lt;/b&gt;&lt;/p&gt;


&lt;p&gt;什么是&amp;ldquo;风格&amp;rdquo;? 汉语词典中说它是：一个时代、一个民族、一个流派或一个人的文艺作品所表现的主要的思想特点和艺术特点。&lt;br /&gt;简而言之，它应该包含 ①时代特色 ②思想特色 ③表现特色。在英文中，&amp;ldquo;风格&amp;rdquo;的对应词是&amp;ldquo;Style&amp;rdquo;&lt;font color=&quot;#696969&quot;&gt;(发音：时'代要)&lt;/font&gt;，然而，&amp;ldquo;In Style&amp;rdquo;的意思译成中文是&amp;ldquo;有品味&amp;rdquo;。那么我们是不是把上面那句话也可以理解成为&amp;ldquo;一个有品味的设计师应该抓住今天的风格&amp;rdquo;呢？是了，如果作为一个设计师，连当下的风格都把握不住，又如何去创造或者引领未来的风格？&lt;/p&gt;


&lt;p&gt;&lt;b&gt;风格的视觉组成元素&lt;/b&gt;&lt;/p&gt;


&lt;p&gt;既然我们是讨论 视觉风格，就应当了解一种特别的视觉风格到底是由哪些部分构成&amp;mdash;&amp;mdash;我努力的想去找到一些前辈大师的言论来当外套，让我的论点显得更&amp;ldquo;优雅华丽&amp;rdquo;一些，但是很可惜的没有如愿。我只好把我的见解就这样&amp;ldquo;赤裸裸&amp;rdquo;的展现出来。&lt;br /&gt;我仔细的回味了传统美术和设计史中对各阶段风格的描述，认为能反映一个&amp;ldquo;成熟的风格&amp;rdquo;的特征元素应该是以下四个方面：&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/01/4442/Web2_P1_Bad3yBYPJhDU.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;① 色彩倾向：&lt;/strong&gt;如同我在之前的一篇文章《&lt;a href=&quot;http://www.blueidea.com/design/doc/2006/3258.asp&quot; target=&quot;_blank&quot;&gt;关于时间和色彩的游戏&lt;/a&gt;》里面谈到的那样，色彩的规划在现代设计中的地位已经跃升到最高的地位。这一点我想各位都不会怀疑，即便是时隔久远，你也不会将&amp;ldquo;&lt;a href=&quot;http://140.126.32.82/arthistory/Impressionism.htm&quot; target=&quot;_blank&quot;&gt;印象派风格&lt;/a&gt;&amp;rdquo;的色彩和&amp;ldquo;&lt;a href=&quot;http://140.126.32.82/arthistory/baroque.htm&quot; target=&quot;_blank&quot;&gt;巴洛克风格&lt;/a&gt;&amp;rdquo;的色彩相混淆；或者说得简单点，你绝不会听到&amp;ldquo;可乐&amp;rdquo;想到绿色，而听到&amp;ldquo;雪碧&amp;rdquo;想到红色，这就是因为它们有不同的&amp;ldquo;色彩风格&amp;rdquo;。&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：印象派的色彩追求感性，笔调欢快。巴洛克属华丽的古典风格，色彩理性，忠实而严谨。其实你也可以把印象派理解成为大光圈高快门速度的高饱和度照片，而巴洛克是追求精致的小光圈慢快门写实照片。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;在后续的文章里，我们会一起来看看这些关于Web2.0视觉风格的特征元素，因为色彩一节比较特殊而重要，我决定将它放在最后来讲，因为我怕可能会越讲越长，让整个文章的结构打乱掉。（其实我准备给蓝色的说辞是：希望先发些相关的内容，看看点击量和关注程度来决定后续的内容。唉，蓝色是我遇到的最没有机心的人，是机心不是心机，没错。）&lt;/p&gt;


&lt;p&gt;写到这里我觉得我似乎在血液里也开始涌动着Web2.0的泡泡，它影响我的行文风格发生了些许小小的变化，不是吗？这就是潜移默化的进化过程。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/01/4442/Web2_P2_toD3QSqRBwbs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;② 结构布局：&lt;/strong&gt;这个在传统美术中叫做构图，书法叫章法，国画叫布局，现代设计中叫构成，排版上称版式设定&amp;hellip;&amp;hellip;说这么多，无非是想告诉你：你了解其中的任何一个词汇，你就明白我想表达什么了。举例来讲，即便你没练过书法，你也不会把颜体和欧体相混淆，因为颜体的丰腴宽厚的结构特征和欧体的险峻严整会让你过目不忘，这是结构上的风格区分。&lt;/p&gt;


&lt;p&gt;书法太难理解？OK，想一下中世纪欧洲宫廷的梳妆台和你在&amp;ldquo;&lt;a href=&quot;http://www.ikea.com/ms/zh_CN/&quot; target=&quot;_blank&quot;&gt;宜家&lt;/a&gt;&amp;rdquo;(&lt;a href=&quot;http://www.ikea.com/&quot; target=&quot;_blank&quot;&gt;IKEA&lt;/a&gt;)买回来的电脑桌有什么不同就好了。&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：我老是在怀疑用书法作比喻会不会产生岐义，因为书法的结构和用笔（也就是表现方法）是捆绑在一起的，你不可能用左边颜体的笔画去写右边欧体的间架。但是设计中却是可以用不同的表现方法套用在同一个结构上的，希望没有给大家带来困惑。&lt;/font&gt;&lt;br /&gt;&lt;br /&gt;乔纳山(Jonathan)的&amp;ldquo;&lt;a href=&quot;http://www.blueidea.com/design/doc/2007/4432.asp&quot; target=&quot;_blank&quot;&gt;Web2.0的视觉设计&lt;/a&gt;&amp;rdquo;(&lt;a href=&quot;http://f6design.com/journal/2006/10/21/the-visual-design-of-web-20/&quot; target=&quot;_blank&quot;&gt;The visual design of Web 2.0&lt;/a&gt;)中认为Web2.0的布局排版部分占的比重不是太大，但是我觉得他指的是布局的难度系数而不是布局的展现方式。就像下围棋，Web2.0可能就是一盘布局简单的棋，但是你不能说布局简单厮杀就不精彩，就没有胜负可言，那就错了。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/01/4442/Web2_P3_lSGPxGEYUVPU.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;③ 造型方法：&lt;/strong&gt;作为一个艺术家，掌握多种艺术方法和找到合适的造型方法来完成自己的作品，恐怕是一生的追求。就像 &lt;a href=&quot;http://www.artcyclopedia.com/artists/picasso_pablo.html&quot; target=&quot;_blank&quot;&gt;毕加索(Pablo Picasso)&lt;/a&gt; 对着一头&lt;a href=&quot;http://www.allposters.com/gallery.asp?CID=A20547CA364F40BD8C1DFA1559DD9F74&amp;amp;txtSearch=Picasso&amp;amp;image1.x=22&amp;amp;image1.y=13&quot; target=&quot;_blank&quot;&gt;公牛 (Le Taureau)&lt;/a&gt;画七八遍一样，很多勤奋的人都在这么干。设计师也面对同样的问题，同样的题材可以有好多种表现的方法，你能想到有多少种，在于你的创造力；你能否找到合适表现你的题材的那种，在于你的判断和鉴赏力。想要成为一个优秀的设计师，就必须锻炼这两种力。现在你应该了解什么是一个&amp;ldquo;Powerful Design&amp;rdquo;了。&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：公牛，我只采用了首尾和中间的4个，其实毕加索画了11个同样的这个牛，目的是探索抽象的方法，摆在一起就显示出从写实到抽象的进化过程。右边的苹果Logo，也是显示出不同时期的进化过程，最右下角那个你也许觉得陌生，那就是传说中的Web2.0的苹果Logo。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;Web2.0应该从现有的造型方法中选择一个什么样的方式，或者派生，或者改良出一个怎样的造型方式来与众不同呢？我们的后续文章会慢慢告诉你。&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;http://www.blueidea.com/articleimg/2007/01/4442/Web2_P4_nSpvNACEU7qd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;④ 笔调特色：&lt;/strong&gt;笔调这个词很好，很传神，它既可以用来对比不同的艺术家的作品，也可以用来对比某个艺术家自己的不同作品。&lt;br /&gt;比如，我们可以说 &lt;a href=&quot;http://www.artcyclopedia.com/artists/van_gogh_vincent.html&quot; target=&quot;_blank&quot;&gt;梵高(Vincent van Gogh)&lt;/a&gt; 的&amp;ldquo;&lt;a href=&quot;http://www.artcyclopedia.com/goto/prints-375608&quot; target=&quot;_blank&quot;&gt; 星夜(Starry Night) &lt;/a&gt;&amp;rdquo;和&amp;ldquo;&lt;a href=&quot;http://www.allposters.com/-sp/Sunflowers-Posters_i373567_.htm&quot; target=&quot;_blank&quot;&gt; 向日葵(Sunflowers) &lt;/a&gt;&amp;rdquo;笔调完全不同，这里的&amp;ldquo;笔调&amp;rdquo;，不光是指&amp;ldquo;笔触&amp;rdquo;，还指画面所带给我们的可以感知的画作者创作时的一种心态。同样的内容，笔调不同就产生不同的情态。&lt;/p&gt;


&lt;p&gt;&lt;font color=&quot;#2f4f4f&quot;&gt;图注：左边梵高的画作对比很好的表达了&amp;ldquo;笔调&amp;rdquo;的解释。右边的图是想告诉你不同时代的同一题材的表现差异，同样是莲花图案，传统的古典手法和现代数码的风格是如此迥异。&lt;/font&gt;&lt;/p&gt;


&lt;p&gt;Web2.0带给我们一种新的态度，开放的，交互的，松散的，闲适的，不断进步的&amp;hellip;&amp;hellip;那么在这种情绪和氛围的影响下我们应该表现出什么样的东西呢？或者反过来讲，用什么样的笔调来表现才能体现这种态度来告诉大家：我已经是Web2.0了！呢？&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>div+css命名参考</title>
   <link href="http://dreambt.github.com/Web Design/2007/01/14/div-css-name"/>
   <updated>2007-01-14T03:46:21+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2007/01/14/div-css-name</id>
   <content type="html">&lt;p&gt;用了一段CSS 布局设计网页,发现自己的命名有点混乱,完全按照自己的想法命名,虽然没什么影响,有不给别人看源文件,但是工作室有时候和团队合作完成项目的时候,就遇到麻烦了,要修改一个地方相当的费事.所以还是有个标准比较好啊!在网上看到的一个相关的参考,再加上平时也研究别人的代码,发现这样的命名使用很广泛!我再加上自己的经验,希望对看到这篇文章的人能有用!&lt;/p&gt;

&lt;p&gt;命名参考&lt;/p&gt;

&lt;p&gt;常用的CSS命名规则：&lt;/p&gt;

&lt;p&gt;头：header
内容：content/container
尾：footer
导航：nav
侧栏：sidebar
栏目：column
页面外围控制整体布局宽度：wrapper
左右中：left right center&lt;/p&gt;

&lt;p&gt;命名全部使用小写字母，如果需要多个单词，单词间使用“-”分隔，比如user-list&lt;/p&gt;

&lt;p&gt;常用代码结构：&lt;/p&gt;

&lt;p&gt;div：主要用于布局，分割页面的结构
ul/ol：用于无序/有序列表
span：没有特殊的意义，可以用作排版的辅助，例如&lt;/p&gt;

&lt;div class=&quot;UBBPanel&quot;&gt;&lt;div class=&quot;UBBTitle&quot;&gt;&lt;img src=&quot;images/code.gif&quot; style=&quot;margin:0px 2px -3px 0px&quot; alt=&quot;程序代码&quot;/&gt; 程序代码&lt;/div&gt;&lt;div class=&quot;UBBContent&quot;&gt;&lt;li&gt;&lt;span&gt;(4.23)&lt;/span&gt;天幻网六周年天幻网六周年天幻网六周年天幻网六&lt;/li&gt;&lt;/div&gt;&lt;/div&gt;


&lt;p&gt;然后在css中定义span为右浮动，实现了日期和标题分两侧显示的效果&lt;/p&gt;

&lt;p&gt;h1-h6：标题
h1-h6 根据重要性依次递减
h1位最重要的标题&lt;/p&gt;

&lt;p&gt;label：为了使你的表单更有亲和力而且还能辅助表单排版的好东西，例如：
[code]&lt;label for=&quot;user-password&quot;&gt;密　码&lt;/label&gt;
&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;user-password&quot; /&gt;[/code]
fieldset &amp;amp; legend：fildset套在表单外，legend用于描述表单内容。例如：
[code]&lt;form&gt;
&lt;fieldset&gt;
&lt;legend&gt;title&lt;/legend&gt;
&lt;label for=&quot;user-password&quot;&gt;密　码&lt;/label&gt;
&lt;input type=&quot;password&quot; name=&quot;password&quot; id=&quot;user-password&quot; /&gt;
&lt;/fieldset&gt;
&lt;/form&gt;[/code]&lt;/p&gt;

&lt;p&gt;dl,dt,dd：当页面中出现第一行为类似标题/简述，然后下面为详细描述的内容时应该使用该标签，例如
[code]&lt;dl&gt;
&lt;dt&gt;什么是CSS?&lt;/dt&gt;
&lt;dd&gt;CSS就是一种叫做样式表（stylesheet）的技术。也有的人称之为层叠样式表（Cascading Stylesheet）。&lt;/dd&gt;&lt;dd&gt;
&lt;dt&gt;什么是XHTML？&lt;/dt&gt;
&lt;/dd&gt;&lt;dd&gt;XHTML是一个基于XML的置标语言，看起来与HTML有些想像，只有一些小的但重要的区别。可以这样看，XHTML就是一个扮演着类似HTML的角色的XML。 本质上说，XHTML是一个桥接（过渡）技术，结合了XML（有几分）的强大功能及HTML（大多数）的简单特性。&lt;/dd&gt;
&lt;/dl&gt;[/code]&lt;/p&gt;

&lt;p&gt;[code]C #content&lt;/p&gt;

&lt;p&gt;S #subcol&lt;/p&gt;

&lt;p&gt;M #maincol&lt;/p&gt;

&lt;p&gt;X #xcol[/code]
这是纵向布局的XHTML结构，c-smx表示网页有三个纵栏, c-sm表示有两个纵栏, c-mx表示有两个纵栏其中一个是附属的, c-m表示一个纵栏。&lt;/p&gt;

&lt;p&gt;其中在三纵栏的布局需要分为两层 第一层是#subcol与#main第二层是#main中的#maincol与#xcol。&lt;/p&gt;

&lt;p&gt;自定义命名：
根据w3c网站上给出的,最好是用意义命名
比如：是重要的新闻高亮显示（像红色）
有两种
[code].red{color:red}
.important-news{color:red}[/code]
很显然第二种传达的意义更加明确,所以尽量不要用意义不明确的作为自己自定义的名字&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>"Web标准"大白话版</title>
   <link href="http://dreambt.github.com/Web Design/2007/01/14/web-standard"/>
   <updated>2007-01-14T03:38:24+08:00</updated>
   <id>http://dreambt.github.com/Web Design/2007/01/14/web-standard</id>
   <content type="html">&lt;p&gt;前几天，版面上,就“web标准”的含义争论不休，我本想活跃一下版面气氛，就没限制，谁知道演变成口水贴，今天又有人问到了到底什么是WEB标准？,我就给他用大白话解释了一下，也觉得有意义把这个名词说的通俗一点，要不然新手们会以为这玩意有多么的深奥。&lt;/p&gt;

&lt;p&gt;先看看两幅漫画，描述的是HTML，CSS两个语言的分工
HTML建造工的角色
&lt;img src=&quot;upload/month_08-01/z200812623846.png&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
CSS粉刷匠的角色
&lt;img src=&quot;upload/month_08-01/8200812623918.png&quot; border=&quot;0&quot; alt=&quot;&quot;/&gt;
根据很直观的漫画，相信分工方面就比较了解是怎么回事了，下面开始大白话名词解释，声明“大白话肯定不像专业术语那样全面，完善，但是能将问题很快的讲明白。”&lt;/p&gt;

&lt;p&gt;Web Standards&lt;/p&gt;

&lt;p&gt;Standards是个复数，就知道他是有好几个标准或者规范组成的，分别是:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;结构规范 XML ,XHTML;
 &lt;/li&gt;&lt;li&gt;表现规范 CSS;
 &lt;/li&gt;&lt;li&gt;行为规范 DOM,ECMAScript;
&lt;/li&gt;&lt;/ul&gt;


&lt;p&gt;上面是理论，也就是说源自这些个东西，“规范，标准”就是统一规格的意思，让大家按照那些统一的规格进行网页制作的编码，最常用的就两个XHTML 1.0 CSS2.1，把它们的要求弄明白了，就去照着规格编写代码就是了。&lt;/p&gt;

&lt;p&gt;实际上， “网页标准化”，就是个称呼，不能望文生义，不就是做网页嘛！原来的方法没有按照规范走，现在觉得规范很有意义，就跟着规范走了。起这个名字也就是出师有名，好宣传推广。&lt;/p&gt;

&lt;p&gt;想关注这方面，你要做的也很简单。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;学习html语言是怎么回事，那些个标签是做什么的，然后把你所表达的信息（文字，图片，乱七八糟的）用这种语言组织起来，把代码写规范了，这就是良好的结构和语义化。&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;2.学习CSS，知道CSS是干什么的，他就是个粉刷匠，做美化网页工作的，美化大家都知道怎么回事吧？就是把1里面你做的那堆东西，美化一下，首先是布局，布局完了，文字排一下版，其他的那就是背景的事情了。
CSS人家的工作就是美化，可你HTML偏要跟人叫板，整个什么table，font的那叫自己不行，还要抢人饭碗。
但是浏览器对CSS2.1规范支持的不好，所以兼容浏览器的问题就有点头疼，这个方面要作的就是有的放矢，知道问题出在哪里？然后就这个具体问题去解决，解决的根本方法就是CSS hack，看看各个浏览器品性，支持哪个，不支持哪个，别人支持的他不支持，别人不支持的他支持，就钻这个空子，就能解决不兼容问题了。&lt;/p&gt;

&lt;p&gt;3.行为脚本，他是做交互用的，根据事件，也就是你的操作，单击阿，双击阿，回车阿，鼠标滑过阿等等，去响应这些操作，所以他就类似动画指导，有个时间轴，有个因果关系，也就是为什么前两个没有选择循环等这种语句。所以他的工作就是响应操作，用行为脚本去实现CSS美化作用，那是抢人饭碗。&lt;/p&gt;

&lt;p&gt;大家各司其职，别掺乎别人的事情，这就叫做分离。&lt;/p&gt;

&lt;p&gt;剩下的工作就交给浏览器了，按照这些个规范，管他PC浏览器，手持设备，盲人浏览器，打印阿，都可以兼容了，这也就是为什么人家W3C花好几年制定维护那些个规范的原因了。&lt;/p&gt;
</content>
 </entry>
 
 
</feed>